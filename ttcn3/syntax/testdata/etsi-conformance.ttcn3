/***************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:9, Ensure that the the IUT receives the message sent by mycompA
 ** @verdict  pass accept, ttcn3verdict:pass
 ** @configuration  port:broadcast
 ***************************************************/

//Mycomp A has two ports and MycompB has two ports.
module Sem_0901_Communication_ports_005{ 
  
	type port myport message {
	  inout integer
	}


type component Mysystem
	{
	timer t_rec,t_rec2;
 	port myport messagePort1,messagePort2;
	}
function fsend() runs on Mysystem {
messagePort1.send(1);
messagePort2.send(2);
	t_rec2.start(20.0);
	alt {
     [] messagePort1.receive(3) {
        setverdict(pass);
     }
     [] messagePort1.receive {
        setverdict(fail);
     }
    		[] t_rec2.timeout {
			setverdict( inconc );
		}
		}
	alt {
     [] messagePort2.receive(4) {
        setverdict(pass);
     }
     [] messagePort2.receive {
        setverdict(fail);
     }
    		[] t_rec2.timeout {
			setverdict( inconc );
		}
		}
t_rec2.stop;
}
function frec() runs on Mysystem {
 t_rec.start( 20.0 );
	alt {
		[]  messagePort1.receive(1) {
			messagePort1.send(3);
			setverdict( pass );
		}
		[] messagePort1.receive {
			setverdict( fail );
		}
		[] t_rec.timeout {
			setverdict( inconc );
		}
		}
		alt {
		[]  messagePort2.receive(2) {
			messagePort2.send(4);
			setverdict( pass );
		}
		[] messagePort2.receive {
			setverdict( fail );
		}
		[] t_rec.timeout {
			setverdict( inconc );
		}
		}
t_rec.stop;
}
	
testcase TC_Sem_0901_Communication_ports_005() runs on Mysystem system Mysystem {
   var Mysystem MyCompA;
   var Mysystem MyCompB;
	
MyCompA:=Mysystem.create;
MyCompB:=Mysystem.create;
connect(MyCompA:messagePort1,MyCompB:messagePort1);
connect(MyCompB:messagePort2,MyCompA:messagePort2);

	
MyCompB.start(frec());
MyCompA.start(fsend());

MyCompB.stop;
MyCompA.stop;
}
control{
    execute(TC_Sem_0901_Communication_ports_005());
}
}
/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:9, Ensure that the IUT correctly handles loopback message 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
 
// Loopback test: messagePort is a loopback port and sends (2). If receives(2) pass, else failed.
module Sem_0901_Communication_ports_001{ 


    type port loopbackPort message {
	  inout integer
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_0901_Communication_ports_001() runs on GeneralComp {


 messagePort.send(2);  //can send also in-line template

    alt {
     [] messagePort.receive(2) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_0901_Communication_ports_001());
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:9.1, Verify that a component port can be connected to two other component ports
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/*NOTE: figure 6(g): A component port can be connected to two other component ports */

module Sem_0901_Communication_ports_009 {
  
    type port MyPort message {
        inout integer
    }

    type component GeneralComp
    {
        port MyPort p;
    }

	function checkConnected() runs on GeneralComp
	{
		if(p.checkstate("Connected")) {
			setverdict(pass,"Connected");			
		} else {
			setverdict(fail,"Not Connected");
		}
	}
	
    testcase TC_Sem_0901_Communication_ports_009() runs on GeneralComp system GeneralComp {
        
//creating 3 components:        
		var GeneralComp v_ptcA := GeneralComp.create;
        var GeneralComp v_ptcB := GeneralComp.create;
        var GeneralComp v_ptcC := GeneralComp.create;
	
		
        connect(v_ptcA:p, v_ptcB:p);
		connect(v_ptcA:p, v_ptcC:p);
        
		v_ptcB.start(checkConnected());
		v_ptcC.start(checkConnected());
			
    }
	
    control{
        execute(TC_Sem_0901_Communication_ports_009());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:9.1, Verify that more than one component port can mapped to a single system port
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// Figure 6: Allowed connections, connection scheme h)

module Sem_0901_Communication_ports_008 {
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p;
    }

	function checkMapped() runs on GeneralComp
	{
		if(p.checkstate("Mapped")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	
    testcase TC_Sem_0901_Communication_ports_007() runs on GeneralComp system GeneralComp {
		// components are created alive so that their mappings are not destroyed when behaviour stops
		var GeneralComp v_ptc1 := GeneralComp.create alive,
			v_ptc2 := GeneralComp.create alive;
		map(self:p, system:p);
		map(v_ptc1:p, system:p);
		map(v_ptc2:p, system:p);
		v_ptc1.start(checkMapped());
		v_ptc2.start(checkMapped());
		checkMapped();
		all component.done;
    }
	
    control{
        execute(TC_Sem_0901_Communication_ports_007());
    }
}

/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:9, Ensure that the IUT correctly handles message exch. between ports
 ** @verdict  pass accept, ttcn3verdict:pass
 ** @configuration  port:broadcast
 ***************************************************/

// GeneralComp has two ports. mess.portA sends a message to messageportB.
module Sem_0901_Communication_ports_004{ 


    type port IntegerPortType message {
	  inout integer
	}
	

type component GeneralComp {	    	    
	  port IntegerPortType messagePortA,messagePortB 
}	

testcase TC_Sem_0901_Communication_ports_004() runs on GeneralComp {


 messagePortA.send(2);  //can send also in-line template

    alt {
     [] messagePortB.receive(2) {
        setverdict(pass);
     }
     [] messagePortB.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_0901_Communication_ports_004());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:9.1, Verify that a port can connect to another port of the same component
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// Figure 6: Allowed connections, connection scheme f)

module Sem_0901_Communication_ports_007 {
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p1, p2;
    }
	
    testcase TC_Sem_0901_Communication_ports_007() runs on GeneralComp system GeneralComp {
		connect(self:p1, self:p2);
		if(p1.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
    }
	
    control{
        execute(TC_Sem_0901_Communication_ports_007());
    }
}

/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:9.1, Verify that a port can connect to itself
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// Figure 6: Allowed connections, connection scheme e)

module Sem_0901_Communication_ports_006 {
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p;
    }
	
    testcase TC_Sem_0901_Communication_ports_006() runs on GeneralComp system GeneralComp {
		connect(self:p, self:p);
		if(p.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
    }
	
    control{
        execute(TC_Sem_0901_Communication_ports_006());
    }
}

/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:9, Ensure that the the IUT receives the message sent by mycompB and mycompC
 ** @verdict  pass accept, ttcn3verdict:pass
 ** @configuration  port:broadcast
 ***************************************************/

// 3 component message exchange
module Sem_0901_Communication_ports_003{ 
  
	type port myport message {
	  inout integer
	}


type component Mysystem
	{
	timer t_rec,t_rec2;
 	port myport messagePort;
	}
function fsend() runs on Mysystem {
	messagePort.send(2) to all component;
	t_rec2.start(30.0);
	alt {
     [] messagePort.receive(3) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    		[] t_rec2.timeout {
			setverdict( inconc );
		}
		}
t_rec2.stop;
}
function frec() runs on Mysystem {
 t_rec.start( 10.0 );
	alt {
		[]  messagePort.receive(2) {
			messagePort.send(3);
			setverdict( pass );
		}
		[] messagePort.receive {
			setverdict( fail );
		}
		[] t_rec.timeout {
			setverdict( inconc );
		}
		}
t_rec.stop;
}
	
testcase TC_Sem_0901_Communication_ports_003() runs on Mysystem system Mysystem {
   var Mysystem MyCompA;
   var Mysystem MyCompB;
   var Mysystem MyCompC;
	
MyCompA:=Mysystem.create;
MyCompB:=Mysystem.create;
MyCompC:=Mysystem.create;
connect(MyCompA:messagePort,MyCompB:messagePort);
connect(MyCompB:messagePort,MyCompA:messagePort);
connect(MyCompA:messagePort,MyCompC:messagePort);
connect(MyCompC:messagePort,MyCompA:messagePort);

	
MyCompB.start(frec());
MyCompC.start(frec());
MyCompA.start(fsend());

/*	alt {
     [] messagePort.receive(3) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }*/
MyCompB.stop;
MyCompC.stop;
MyCompA.stop;
}
control{
    execute(TC_Sem_0901_Communication_ports_003());
}
}

/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:9.1, Verify that a component port can be mapped to TSI port
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/*    NOTE: figure 6(b): Ensure that a component port can be mapped to a TSI port */

module Sem_0901_Communication_ports_010 {
  
    type port MyPort message {
        inout integer
    }

    type component GeneralComp
    {
        port MyPort p;
    }
    
    type component MyCompA
    {
        port MyPort p;
    }

    	function checkMapped() runs on MyCompA
	{
		if(p.checkstate("Mapped")) {
			setverdict(pass,"Mapped");			
		} else {
			setverdict(fail,"Not Mapped");
		}
	}
	
    testcase TC_Sem_0901_Communication_ports_010() runs on MyCompA system GeneralComp {
        
        map(self:p,system:p);
     	checkMapped();
    }
	
    control{
        execute(TC_Sem_0901_Communication_ports_010());
    }
}/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:9, Ensure that the the IUT receives the message sent by mycompA
 ** @verdict  pass accept, ttcn3verdict:pass
 ** @configuration  port:broadcast
 ***************************************************/

// Two component mycompA and B message exchange
module Sem_0901_Communication_ports_002{ 
  
	type port myport message {
	  inout integer
	}


type component Mysystem
	{
	timer t_rec,t_rec2;
 	port myport messagePort;
	}
function fsend() runs on Mysystem {
messagePort.send(2);
	t_rec2.start(20.0);
	alt {
     [] messagePort.receive(3) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    		[] t_rec2.timeout {
			setverdict( inconc );
		}
		}
t_rec2.stop;
}
function frec() runs on Mysystem {
 t_rec.start( 20.0 );
	alt {
		[]  messagePort.receive(2) {
			messagePort.send(3);
			setverdict( pass );
		}
		[] messagePort.receive {
			setverdict( fail );
		}
		[] t_rec.timeout {
			setverdict( inconc );
		}
		}
t_rec.stop;
}
	
testcase TC_Sem_0901_Communication_ports_002() runs on Mysystem system Mysystem {
   var Mysystem MyCompA;
   var Mysystem MyCompB;
	
MyCompA:=Mysystem.create;
MyCompB:=Mysystem.create;
connect(MyCompA:messagePort,MyCompB:messagePort);
connect(MyCompB:messagePort,MyCompA:messagePort);

	
MyCompB.start(frec());
MyCompA.start(fsend());

MyCompB.stop;
MyCompA.stop;
}
control{
    execute(TC_Sem_0901_Communication_ports_002());
}
}

/***************************************************
 ** @author   STF 478
 ** @version  0.0.1
 ** @purpose  1:9.1, Verify that a component ports can be mapped to TSI ports
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/*    NOTE: figure 6(d): Ensure that component ports can be mapped to a TSI ports */

module Sem_0901_Communication_ports_011 {
  
    type port MyPort message {
        inout integer
    }

    type component GeneralComp
    {
        port MyPort p1,p2;
    }

    type component MyComp
    {
        port MyPort p1,p2;
    }
	function checkMapped() runs on MyComp
	{
		if(p1.checkstate("Mapped") and p2.checkstate("Mapped")) {
			setverdict(pass,"Mapped");			
		} else {
			setverdict(fail,"Mapped");
		}
	}
	
    testcase TC_Sem_0901_Communication_ports_011() runs on MyComp system GeneralComp {
        
       map(self:p1, system:p1);
       map(self:p2, system:p2);
        
       checkMapped();
    }
	
    control{
        execute(TC_Sem_0901_Communication_ports_011());
    }
}/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:9, Ensure that the IUTs two ports are mapped correctly to system interfaces 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

//Two ports are mapped to two system interface
module Sem_0902_Communication_ports_002{ 

 type port loopbackPort message {
	  inout integer
		}
 type port MyMessagePortType message {
	  inout integer
		}	

type component GeneralComp
{
var integer v_received1:=0;
var integer v_received2:=0;
port MyMessagePortType myPortA,myPortB
}

type component MyTestSystemInterface
	{
 	port loopbackPort messagePortA,messagePortB
	}
	
// MyTestSystemInterface is the test system interface
testcase TC_Sem_0902_Communication_ports_002() runs on GeneralComp system MyTestSystemInterface {
// establishing the port connections
map(mtc:myPortA, system:messagePortA);
map(mtc:myPortB, system:messagePortB);


 myPortA.send(2);  //can send also in-line template
 myPortB.send(3); 

    myPortA.receive(integer:?) -> value v_received1 ;
    myPortB.receive(integer:?) -> value v_received2 ;
    
    if ((v_received1+v_received2)==5)
    {
        setverdict(pass);
     }
     else
     {
        setverdict(fail);
     }
}

control{
    execute(TC_Sem_0902_Communication_ports_002());
}

}
/***************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:9, Ensure that two component can be mapped by one system interface 
** @verdict  pass accept, noexecution
 ***************************************************/
 //Two components are mapped to the same system interface
module Syn_0902_Communication_ports_001{ 

    type port myPort message {
	  inout integer
		}
	
	
type component MyTestSystemInterface
	{
 	port myPort messagePort;
	}
	
// MyTestSystemInterface is the test system interface
testcase TC_Syn_0902_Communication_ports_001() runs on MyTestSystemInterface system MyTestSystemInterface {
// establishing the port connections
	var MyTestSystemInterface MycompA;
	var MyTestSystemInterface MycompB;	
MycompA := MyTestSystemInterface.create;
MycompB := MyTestSystemInterface.create;

map(MycompA:messagePort, system:messagePort);
map(MycompB:messagePort, system:messagePort);
	
}
control{
    execute(TC_Syn_0902_Communication_ports_001());
}
}/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:9, Ensure that the IUT port correctly mapped with a system interface
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// Mycompport A is mapped with a system interface
module Sem_0902_Communication_ports_001{ 

    type port loopbackPort message {
	  inout integer
		}
type port IntegerOutputPortType message {
	  inout integer
	}
	
type component GeneralComp
	{
	
		port IntegerOutputPortType MycomportA
	}

type component MyTestSystemInterface
	{
 	port loopbackPort messagePort
	}
// MyTestSystemInterface is the test system interface
testcase TC_Sem_0902_Communication_ports_001() runs on GeneralComp system MyTestSystemInterface {
// establishing the port connections
map(mtc:MycomportA, system:messagePort);


 MycomportA.send(2);  //can send also in-line template

    alt {
     [] MycomportA.receive(2) {
        setverdict(pass);
     }
     [] MycomportA.receive {
        setverdict(fail);
     }
    }
}
control{
    execute(TC_Sem_0902_Communication_ports_001());
}
}/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @desc     Test cases for clause 5.3 ordering rules                     
 ** @purpose  1:5.3, Ensure that allowed any ordering with component definitions are supported
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0503_Ordering_002 {


    type port loopbackPort message {
	  inout integer
	}

type component GeneralComp	//declarations inside a component can be in any order
{
 timer t_rec,t_rec2;
 var integer v_comp1:=0;
 port loopbackPort messagePortA;
 var integer v_comp2:=0;
}

testcase TC_Sem_0503_Ordering_002() runs on GeneralComp  {
    
     v_comp1 := 1;
     v_comp2 := v_comp1;
      if (v_comp2 == 1) {
	    setverdict(pass);
      }

}

control {
    execute(TC_Sem_0503_Ordering_002());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @desc     Test cases for clause 5.2 Scope rules                     
 ** @purpose  1:5.3, Ensure that allowed orderings of declarations are supported
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0503_Ordering_001 {

type component GeneralComp {	    	    
    var integer vc_component := 0;
}	

testcase TC_Sem_0503_Ordering_001() runs on GeneralComp  {
    var integer v_testcase := 0;
    
    f_function();
    if(true) {
     var integer v_statement := 0;
      if (v_statement == 0) {
            var integer v_nested_statement := 0;
	    setverdict(pass);
      }

    }
}

function f_function() runs on GeneralComp {	    
    var integer v_function := 0;
}		

control {
    var integer v_control := 0;
    execute(TC_Sem_0503_Ordering_001());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @desc     Test cases for clause 5.2 Scope rules                     
 ** @purpose  1:5.3, Ensure that allowed orderings of declarations are supported
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0503_Ordering_005 {

type component GeneralComp {	    	    
    var integer vc_component := 0;
}	

testcase TC_Sem_0503_Ordering_005() runs on GeneralComp  {
    var integer v_testcase := 0;
    
    f_function();
    if(true) {
     var integer v_statement := 0;
      if (c_module == 0) {		// c_module is known as it is declared on the module level
            var integer v_nested_statement := 0;
	    setverdict(pass);
      }

    }
}

function f_function() runs on GeneralComp {	    
    var integer v_function := 0;
}		

    const integer c_module := 0; 	    

control {
    var integer v_control := 0;
    execute(TC_Sem_0503_Ordering_005());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:5.5, Ensure that the IUT correctly handles cyclic imports 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_0505_cyclic_definitions_002 { 
   type integer MyInteger; 
   import from Sem_0505_cyclic_definitions_002_import { type MyIntegerList } 


type component GeneralComp {	    	    
}	

testcase TC_Sem_0505_cyclic_definitions_002() runs on GeneralComp {
    var MyIntegerList v_list := {1,2};

    if ( match(v_list, { 1, 2})) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}

control{
    execute(TC_Sem_0505_cyclic_definitions_002());
}

}

module Sem_0505_cyclic_definitions_002_import { 
   import from Sem_0505_cyclic_definitions_002 { type MyInteger } 
   type record of MyInteger MyIntegerList; 
} 
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:5.5, Verify that cyclic altsteps are allowed
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// Direct and indirect cyclic definitions are not allowed with the exception of the 
// following cases:
// b) ... altstep definitions (i.e. recursive ... altstep calls);

module Sem_0505_cyclic_definitions_004 {
	type port P message { 
		inout integer; 
	}
	type component GeneralComp {	
		var integer vc_receiveCounter := 0;
		port P p1;
	}	
	
	altstep a_test() runs on GeneralComp {
		[] p1.receive(integer:(0..3)) {
			vc_receiveCounter := vc_receiveCounter + 1;
			a_test();
		}
		[] p1.receive(integer:?) {
			if (vc_receiveCounter == 4) {
				setverdict(pass);
			} else {
				setverdict(fail);
			}
		}
		[else] {
			setverdict(fail);
		}
	}	
	
	testcase TC_Sem_0505_cyclic_definitions_004() runs on GeneralComp system GeneralComp {
		map(self:p1, system:p1);
		for (var integer i := 0; i < 5; i := i + 1) {
			p1.send(i);
		}
	    a_test();		
	}
	
	control{
	    execute(TC_Sem_0505_cyclic_definitions_004());
	}
}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:5.5, Ensure that the IUT correctly handles recursive functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0505_cyclic_definitions_001 {

type component GeneralComp {	    	    
}	

function f_recursive(integer p_argument) return integer {	    
    if(p_argument==0) {
     return 1;
    }
    else {
     return p_argument*f_recursive(p_argument-1);
    }
}		

testcase TC_Sem_0505_cyclic_definitions_001() runs on GeneralComp {
    if (f_recursive(10) == 3628800) {		// checks 10!
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}

control{
    execute(TC_Sem_0505_cyclic_definitions_001());
}

}
/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:5.5, Verify that cyclic import containing cyclic function calls is allowed
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// Direct and indirect cyclic definitions are not allowed with the exception of the 
// following cases:
// a) for recursive type definitions (see clause 6.2);
// b) function and altstep definitions (i.e. recursive function or altstep calls);
// c) cyclic import definitions, if the imported definitions only form allowed cyclic 
// definitions.
// In particular, the combination of c and b is tested

module Sem_0505_cyclic_definitions_003 {
	import from Sem_0505_cyclic_definitions_003_import { function f_factImp; }
	type component GeneralComp {	    	    
	}	
	
	function f_fact(integer p_argument) return integer {	    
	    if(p_argument==0) {
	     return 1;
	    }
	    else {
	     return p_argument*f_factImp(p_argument-1);
	    }
	}		
	
	testcase TC_Sem_0505_cyclic_definitions_003() runs on GeneralComp {
	    if (f_fact(10) == 3628800) {		// checks 10!
	        setverdict(pass);
	    }
	    else {
	        setverdict(fail);
	    }		
	}
	
	control{
	    execute(TC_Sem_0505_cyclic_definitions_003());
	}

}

module Sem_0505_cyclic_definitions_003_import {
	import from Sem_0505_cyclic_definitions_003 { function f_fact; }
	function f_factImp(integer p_argument) return integer {	    
	    if(p_argument==0) {
	     return 1;
	    }
	    else {
	     return p_argument*f_fact(p_argument-1);
	    }
	}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:5.1, Ensure that the IUT handle the identifiers case sensitively.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Syn_0501_Identifier_001 {

type component IdComp {	    	    
    const integer cl_int := 0;
}	

testcase TC_Syn_0501_Identifier_001() runs on IdComp {
    const integer cl_iNT := 1;
    if ( match(cl_int, 0) ){		
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}			

control{
    execute(TC_Syn_0501_Identifier_001(), 1.0);
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:5.4.1.4, Ensure that the IUT accepts port parametrization types for functions.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_05040104_parameters_of_kind_port_001 {

    type enumerated MyEnumeratedType {e_black, e_white}
    type integer address;

    type record MyRecord {
        integer field1,
        boolean field2,
        address field3,
        MyEnumeratedType field4,
        integer field5
    }

    type port TestPort message {
        inout MyRecord
    }

    type component GeneralComp {
        port TestPort generalPort;
        port TestPort otherPort;
    }

    function f_parametrizationCheck (
        MyRecord ExpectedMatch,
        timer p_timer,
        integer p_integer := 0,
        boolean p_boolean := true,
        address p_address := null,
        MyEnumeratedType p_enumerated := e_black,
        template integer p_integerTemplate := ?,
        TestPort p_port
    ) runs on GeneralComp {
        var template MyRecord ReceivedRecordTemplate := {p_integer, p_boolean, p_address, p_enumerated, p_integerTemplate};
 
        p_port.send(ExpectedMatch);
    }

    testcase TC_Sem_05040104_parameters_of_kind_port_001_a (
        MyRecord ExpectedMatch,
        integer p_integer := 0,
        boolean p_boolean := true,
        address p_address := null,
        MyEnumeratedType p_enumerated := e_black,
        template integer p_integerTemplate := ?
    ) runs on GeneralComp {

        timer t_check;
        t_check.start(5.0);
        f_parametrizationCheck(ExpectedMatch, t_check, p_integer, p_boolean, p_address, p_enumerated, p_integerTemplate,generalPort);
        alt {
            [] generalPort.receive {
                setverdict(pass);
            }
            [] t_check.timeout {
                setverdict(fail);
            }
        }

        t_check.stop;
 
    }

    testcase TC_Sem_05040104_parameters_of_kind_port_001_b (
        MyRecord ExpectedMatch,
        integer p_integer := 0,
        boolean p_boolean := true,
        address p_address := null,
        MyEnumeratedType p_enumerated := e_black,
        template integer p_integerTemplate := ?
    ) runs on GeneralComp {

        timer t_check;
        t_check.start(1.0);
        f_parametrizationCheck(ExpectedMatch, t_check, p_integer, p_boolean, p_address, p_enumerated, p_integerTemplate,otherPort);
        alt {
            [] otherPort.receive {
                setverdict(pass);
            }
            [] t_check.timeout {
                setverdict(fail);
            }
        }

        t_check.stop;
 
    }


    control{

        var MyRecord ModifiedValues  := {
            field1 := 1,
            field2 := false,
            field3 := 1,
            field4 := e_white,
            field5 := 1
        }

        //the following testcases will call same function with different port parameter values
        execute(TC_Sem_05040104_parameters_of_kind_port_001_a(ModifiedValues,1,false,1,e_white,1));
        execute(TC_Sem_05040104_parameters_of_kind_port_001_b(ModifiedValues,1,false,1,e_white,1));
    
    }

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:5.4.1.3, Ensure that the IUT correctly handles parametrization through the use of timer parameters.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_05040103_parameters_of_kind_timer_001 {

type enumerated MyEnumeratedType {e_black, e_white}
type integer address;

type record MyRecord {
 integer field1,
 boolean field2,
 address field3,
 MyEnumeratedType field4,
 integer field5
}

type port TestPort message {
 inout MyRecord
}

type component GeneralComp {	    	    
  port TestPort generalPort;
  port TestPort otherport;
}	
function f_parametrizationCheck (
  MyRecord ExpectedMatch,
  timer p_timer, 
  integer p_integer := 0,
  boolean p_boolean := true,
  address p_address := null,
  MyEnumeratedType p_enumerated := e_black,
  template integer p_integerTemplate := ?
 ) runs on GeneralComp {
  var template MyRecord ReceivedRecordTemplate := {p_integer, p_boolean, p_address, p_enumerated, p_integerTemplate};

    if ( match(ExpectedMatch, ReceivedRecordTemplate) and (p_timer.running) ) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
  }

testcase TC_Sem_05040103_parameters_of_kind_timer_001 (
  MyRecord ExpectedMatch,
  integer p_integer := 0,
  boolean p_boolean := true,
  address p_address := null,
  MyEnumeratedType p_enumerated := e_black,
  template integer p_integerTemplate := ?
 ) runs on GeneralComp {

 timer t_check;
 t_check.start(5.0);
 f_parametrizationCheck(ExpectedMatch, t_check, p_integer, p_boolean, p_address, p_enumerated, p_integerTemplate);

 t_check.stop;
 
}


control{

 var MyRecord DefaultValues  := {
  field1 := 0,
  field2 := true,
  field3 := null,
  field4 := e_black,
  field5 := 1			//any number can be used here to correspond with ? matching
 }

 var MyRecord ModifiedValues  := {
  field1 := 1,
  field2 := false,
  field3 := 1,
  field4 := e_white,
  field5 := 1
 }

 var MyRecord PartlyModifiedValues  := {
  field1 := 0,
  field2 := false,
  field3 := null,
  field4 := e_white,
  field5 := 1
 }

    execute(TC_Sem_05040103_parameters_of_kind_timer_001(DefaultValues));
    execute(TC_Sem_05040103_parameters_of_kind_timer_001(DefaultValues,-,-,-,-,-));
    execute(TC_Sem_05040103_parameters_of_kind_timer_001(ModifiedValues,1,false,1,e_white,1));
    execute(TC_Sem_05040103_parameters_of_kind_timer_001(PartlyModifiedValues,-,false,-,e_white,-));
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that template formal parameters can be used in the same way as templates or template variables
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be used within the parameterized object the same way as 
// templates and template variables.

module Sem_05040102_parameters_of_kind_template_008 { 

	type component GeneralComp {
	}
    
    function f(template integer p_int1, in template integer p_int2) {
        p_int1 := ?; // modification
        if (match(1, p_int2)) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_008() runs on GeneralComp {
        f(*, (0..5));
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_008());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that template definition can contain in template formal parameters with omit restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_015 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2 optional
    }
	
    template R mw_t(template(omit) integer p_int1, in template(omit) integer p_int2) := {
        field1 := p_int1,
        field2 := p_int2
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_015() runs on GeneralComp {
        log(mw_t(3, omit));
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_015());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that altstep definition can contain in, out and inout template formal parameters with omit restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_018 { 

	type component GeneralComp {
	}
    
    altstep a(template(omit) integer p_int1, in template(omit) integer p_int2, 
        out template(omit) integer p_int3, inout template(omit) integer p_int4) {
        [] any timer.timeout { setverdict(fail); }
        [else] { setverdict(pass); }
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_018() runs on GeneralComp {
        var template(omit) integer v_int1, v_int2 := omit;
        a(0, 2, v_int1, v_int2);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_018());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that function definition can contain in, out and inout template formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Templates parameters can be defined for templates, functions, altsteps, and test cases.
// To enable a parameterized object to accept templates or matching symbols as actual parameters, 
// the extra keyword template shall be added before the type field of the corresponding formal 
// parameter. This makes the parameter a template parameter and in effect extends the allowed actual 
// parameters for the associated type to include the appropriate set of matching attributes (see 
// annex B) as well as the normal set of values.
// Formal template parameters may be in, inout or out parameters. The default for formal template 
// parameters is in parameterization.

module Sem_05040102_parameters_of_kind_template_005 { 

	type component GeneralComp {
	}
    
    function f(template integer p_int1, in template integer p_int2, out template integer p_int3, inout template integer p_int4){
        setverdict(pass);
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_005() runs on GeneralComp {
        var template integer v_int1, v_int2 := ?;
        f((1..3), 2, v_int1, v_int2);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_005());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that mtc is suitable default value of formal template parameters of component type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Restriction e)
// Default templates of component type formal parameters shall be built from the special values 
// null, mtc, self, or system.

module Sem_05040102_parameters_of_kind_template_037 { 

	type component GeneralComp {
	}	
    
    function f(template GeneralComp p_comp := mtc) {
        log(p_comp);
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_037() runs on GeneralComp {
        f();
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_037());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that test case definition can contain in, out and inout template formal parameters with omit restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_019 { 

	type component GeneralComp {
	}
    
	testcase TC_Sem_05040102_parameters_of_kind_template_019(
        template(omit) integer p_int1, in template(omit) integer p_int2, 
        out template(omit) integer p_int3, inout template(omit) integer p_int4) runs on GeneralComp {
        setverdict(pass);
	}

	control {
        var template(omit) integer v_int1, v_int2 := 20;
		execute(TC_Sem_05040102_parameters_of_kind_template_019(omit, 2, v_int1, v_int2));
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that template definition can contain in template formal parameters with value restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_025 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2 optional
    }
	
    template R mw_t(template(value) integer p_int1, in template(value) integer p_int2) := {
        field1 := p_int1,
        field2 := p_int2
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_025() runs on GeneralComp {
        log(mw_t(3, 4));
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_025());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that function definition can contain in, out and inout template formal parameters with short omit restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value. The restriction template (omit) can be replaced by the shorthand notation omit.

module Sem_05040102_parameters_of_kind_template_032 { 

	type component GeneralComp {
	}
    
    function f(omit integer p_int1, in omit integer p_int2, 
        out omit integer p_int3, inout omit integer p_int4){
        setverdict(pass);
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_032() runs on GeneralComp {
        var omit integer v_int1, v_int2 := 20;
        f(omit, 2, v_int1, v_int2);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_032());
	}
}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, Ensure that the IUT correctly handles parametrization through the use of parameterized templates.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_05040102_parameters_of_kind_template_002 {

type enumerated MyEnumeratedType {e_black, e_white}
type integer address;

type record MyRecord {
 integer field1,
 boolean field2,
 address field3,
 MyEnumeratedType field4,
 integer field5
}


type component GeneralComp {	    	    

}	


testcase TC_Sem_05040102_parameters_of_kind_template_002 (
  MyRecord ExpectedMatch,
  integer p_integer := 0,
  boolean p_boolean := true,
  address p_address := null,
  MyEnumeratedType p_enumerated := e_black,
  template integer p_integerTemplate := ?
 ) runs on GeneralComp {

 var template MyRecord ReceivedRecord := {p_integer, p_boolean, p_address, p_enumerated, p_integerTemplate};

    if (match(ExpectedMatch, ReceivedRecord)) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
 
}


control{

 var MyRecord DefaultValues  := {
  field1 := 0,
  field2 := true,
  field3 := null,
  field4 := e_black,
  field5 := 1			//any number can be used here to correspond with ? matching
 }

 var MyRecord ModifiedValues  := {
  field1 := 1,
  field2 := false,
  field3 := 1,
  field4 := e_white,
  field5 := 1
 }

 var MyRecord PartlyModifiedValues  := {
  field1 := 0,
  field2 := false,
  field3 := null,
  field4 := e_white,
  field5 := 1
 }

    execute(TC_Sem_05040102_parameters_of_kind_template_002(DefaultValues));
    execute(TC_Sem_05040102_parameters_of_kind_template_002(DefaultValues,-,-,-,-,-));
    execute(TC_Sem_05040102_parameters_of_kind_template_002(ModifiedValues,1,false,1,e_white,1));
    execute(TC_Sem_05040102_parameters_of_kind_template_002(PartlyModifiedValues,-,false,-,e_white,-));
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that local template definition can contain in template formal parameters with value restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_026 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2 optional
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_026() runs on GeneralComp {
        template R m_t(template(value) integer p_int1, in template(value) integer p_int2) := {
            field1 := p_int1,
            field2 := p_int2
        }
        log(m_t(3, 4));
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_026());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that function definition can contain in, out and inout template formal parameters with present restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_022 { 

	type component GeneralComp {
	}
    
    function f(template(present) integer p_int1, in template(present) integer p_int2, 
        out template(present) integer p_int3, inout template(present) integer p_int4){
        setverdict(pass);
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_022() runs on GeneralComp {
        var template(present) integer v_int1, v_int2 := 20;
        f((0..5), 2, v_int1, v_int2);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_022());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that local template definition can contain in template formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Templates parameters can be defined for templates, functions, altsteps, and test cases.
// To enable a parameterized object to accept templates or matching symbols as actual parameters, 
// the extra keyword template shall be added before the type field of the corresponding formal 
// parameter. This makes the parameter a template parameter and in effect extends the allowed actual 
// parameters for the associated type to include the appropriate set of matching attributes (see 
// annex B) as well as the normal set of values.
// Formal template parameters may be in, inout or out parameters. The default for formal template 
// parameters is in parameterization.

module Sem_05040102_parameters_of_kind_template_004 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_004() runs on GeneralComp {
        template R m_t(template integer p_int1, in template integer p_int2) := {
            field1 := p_int1,
            field2 := p_int2
        }
        log(m_t(3, ?));
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_004());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that test case definition can contain in, out and inout template formal parameters with value restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_029 { 

	type component GeneralComp {
	}
    
	testcase TC_Sem_05040102_parameters_of_kind_template_029(
        template(value) integer p_int1, in template(value) integer p_int2, 
        out template(value) integer p_int3, inout template(value) integer p_int4) runs on GeneralComp {
        setverdict(pass);
	}

	control {
        var template(value) integer v_int1, v_int2 := 20;
		execute(TC_Sem_05040102_parameters_of_kind_template_029(0, 2, v_int1, v_int2));
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that altstep definition can contain in, out and inout template formal parameters with present restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_023 { 

	type component GeneralComp {
	}
    
    altstep a(template(present) integer p_int1, in template(present) integer p_int2, 
        out template(present) integer p_int3, inout template(present) integer p_int4) {
        [] any timer.timeout { setverdict(fail); }
        [else] { setverdict(pass); }
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_023() runs on GeneralComp {
        var template(present) integer v_int1, v_int2 := (0..5);
        a(0, 2, v_int1, v_int2);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_023());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that function definition can contain in, out and inout template formal parameters with value restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_027 { 

	type component GeneralComp {
	}
    
    function f(template(value) integer p_int1, in template(value) integer p_int2, 
        out template(value) integer p_int3, inout template(value) integer p_int4){
        setverdict(pass);
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_027() runs on GeneralComp {
        var template(value) integer v_int1, v_int2 := 20;
        f(0, 2, v_int1, v_int2);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_027());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that system is suitable default value of formal template parameters of component type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Restriction e)
// Default templates of component type formal parameters shall be built from the special values 
// null, mtc, self, or system.

module Sem_05040102_parameters_of_kind_template_038 { 

	type component GeneralComp {
	}	
    
    function f(template GeneralComp p_comp := system) {
        log(p_comp);
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_038() runs on GeneralComp {
        f();
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_038());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that function definition can contain in, out and inout template formal parameters with omit restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_017 { 

	type component GeneralComp {
	}
    
    function f(template(omit) integer p_int1, in template(omit) integer p_int2, 
        out template(omit) integer p_int3, inout template(omit) integer p_int4){
        setverdict(pass);
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_017() runs on GeneralComp {
        var template(omit) integer v_int1, v_int2 := 20;
        f(omit, 2, v_int1, v_int2);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_017());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that null is suitable default value of formal template parameters of component type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Restriction e)
// Default templates of component type formal parameters shall be built from the special values 
// null, mtc, self, or system.

module Sem_05040102_parameters_of_kind_template_035 { 

	type component GeneralComp {
	}	
    
    function f(template GeneralComp p_comp := null) {
        log(p_comp);
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_035() runs on GeneralComp {
        f();
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_035());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that test case definition can contain in, out and inout template formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Templates parameters can be defined for templates, functions, altsteps, and test cases.
// To enable a parameterized object to accept templates or matching symbols as actual parameters, 
// the extra keyword template shall be added before the type field of the corresponding formal 
// parameter. This makes the parameter a template parameter and in effect extends the allowed actual 
// parameters for the associated type to include the appropriate set of matching attributes (see 
// annex B) as well as the normal set of values.
// Formal template parameters may be in, inout or out parameters. The default for formal template 
// parameters is in parameterization.

module Sem_05040102_parameters_of_kind_template_007 { 

	type component GeneralComp {
	}
    
	testcase TC_Sem_05040102_parameters_of_kind_template_007(
        template integer p_int1, in template integer p_int2, out template integer p_int3, inout template integer p_int4) runs on GeneralComp {
        setverdict(pass);
	}

	control {
        var template integer v_int1, v_int2 := ?;
		execute(TC_Sem_05040102_parameters_of_kind_template_007((1..3), 2, v_int1, v_int2));
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that local template definition can contain in template formal parameters with omit restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_016 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2 optional
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_016() runs on GeneralComp {
        template R m_t(template(omit) integer p_int1, in template(omit) integer p_int2) := {
            field1 := p_int1,
            field2 := p_int2
        }
        log(m_t(3, omit));
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_016());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that in template formal parameters of test case can have default values
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// In parameters may have a default template, which is given by a template instance 
// assigned to the parameter.

module Sem_05040102_parameters_of_kind_template_013 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
    testcase TC(template integer p_int1 := ?, in template integer p_int2 := (0..5)) runs on GeneralComp {
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that local template definition can contain in template formal parameters with present restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_021 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2 optional
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_021() runs on GeneralComp {
        template R m_t(template(present) integer p_int1, in template(present) integer p_int2) := {
            field1 := p_int1,
            field2 := p_int2
        }
        log(m_t(3, (0..5)));
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_021());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that altstep definition can contain in, out and inout template formal parameters with short omit restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value. The restriction template (omit) can be replaced by the shorthand notation omit.

module Sem_05040102_parameters_of_kind_template_033 { 

	type component GeneralComp {
	}
    
    altstep a(omit integer p_int1, in omit integer p_int2, 
        out omit integer p_int3, inout omit integer p_int4) {
        [] any timer.timeout { setverdict(fail); }
        [else] { setverdict(pass); }
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_033() runs on GeneralComp {
        var omit integer v_int1, v_int2 := omit;
        a(0, 2, v_int1, v_int2);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_033());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that altstep definition can contain in, out and inout template formal parameters with value restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_028 { 

	type component GeneralComp {
	}
    
    altstep a(template(value) integer p_int1, in template(value) integer p_int2, 
        out template(value) integer p_int3, inout template(value) integer p_int4) {
        [] any timer.timeout { setverdict(fail); }
        [else] { setverdict(pass); }
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_028() runs on GeneralComp {
        var template(value) integer v_int1, v_int2 := 20;
        a(0, 2, v_int1, v_int2);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_028());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that self is suitable default value of formal template parameters of component type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Restriction e)
// Default templates of component type formal parameters shall be built from the special values 
// null, mtc, self, or system.

module Sem_05040102_parameters_of_kind_template_036 { 

	type component GeneralComp {
	}	
    
    function f(template GeneralComp p_comp := self) {
        log(p_comp);
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_036() runs on GeneralComp {
        f();
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_036());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that test case definition can contain in, out and inout template formal parameters with present restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_024 { 

	type component GeneralComp {
	}
    
	testcase TC_Sem_05040102_parameters_of_kind_template_024(
        template(present) integer p_int1, in template(present) integer p_int2, 
        out template(present) integer p_int3, inout template(present) integer p_int4) runs on GeneralComp {
        setverdict(pass);
	}

	control {
        var template(present) integer v_int1, v_int2 := 20;
		execute(TC_Sem_05040102_parameters_of_kind_template_024((0..5), 2, v_int1, v_int2));
	}
}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, Ensure that the IUT correctly handles parametrization through the use of parameterized templates.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_05040102_parameters_of_kind_template_001 {

type enumerated MyEnumeratedType {e_black, e_white}
type integer address;

type record MyRecord {
 integer field1,
 boolean field2,
 address field3,
 MyEnumeratedType field4,
 integer field5
}

template MyRecord m_parametrizedTemplate 
 (
  integer p_integer := 0,
  boolean p_boolean := true,
  address p_address := null,
  MyEnumeratedType p_enumerated := e_black,
  template integer p_integerTemplate := ?
 ) := {
  field1 := p_integer,
  field2 := p_boolean,
  field3 := p_address,
  field4 := p_enumerated,
  field5 := p_integerTemplate
}



type component GeneralComp {	    	    

}	


testcase TC_Sem_05040102_parameters_of_kind_template_001() runs on GeneralComp {

 var MyRecord DefaultValues  := {
  field1 := 0,
  field2 := true,
  field3 := null,
  field4 := e_black,
  field5 := 1			//any number can be used here to correspond with ? matching
 }

 var MyRecord ModifiedValues  := {
  field1 := 1,
  field2 := false,
  field3 := 1,
  field4 := e_white,
  field5 := 1
 }

 var MyRecord PartlyModifiedValues  := {
  field1 := 0,
  field2 := false,
  field3 := null,
  field4 := e_white,
  field5 := 1
 }

    if ( 
     match(DefaultValues, m_parametrizedTemplate) and 
     match(ModifiedValues, m_parametrizedTemplate(1,false,1,e_white,1)) and
     match(PartlyModifiedValues, m_parametrizedTemplate(-,false,-,e_white,-))     
    ) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
 
}


control{
    execute(TC_Sem_05040102_parameters_of_kind_template_001());
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that in template formal parameters of template can have default values
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// In parameters may have a default template, which is given by a template instance 
// assigned to the parameter. 

module Sem_05040102_parameters_of_kind_template_009 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
    template R mw_t(template integer p_int1 := ?, in template integer p_int2 := (0..5)) := {
        field1 := p_int1,
        field2 := p_int2
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that template definition can contain in template formal parameters with short omit restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value. The restriction template (omit) can be replaced by the shorthand notation omit.

module Sem_05040102_parameters_of_kind_template_030 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2 optional
    }
	
    template R mw_t(omit integer p_int1, in omit integer p_int2) := {
        field1 := p_int1,
        field2 := p_int2
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_030() runs on GeneralComp {
        log(mw_t(3, omit));
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_030());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that local template definition can contain in template formal parameters with short omit restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value. The restriction template (omit) can be replaced by the shorthand notation omit.

module Sem_05040102_parameters_of_kind_template_031 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2 optional
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_031() runs on GeneralComp {
        template R m_t(omit integer p_int1, in omit integer p_int2) := {
            field1 := p_int1,
            field2 := p_int2
        }
        log(m_t(3, omit));
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_031());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that altstep definition can contain in, out and inout template formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Templates parameters can be defined for templates, functions, altsteps, and test cases.
// To enable a parameterized object to accept templates or matching symbols as actual parameters, 
// the extra keyword template shall be added before the type field of the corresponding formal 
// parameter. This makes the parameter a template parameter and in effect extends the allowed actual 
// parameters for the associated type to include the appropriate set of matching attributes (see 
// annex B) as well as the normal set of values.
// Formal template parameters may be in, inout or out parameters. The default for formal template 
// parameters is in parameterization.

module Sem_05040102_parameters_of_kind_template_006 { 

	type component GeneralComp {
	}
    
    altstep a(template integer p_int1, in template integer p_int2, out template integer p_int3, inout template integer p_int4) {
        [] any timer.timeout { setverdict(fail); }
        [else] { setverdict(pass); }
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_006() runs on GeneralComp {
        var template integer v_int1, v_int2 := ?;
        a((1..3), 2, v_int1, v_int2);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_006());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that in template formal parameters of local template can have default values
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// In parameters may have a default template, which is given by a template instance 
// assigned to the parameter. 

module Sem_05040102_parameters_of_kind_template_010 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
    function f() {
        template R m_t(template integer p_int1 := ?, in template integer p_int2 := (0..5)) := {
            field1 := p_int1,
            field2 := p_int2
        }
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that template definition can contain in template formal parameters with present restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value.

module Sem_05040102_parameters_of_kind_template_020 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2 optional
    }
	
    template R mw_t(template(present) integer p_int1, in template(present) integer p_int2) := {
        field1 := p_int1,
        field2 := p_int2
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_020() runs on GeneralComp {
        log(mw_t(3, (0..5)));
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_020());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that template definition can contain in template formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Templates parameters can be defined for templates, functions, altsteps, and test cases.
// To enable a parameterized object to accept templates or matching symbols as actual parameters, 
// the extra keyword template shall be added before the type field of the corresponding formal 
// parameter. This makes the parameter a template parameter and in effect extends the allowed actual 
// parameters for the associated type to include the appropriate set of matching attributes (see 
// annex B) as well as the normal set of values.
// Formal template parameters may be in, inout or out parameters. The default for formal template 
// parameters is in parameterization.

module Sem_05040102_parameters_of_kind_template_003 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
    template R mw_t(template integer p_int1, in template integer p_int2) := {
        field1 := p_int1,
        field2 := p_int2
    }
	
	testcase TC_Sem_05040102_parameters_of_kind_template_003() runs on GeneralComp {
        log(mw_t(3, ?));
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040102_parameters_of_kind_template_003());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that in template formal parameters of function can have default values
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// In parameters may have a default template, which is given by a template instance 
// assigned to the parameter. 

module Sem_05040102_parameters_of_kind_template_011 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
    function f(template integer p_int1 := ?, in template integer p_int2 := (0..5)) {
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that test case definition can contain in, out and inout template formal parameters with short omit restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal template parameters can be restricted to accept actual parameters containing a restricted 
// set of matching mechanisms only. Such limitations can be expressed by the restrictions omit, 
// present, and value. The restriction template (omit) can be replaced by the shorthand notation omit.

module Sem_05040102_parameters_of_kind_template_034 { 

	type component GeneralComp {
	}
    
	testcase TC_Sem_05040102_parameters_of_kind_template_034(
        omit integer p_int1, in omit integer p_int2, 
        out omit integer p_int3, inout omit integer p_int4) runs on GeneralComp {
        setverdict(pass);
	}

	control {
        var omit integer v_int1, v_int2 := 20;
		execute(TC_Sem_05040102_parameters_of_kind_template_034(omit, 2, v_int1, v_int2));
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that in template formal parameters of modified template can used dash as default value
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// Formal template parameters of modified templates may inherit their default templates from the 
// corresponding parameters of their parent templates; this shall explicitly be denoted by using 
// a dash (don't change) symbol at the place of the modified template parameter's default template.

module Sem_05040102_parameters_of_kind_template_014 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
    template R mw_t(template integer p_int1 := ?, in template integer p_int2 := (0..5)) := {
        field1 := p_int1,
        field2 := p_int2
    }
    
    template R mw_tmod(template integer p_int1 := 10, in template integer p_int2 := -) modifies mw_t := {
        field1 := p_int1,
        field2 := p_int2
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.2, verify that in template formal parameters of altstep can have default values
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// In parameters may have a default template, which is given by a template instance 
// assigned to the parameter. 

module Sem_05040102_parameters_of_kind_template_012 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
    altstep a(template integer p_int1 := ?, in template integer p_int2 := (0..5)) {
        [] any timer.timeout {}
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that in value formal parameters of test case can have default values
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// In parameters may have a default value, which is given by an expression assigned to 
// the parameter.

module Sem_05040101_parameters_of_kind_value_015 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
    testcase TC(integer p_int1 := 3, in integer p_int2 := 4) runs on GeneralComp {
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that self is suitable default value of formal value parameters of component type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Restriction f)
// Default values of component type formal parameters shall be one of the special values null, 
// mtc, self, or system.

module Sem_05040101_parameters_of_kind_value_018 { 

	type component GeneralComp {
	}	
    
    function f(GeneralComp p_comp := self) {
        log(p_comp);
    }
	
	testcase TC_Sem_05040101_parameters_of_kind_value_018() runs on GeneralComp {
        f();
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040101_parameters_of_kind_value_018());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that test case definition can contain in, out and inout value formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// TTCN 3 supports value parameterization according to the following rules:
// - the language elements template, testcase, altstep and function support dynamic value 
// parameterization (i.e. this parameterization shall be resolved at runtime). Value formal 
// parameters may be in, inout or out parameters. The default for value formal parameters is 
// in parameterization which may optionally be denoted by the keyword in. Using of inout or out 
// kind of parameterization shall be specified by the keywords inout or out respectively.

module Sem_05040101_parameters_of_kind_value_009 { 

	type component GeneralComp {
	}
    
	testcase TC_Sem_05040101_parameters_of_kind_value_009(integer p_int1, in integer p_int2, out integer p_int3, inout integer p_int4) runs on GeneralComp {
        setverdict(pass);
	}

	control {
        var integer v_int1, v_int2 := 0;
		execute(TC_Sem_05040101_parameters_of_kind_value_009(1, 2, v_int1, v_int2));
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that in value formal parameters of function can have default values
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// In parameters may have a default value, which is given by an expression assigned to 
// the parameter.

module Sem_05040101_parameters_of_kind_value_013 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
    function f(integer p_int1 := 3, in integer p_int2 := 4) {
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that null is suitable default value of formal value parameters of component type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Restriction f)
// Default values of component type formal parameters shall be one of the special values null, 
// mtc, self, or system.

module Sem_05040101_parameters_of_kind_value_017 { 

	type component GeneralComp {
	}	
    
    function f(GeneralComp p_comp := null) {
        log(p_comp);
    }
	
	testcase TC_Sem_05040101_parameters_of_kind_value_017() runs on GeneralComp {
        f();
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040101_parameters_of_kind_value_017());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that system is suitable default value of formal value parameters of component type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Restriction f)
// Default values of component type formal parameters shall be one of the special values null, 
// mtc, self, or system.

module Sem_05040101_parameters_of_kind_value_020 { 

	type component GeneralComp {
	}	
    
    function f(GeneralComp p_comp := system) {
        log(p_comp);
    }
	
	testcase TC_Sem_05040101_parameters_of_kind_value_020() runs on GeneralComp {
        f();
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040101_parameters_of_kind_value_020());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that value formal parameters can be used in expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Value formal parameters can be used within the parameterized object the same way as values, 
// for example in expressions.

module Sem_05040101_parameters_of_kind_value_010 { 

	type component GeneralComp {
	}
    
    function f(integer p_int1, in integer p_int2){
        if (p_int1 + p_int2 == 5) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }
	
	testcase TC_Sem_05040101_parameters_of_kind_value_010() runs on GeneralComp {
        f(2, 3);
	}

	control{
		execute(TC_Sem_05040101_parameters_of_kind_value_010());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that altstep definition can contain in, out and inout value formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// TTCN 3 supports value parameterization according to the following rules:
// - the language elements template, testcase, altstep and function support dynamic value 
// parameterization (i.e. this parameterization shall be resolved at runtime). Value formal 
// parameters may be in, inout or out parameters. The default for value formal parameters is 
// in parameterization which may optionally be denoted by the keyword in. Using of inout or out 
// kind of parameterization shall be specified by the keywords inout or out respectively.

module Sem_05040101_parameters_of_kind_value_008 { 

	type component GeneralComp {
	}
    
    altstep a(integer p_int1, in integer p_int2, out integer p_int3, inout integer p_int4) {
        [] any timer.timeout { setverdict(fail); }
        [else] { setverdict(pass); }
    }
	
	testcase TC_Sem_05040101_parameters_of_kind_value_008() runs on GeneralComp {
        var integer v_int1, v_int2 := 0;
        a(1, 2, v_int1, v_int2);
	}

	control{
		execute(TC_Sem_05040101_parameters_of_kind_value_008());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that mtc is suitable default value of formal value parameters of component type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Restriction f)
// Default values of component type formal parameters shall be one of the special values null, 
// mtc, self, or system.

module Sem_05040101_parameters_of_kind_value_019 { 

	type component GeneralComp {
	}	
    
    function f(GeneralComp p_comp := mtc) {
        log(p_comp);
    }
	
	testcase TC_Sem_05040101_parameters_of_kind_value_019() runs on GeneralComp {
        f();
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040101_parameters_of_kind_value_019());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that local template definition can contain in value formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// TTCN 3 supports value parameterization according to the following rules:
// - the language elements template, testcase, altstep and function support dynamic value 
// parameterization (i.e. this parameterization shall be resolved at runtime). Value formal 
// parameters may be in, inout or out parameters. The default for value formal parameters is 
// in parameterization which may optionally be denoted by the keyword in. Using of inout or out 
// kind of parameterization shall be specified by the keywords inout or out respectively.

module Sem_05040101_parameters_of_kind_value_006 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
	testcase TC_Sem_05040101_parameters_of_kind_value_006() runs on GeneralComp {
        template R m_t(integer p_int1, in integer p_int2) := {
            field1 := p_int1,
            field2 := p_int2
        }
        log(m_t(3,4));
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040101_parameters_of_kind_value_006());
	}
}
/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, Ensure that the IUT correctly handles parametrization through the use of module parameters.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_05040101_parameters_of_kind_value_003 {

    // the following module parameters must not be set externally, as their default values are being checked
    modulepar address ADDRESS_MODULE_PARAMETER := 5;

    type integer address;

    type component GeneralComp {
    }


    testcase TC_Sem_05040101_parameters_of_kind_value_003() runs on GeneralComp {
        if ( ADDRESS_MODULE_PARAMETER == 5) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
 
    }


    control{
        execute(TC_Sem_05040101_parameters_of_kind_value_003());
    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that in value formal parameters of modified template can used dash as default value
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// Formal parameters of modified templates may inherit the default values from the corresponding 
// parameters of their parent templates; this shall explicitly be denoted by using a dash (don't 
// change) symbol at the place of the modified template parameters' default value.

module Sem_05040101_parameters_of_kind_value_016 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
    template R m_t(integer p_int1 := 3, in integer p_int2 := 4) := {
        field1 := p_int1,
        field2 := p_int2
    }
    
    template R m_tmod(integer p_int1 := 10, in integer p_int2 := -) modifies m_t := {
        field1 := p_int1,
        field2 := p_int2
    }
}
/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, Ensure that the IUT correctly handles parametrization through the use of module parameters.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_05040101_parameters_of_kind_value_004 {

    // the following module parameter must not be set externally, as their default values are being checked

    modulepar MyEnumeratedType ENUMERATED_MODULE_PARAMETER := e_black;

    type enumerated MyEnumeratedType {e_black, e_white}

    type component GeneralComp {
    }


    testcase TC_Sem_05040101_parameters_of_kind_value_004() runs on GeneralComp {
        if (ENUMERATED_MODULE_PARAMETER == e_black ) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
 
    }


    control{
        execute(TC_Sem_05040101_parameters_of_kind_value_004());
    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that passing by value and by reference works correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// No specific requirement, just (slightly modified) example 6

module Sem_05040101_parameters_of_kind_value_022 { 

	type component GeneralComp {
	}	
    
    function f_byValue (in integer p_int1, in integer p_int2) {
	  p_int2 := p_int2 + 1;
	  log(p_int1);
	  log(p_int2);
	}

	function f_byReference (inout integer p_int1, inout integer p_int2) {
	  p_int2 := p_int2 + 1;
	  log(p_int1);
	  log(p_int2);
	}
	
	testcase TC_Sem_05040101_parameters_of_kind_value_022() runs on GeneralComp {
        var integer v_int := 1; 
	    f_byValue(v_int, v_int); // prints 1 and 2
	    log(v_int); // prints 1
        if (v_int == 1) { setverdict(pass); }
        else { setverdict(fail); }
        f_byReference(v_int, v_int); // prints 2 and 2
	    log(v_int); // prints 2
        if (v_int == 2) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_Sem_05040101_parameters_of_kind_value_022());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that in value formal parameters of template can have default values
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// In parameters may have a default value, which is given by an expression assigned to 
// the parameter.

module Sem_05040101_parameters_of_kind_value_011 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
    template R m_t(integer p_int1 := 3, in integer p_int2 := 4) := {
        field1 := p_int1,
        field2 := p_int2
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that null can be used as default value of formal value parameters of default type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Restriction g)
// Default values of default type formal parameters shall be the special value null.

module Sem_05040101_parameters_of_kind_value_021 { 

	type component GeneralComp {
	}	
    
    function f(default p_def := null) {
        log(p_def);
    }
	
	testcase TC_Sem_05040101_parameters_of_kind_value_021() runs on GeneralComp {
        f();
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040101_parameters_of_kind_value_021());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that in value formal parameters of altstep can have default values
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// In parameters may have a default value, which is given by an expression assigned to 
// the parameter.

module Sem_05040101_parameters_of_kind_value_014 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
    altstep a(integer p_int1 := 3, in integer p_int2 := 4) {
        [] any timer.timeout {}
    }
}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.2
 ** @purpose  1:5.4.1.1, Ensure that the IUT correctly handles parametrization through the use of module parameters.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_05040101_parameters_of_kind_value_001 {

    // the following module parameters must not be set externally, as their default values are being checked
    modulepar integer INTEGER_MODULE_PARAMETER := 1;
   

    type component GeneralComp {
    }


    testcase TC_Sem_05040101_parameters_of_kind_value_001() runs on GeneralComp {
        if ( (INTEGER_MODULE_PARAMETER == 1)) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
 
    }


    control{
        execute(TC_Sem_05040101_parameters_of_kind_value_001());
    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that in value formal parameters of local template can have default values
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// In parameters may have a default value, which is given by an expression assigned to 
// the parameter.

module Sem_05040101_parameters_of_kind_value_012 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
    function f() {
        template R m_t(integer p_int1 := 3, in integer p_int2 := 4) := {
            field1 := p_int1,
            field2 := p_int2
        }
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that function definition can contain in, out and inout value formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// TTCN 3 supports value parameterization according to the following rules:
// - the language elements template, testcase, altstep and function support dynamic value 
// parameterization (i.e. this parameterization shall be resolved at runtime). Value formal 
// parameters may be in, inout or out parameters. The default for value formal parameters is 
// in parameterization which may optionally be denoted by the keyword in. Using of inout or out 
// kind of parameterization shall be specified by the keywords inout or out respectively.

module Sem_05040101_parameters_of_kind_value_007 { 

	type component GeneralComp {
	}
    
    function f(integer p_int1, in integer p_int2, out integer p_int3, inout integer p_int4){
        setverdict(pass);
    }
	
	testcase TC_Sem_05040101_parameters_of_kind_value_007() runs on GeneralComp {
        var integer v_int1, v_int2 := 0;
        f(1, 2, v_int1, v_int2);
	}

	control{
		execute(TC_Sem_05040101_parameters_of_kind_value_007());
	}
}
/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, Ensure that the IUT correctly handles parametrization through the use of module parameters.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_05040101_parameters_of_kind_value_002 {

    // the following module parameters must not be set externally, as their default values are being checked
    modulepar boolean BOOLEAN_MODULE_PARAMETER := true;


    type component GeneralComp {
    }


    testcase TC_Sem_05040101_parameters_of_kind_value_002() runs on GeneralComp {
        if ( BOOLEAN_MODULE_PARAMETER == true){
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
 
    }


    control{
        execute(TC_Sem_05040101_parameters_of_kind_value_002());
    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1.1, verify that template definition can contain in value formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// TTCN 3 supports value parameterization according to the following rules:
// - the language elements template, testcase, altstep and function support dynamic value 
// parameterization (i.e. this parameterization shall be resolved at runtime). Value formal 
// parameters may be in, inout or out parameters. The default for value formal parameters is 
// in parameterization which may optionally be denoted by the keyword in. Using of inout or out 
// kind of parameterization shall be specified by the keywords inout or out respectively.

module Sem_05040101_parameters_of_kind_value_005 { 

	type component GeneralComp {
	}	
    
    type record R
    {
        integer field1,
        integer field2
    }
	
    template R m_t(integer p_int1, in integer p_int2) := {
        field1 := p_int1,
        field2 := p_int2
    }
	
	testcase TC_Sem_05040101_parameters_of_kind_value_005() runs on GeneralComp {
        log(m_t(3,4));
        setverdict(pass);
	}

	control{
		execute(TC_Sem_05040101_parameters_of_kind_value_005());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that @lazy modifier can be used for template parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal value or template parameters may be declared lazy using the @lazy modifier. The behaviour 
// of lazy parameters is defined in clause 3.1, definition of lazy values or templates. 

module Sem_050401_top_level_020 { 

	type component GeneralComp {
	}
    
	function f(template @lazy integer pm_int) {
        if (match(1, pm_int)) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	testcase TC_Sem_050401_top_level_020() runs on GeneralComp {
		f(1);
	}

	control{
		execute(TC_Sem_050401_top_level_020());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that out parameters can be used as actual out parameters of parameterized objects
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal parameters can be used directly as actual parameters for other parametrized objects, 
// e.g. as actual parameters in function invocations or as actual parameters in template instances.

module Sem_050401_top_level_011 { 

	type component GeneralComp {
	}	
	
    function fx(out integer p_int) {
        p_int := 3;
    }
    
	function f(out integer p_int) {
        fx(p_int);
        setverdict(pass);
	}
	
	testcase TC_Sem_050401_top_level_011() runs on GeneralComp {
		var integer v_int;
        f(v_int);
	}

	control{
		execute(TC_Sem_050401_top_level_011());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that inout parameters can be used as actual out parameters of parameterized objects
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal parameters can be used directly as actual parameters for other parametrized objects, 
// e.g. as actual parameters in function invocations or as actual parameters in template instances.

module Sem_050401_top_level_014 { 

	type component GeneralComp {
	}	
	
    function fx(out integer p_int) {
        p_int := 3;
    }
    
	function f(inout integer p_int) {
        fx(p_int);
        setverdict(pass);
	}
	
	testcase TC_Sem_050401_top_level_014() runs on GeneralComp {
		var integer v_int := 0;
        f(v_int);
	}

	control{
		execute(TC_Sem_050401_top_level_014());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that @fuzzy parameters containing component variable references are properly evaluated
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal value or template parameters may be declared fuzzy using the @fuzzy modifier. The behaviour 
// of fuzzy parameters is defined in clause 3.1, definition of fuzzy values or templates. 

// Note: the test checks the situation described in NOTE 2:
// The actual values of component variables used in the delayed evaluation of a lazy or fuzzy parameter 
// may differ from their values at the time, when the parameterized function or alstep was called.

module Sem_050401_top_level_024 { 

	type component GeneralComp {
        var integer vc_int := 20;
	}
    
	function f(@fuzzy integer p_int) runs on GeneralComp {
        vc_int := 0;
        if (p_int == 1) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	testcase TC_Sem_050401_top_level_024() runs on GeneralComp {
		f(vc_int + 1);
	}

	control{
		execute(TC_Sem_050401_top_level_024());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that in parameters can be read within parametrized content
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For all these three sorts of parameter passing, the formal parameters can both be read and set 
// (i.e. get new values being assigned) within the parametrized object.

module Sem_050401_top_level_001 { 

	type component GeneralComp {
	}	
	
	function f(in integer p_int) {
        if (p_int == 0) { setverdict(pass); } // reading from p_int
        else { setverdict(fail); }
	}
	
	testcase TC_Sem_050401_top_level_001() runs on GeneralComp {
		f(0);
	}

	control{
		execute(TC_Sem_050401_top_level_001());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that in parameters can be set within parametrized content
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For all these three sorts of parameter passing, the formal parameters can both be read and set 
// (i.e. get new values being assigned) within the parametrized object.

module Sem_050401_top_level_004 { 

	type component GeneralComp {
	}	
	
	function f(in integer p_int) {
        p_int := 3; // setting p_int within parametrized content
        if (p_int == 3) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	testcase TC_Sem_050401_top_level_004() runs on GeneralComp {
		f(0);
	}

	control{
		execute(TC_Sem_050401_top_level_004());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that strong typing is used for passing inout parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When parameters are passed by reference, strong typing is required. Both the actual and formal 
// parameter shall be of the same type.

module Sem_050401_top_level_018 { 

	type component GeneralComp {
	}
    
    type record R1 {
        integer field1,
        integer field2
    }
    
	function f(inout R1 p_rec) {
        if (match(p_rec, {1, 2})) { setverdict(pass); }
        else { setverdict(fail, "p_rec value not matching ", p_rec, {1, 2}); }
	}
	
	testcase TC_Sem_050401_top_level_018() runs on GeneralComp {
        var R1 v_rec := { field1 := 1, field2 := 2 };
		f(v_rec);
	}

	control{
		execute(TC_Sem_050401_top_level_018());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that out parameters can be read within parametrized content
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For all these three sorts of parameter passing, the formal parameters can both be read and set 
// (i.e. get new values being assigned) within the parametrized object.

module Sem_050401_top_level_002 { 

	type component GeneralComp {
	}	
	
	function f(out integer p_int) {
        log(p_int); // read access: UNINITIALIZED shall be printed as no assignment has been made        
	}
	
	testcase TC_Sem_050401_top_level_002() runs on GeneralComp {
		var integer v_int := 10;
        f(v_int);
        if (v_int == 10) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control{
		execute(TC_Sem_050401_top_level_002());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that @fuzzy modifier can be used for value parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal value or template parameters may be declared fuzzy using the @fuzzy modifier. The behaviour 
// of fuzzy parameters is defined in clause 3.1, definition of fuzzy values or templates. 

module Sem_050401_top_level_022 { 

	type component GeneralComp {
	}
    
	function f(@fuzzy integer p_int) {
        if (p_int == 1) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	testcase TC_Sem_050401_top_level_022() runs on GeneralComp {
		f(1);
	}

	control{
		execute(TC_Sem_050401_top_level_022());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that inout parameters can be used as actual inout parameters of parameterized objects
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal parameters can be used directly as actual parameters for other parametrized objects, 
// e.g. as actual parameters in function invocations or as actual parameters in template instances.

module Sem_050401_top_level_015 { 

	type component GeneralComp {
	}	
	
    function fx(inout integer p_int) {
        p_int := 3;
    }
    
	function f(inout integer p_int) {
        fx(p_int);
        setverdict(pass);
	}
	
	testcase TC_Sem_050401_top_level_015() runs on GeneralComp {
		var integer v_int := 0;
        f(v_int);
	}

	control{
		execute(TC_Sem_050401_top_level_015());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that @lazy modifier can be used for value parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal value or template parameters may be declared lazy using the @lazy modifier. The behaviour 
// of lazy parameters is defined in clause 3.1, definition of lazy values or templates. 

module Sem_050401_top_level_019 { 

	type component GeneralComp {
	}
    
	function f(@lazy integer p_int) {
        if (p_int == 1) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	testcase TC_Sem_050401_top_level_019() runs on GeneralComp {
		f(1);
	}

	control{
		execute(TC_Sem_050401_top_level_019());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that in parameters can be used as actual inout parameters of parameterized objects
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal parameters can be used directly as actual parameters for other parametrized objects, 
// e.g. as actual parameters in function invocations or as actual parameters in template instances.

module Sem_050401_top_level_009 { 

	type component GeneralComp {
	}	
	
    function fx(inout integer p_int) {
        p_int := p_int + 3;
    }
    
	function f(in integer p_int) {
        fx(p_int);
        setverdict(pass);
	}
	
	testcase TC_Sem_050401_top_level_009() runs on GeneralComp {
		f(5);
	}

	control{
		execute(TC_Sem_050401_top_level_009());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that in parameters can be used as actual in parameters of parameterized objects
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal parameters can be used directly as actual parameters for other parametrized objects, 
// e.g. as actual parameters in function invocations or as actual parameters in template instances.

module Sem_050401_top_level_007 { 

	type component GeneralComp {
	}	
	
    template integer mw_range(in integer p_upperBound) := (0..p_upperBound);
    
	function f(in integer p_int) {
        var template integer vm_t := mw_range(p_int);
        log(vm_t);
        setverdict(pass);
	}
	
	testcase TC_Sem_050401_top_level_007() runs on GeneralComp {
		f(5);
	}

	control{
		execute(TC_Sem_050401_top_level_007());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that passing fuzzy parameter to formal parameter without modifier disables fuzzy evaluation
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Lazy and fuzzy properties are valid only in the scope, where the parameters' names are visible. 
// For example, if a fuzzy parameter is passed to a formal parameter declared without a modifier, it 
// loses its fuzzy feature inside the called function. Similarly, if it is passed to a lazy formal 
// parameter, it becomes lazy within the called function.

module Sem_050401_top_level_028 { 

	type component GeneralComp {
        var integer vc_int := 20;
	}

    function fx(integer p_int) runs on GeneralComp {
        vc_int := 0; // doesn't have effect on the parameter value anymore as the parameter is not lazy
        if (p_int == 21) { setverdict(pass); }
        else { setverdict(fail); }
    }
	function f(@fuzzy integer p_int) runs on GeneralComp {
        fx(p_int); // causes evaluation of the value
	}
	
	testcase TC_Sem_050401_top_level_028() runs on GeneralComp {
		f(vc_int + 1); // vc_int is equal to 20 at the time of function call
	}

	control{
		execute(TC_Sem_050401_top_level_028());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that @fuzzy modifier can be used for template parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal value or template parameters may be declared fuzzy using the @fuzzy modifier. The behaviour 
// of fuzzy parameters is defined in clause 3.1, definition of fuzzy values or templates. 

module Sem_050401_top_level_023 { 

	type component GeneralComp {
	}
    
	function f(template @fuzzy integer pm_int) {
        if (match(1, pm_int)) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	testcase TC_Sem_050401_top_level_023() runs on GeneralComp {
		f(1);
	}

	control{
		execute(TC_Sem_050401_top_level_023());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that fuzzy parameter passed to lazy formal parameter enables lazy evaluation
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Lazy and fuzzy properties are valid only in the scope, where the parameters' names are visible. 
// For example, if a fuzzy parameter is passed to a formal parameter declared without a modifier, it 
// loses its fuzzy feature inside the called function. Similarly, if it is passed to a lazy formal 
// parameter, it becomes lazy within the called function.

module Sem_050401_top_level_029 { 

	type component GeneralComp {
        var integer vc_int := 20;
	}

    function fx(@lazy integer p_int) runs on GeneralComp {
        vc_int := 0; // p_int hasn't been evaluated yet - this change will have impact on evaluation
        if (p_int == 1) { setverdict(pass); }
        else { setverdict(fail); }
        vc_int := 10; // no impact on p_int value as the parameter has been already evaluated
        if (p_int == 1) { setverdict(pass); }
        else { setverdict(fail); }
    }
	function f(@fuzzy integer p_int) runs on GeneralComp {
        fx(p_int); // no evaluation of the value yet
	}
	
	testcase TC_Sem_050401_top_level_029() runs on GeneralComp {
		f(vc_int + 1); // vc_int is equal to 20 at the time of function call
	}

	control{
		execute(TC_Sem_050401_top_level_029());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that inout parameters can be read within parametrized content
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For all these three sorts of parameter passing, the formal parameters can both be read and set 
// (i.e. get new values being assigned) within the parametrized object.

module Sem_050401_top_level_003 { 

	type component GeneralComp {
	}	
	
	function f(inout integer p_int) {
        if (p_int == 0) { setverdict(pass); } // reading from p_int
        else { setverdict(fail); }
	}
	
	testcase TC_Sem_050401_top_level_003() runs on GeneralComp {
        var integer v_int := 0;
		f(v_int);
	}

	control{
		execute(TC_Sem_050401_top_level_003());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that passing lazy parameter to formal parameter without modifier disables lazy evaluation
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Lazy and fuzzy properties are valid only in the scope, where the parameters' names are visible. 
// For example, if a fuzzy parameter is passed to a formal parameter declared without a modifier, it 
// loses its fuzzy feature inside the called function. Similarly, if it is passed to a lazy formal 
// parameter, it becomes lazy within the called function.

module Sem_050401_top_level_027 { 

	type component GeneralComp {
        var integer vc_int := 20;
	}

    function fx(integer p_int) runs on GeneralComp {
        vc_int := 0; // doesn't have effect on the parameter value anymore as the parameter is not lazy
        if (p_int == 21) { setverdict(pass); }
        else { setverdict(fail); }
    }
	function f(@lazy integer p_int) runs on GeneralComp {
        fx(p_int); // causes evaluation of the value
	}
	
	testcase TC_Sem_050401_top_level_027() runs on GeneralComp {
		f(vc_int + 1); // vc_int is equal to 20 at the time of function call
	}

	control{
		execute(TC_Sem_050401_top_level_027());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that compatibility rules are used for passing in parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// If parameters are passed by value (i.e. in case of in and out parameters), type compatibility 
// rules specified in 6.3 apply.

module Sem_050401_top_level_016 { 

	type component GeneralComp {
	}
    
    type record R1 {
        integer field1,
        integer field2
    }
    
    type record R2 {
        integer option1,
        integer option2
    }
	
	function f(R2 p_rec) {
        if (match(p_rec, {1, 2})) { setverdict(pass); }
        else { setverdict(fail, "p_rec value not matching ", p_rec, {1, 2}); }
	}
	
	testcase TC_Sem_050401_top_level_016() runs on GeneralComp {
        var R1 v_rec := { field1 := 1, field2 := 2 };
		f(v_rec);
	}

	control{
		execute(TC_Sem_050401_top_level_016());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that inout parameters can be set within parametrized content
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For all these three sorts of parameter passing, the formal parameters can both be read and set 
// (i.e. get new values being assigned) within the parametrized object.

module Sem_050401_top_level_006 { 

	type component GeneralComp {
	}	
	
	function f(inout integer p_int) {
        p_int := 3; // setting p_int within parametrized content
        if (p_int == 3) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	testcase TC_Sem_050401_top_level_006() runs on GeneralComp {
		var integer v_int := 0;
        f(v_int);
	}

	control{
		execute(TC_Sem_050401_top_level_006());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that out parameters can be used as actual inout parameters of parameterized objects
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal parameters can be used directly as actual parameters for other parametrized objects, 
// e.g. as actual parameters in function invocations or as actual parameters in template instances.

module Sem_050401_top_level_012 { 

	type component GeneralComp {
	}	
	
    function fx(inout integer p_int) {
        p_int := 3;
    }
    
	function f(out integer p_int) {
        p_int := 0;
        fx(p_int);
        setverdict(pass);
	}
	
	testcase TC_Sem_050401_top_level_012() runs on GeneralComp {
		var integer v_int;
        f(v_int);
	}

	control{
		execute(TC_Sem_050401_top_level_012());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that default values of @lazy parameters are properly evaluated
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Assigning default values for lazy and fuzzy formal parameters does not change the parameters' semantics: 
// when the default values are used as actual values for the parameters, they shall be evaluated the same 
// way (i.e. delayed) as if an actual parameter was provided.

module Sem_050401_top_level_025 { 

	type component GeneralComp {
	}

	function f(@lazy float p_int := rnd()) runs on GeneralComp {
        var float v_float;
        // rnd function is used for checking:
        // 1. first rnd with a seed is called to initiate the generator with a fixed value
        // 2. the next call is without a seed (to continue the sequence); this value is saved
        // 3. the third call re-uses the seed to restart the sequence
        // 4. the rnd call used in evaluation of the default value shall produce the same result now as in the 2nd step
        rnd(1.0);
        v_float := rnd();
        rnd(1.0);
        if (p_int == v_float) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	testcase TC_Sem_050401_top_level_025() runs on GeneralComp {
		f();
	}

	control{
		execute(TC_Sem_050401_top_level_025());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that in parameters can be used as actual out parameters of parameterized objects
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal parameters can be used directly as actual parameters for other parametrized objects, 
// e.g. as actual parameters in function invocations or as actual parameters in template instances.

module Sem_050401_top_level_008 { 

	type component GeneralComp {
	}	
	
    function fx(out integer p_int) {
        p_int := 3;
    }
    
	function f(in integer p_int) {
        fx(p_int);
        setverdict(pass);
	}
	
	testcase TC_Sem_050401_top_level_008() runs on GeneralComp {
		f(5);
	}

	control{
		execute(TC_Sem_050401_top_level_008());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that compatibility rules are used for passing out parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// If parameters are passed by value (i.e. in case of in and out parameters), type compatibility 
// rules specified in 6.3 apply.

module Sem_050401_top_level_017 { 

	type component GeneralComp {
	}
    
    type record R1 {
        integer field1,
        integer field2
    }
    
    type record R2 {
        integer option1,
        integer option2
    }
	
	function f(out R2 p_rec) {
        p_rec.option1 := 1;
        p_rec.option2 := 2; 
	}
	
	testcase TC_Sem_050401_top_level_017() runs on GeneralComp {
        var R1 v_rec;
		f(v_rec);
        if (match(v_rec, {1, 2})) { setverdict(pass); }
        else { setverdict(fail, "v_rec value not matching ", v_rec, {1, 2}); }
	}

	control{
		execute(TC_Sem_050401_top_level_017());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that out parameters can be used as actual in parameters of parameterized objects
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal parameters can be used directly as actual parameters for other parametrized objects, 
// e.g. as actual parameters in function invocations or as actual parameters in template instances.

module Sem_050401_top_level_010 { 

	type component GeneralComp {
	}	
	
    template integer mw_range(in integer p_upperBound) := (0..p_upperBound);
    
	function f(out integer p_int) {
        var template integer vm_t;
        p_int := 5;
        vm_t := mw_range(p_int);
        log(vm_t);
        setverdict(pass);
	}
	
	testcase TC_Sem_050401_top_level_010() runs on GeneralComp {
		var integer v_int := 0;
        f(v_int);
	}

	control{
		execute(TC_Sem_050401_top_level_010());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that @lazy parameters containing component variable references are properly evaluated
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal value or template parameters may be declared lazy using the @lazy modifier. The behaviour 
// of lazy parameters is defined in clause 3.1, definition of lazy values or templates. 

// Note: the test checks the situation described in NOTE 2:
// The actual values of component variables used in the delayed evaluation of a lazy or fuzzy parameter 
// may differ from their values at the time, when the parameterized function or alstep was called.

module Sem_050401_top_level_021 { 

	type component GeneralComp {
        var integer vc_int := 20;
	}
    
	function f(@lazy integer p_int) runs on GeneralComp {
        vc_int := 0;
        if (p_int == 1) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	testcase TC_Sem_050401_top_level_021() runs on GeneralComp {
		f(vc_int + 1);
	}

	control{
		execute(TC_Sem_050401_top_level_021());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that default values of @fuzzy parameters are properly evaluated
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Assigning default values for lazy and fuzzy formal parameters does not change the parameters' semantics: 
// when the default values are used as actual values for the parameters, they shall be evaluated the same 
// way (i.e. delayed) as if an actual parameter was provided.

module Sem_050401_top_level_026 { 

	type component GeneralComp {
	}

	function f(@fuzzy float p_int := rnd()) runs on GeneralComp {
        var float v_float;
        // rnd function is used for checking:
        // 1. first rnd with a seed is called to initiate the generator with a fixed value
        // 2. the next call is without a seed (to continue the sequence); this value is saved
        // 3. the third call re-uses the seed to restart the sequence
        // 4. the rnd call used in evaluation of the default value shall produce the same result now as in the 2nd step
        rnd(1.0);
        v_float := rnd();
        rnd(1.0);
        if (p_int == v_float) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	testcase TC_Sem_050401_top_level_026() runs on GeneralComp {
		f();
	}

	control{
		execute(TC_Sem_050401_top_level_026());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that inout parameters can be used as actual in parameters of parameterized objects
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Formal parameters can be used directly as actual parameters for other parametrized objects, 
// e.g. as actual parameters in function invocations or as actual parameters in template instances.

module Sem_050401_top_level_013 { 

	type component GeneralComp {
	}	
	
    template integer mw_range(in integer p_upperBound) := (0..p_upperBound);
    
	function f(inout integer p_int) {
        var template integer vm_t;
        vm_t := mw_range(p_int);
        log(vm_t);
        setverdict(pass);
	}
	
	testcase TC_Sem_050401_top_level_013() runs on GeneralComp {
		var integer v_int := 5;
        f(v_int);
	}

	control{
		execute(TC_Sem_050401_top_level_013());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.1, verify that out parameters can be set within parametrized content
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For all these three sorts of parameter passing, the formal parameters can both be read and set 
// (i.e. get new values being assigned) within the parametrized object.

module Sem_050401_top_level_005 { 

	type component GeneralComp {
	}	
	
	function f(out integer p_int) {
        p_int := 3; // setting p_int within parametrized content
        if (p_int == 3) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	testcase TC_Sem_050401_top_level_005() runs on GeneralComp {
		var integer v_int := 0;
        f(v_int);
	}

	control{
		execute(TC_Sem_050401_top_level_005());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variable element reference can be used as inout formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_141 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    type record R {
        integer field1
    }
    
    altstep a_test(inout template(present) integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(10, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_141() runs on GeneralComp {
        var template R v_val := { field1 := 10 };
        t.start;
        a_test(v_val.field1); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_141());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that inout value parameters can be used as in formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_010 { 

    type component GeneralComp {
    }
    
    function f_test(in integer p_val) {
        if (p_val == 8) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(inout integer p_val) {
        f_test(p_val); // tested parameter passing
    }
    
    testcase TC_Sem_050402_actual_parameters_010() runs on GeneralComp {
        var integer v_val := 8;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_010());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that function calls can be used as in formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_007 { 

    type component GeneralComp {
    }
    
    function f_ret() return integer {
        return 5;
    }
    
    function f_test(in integer p_val) {
        if (p_val == 5) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_007() runs on GeneralComp {
        f_test(f_ret()); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_007());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that default values are used if actual parameters are missing
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When a formal parameter has been defined with a default value or template, 
// respectively, then it is not necessary to provide an actual parameter.

module Sem_050402_actual_parameters_163 { 

    type component GeneralComp {
	}
    
    function f_test(integer p_val := 5) {
        if (p_val == 5) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_163() runs on GeneralComp {
        f_test(-); // tested parameter passing        
	}

	control {
		execute(TC_Sem_050402_actual_parameters_163());
	}
}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:5.4.2, Ensure that the IUT accepts allowed assignments of actual parameters.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_050402_actual_parameters_001 {

type enumerated MyEnumeratedType {e_black, e_white}
type integer address;

type record MyRecord {
 integer field1,
 boolean field2,
 address field3,
 MyEnumeratedType field4,
 integer field5
}


type component GeneralComp {	    	    

}

testcase TC_Sem_050402_actual_parameters_001 (
  MyRecord ExpectedMatch,
  integer p_integer := 0,
  boolean p_boolean := true,
  address p_address := null,
  MyEnumeratedType p_enumerated := e_black,
  template integer p_integerTemplate := ?
 ) runs on GeneralComp {

 var template MyRecord ReceivedRecord := {p_integer, p_boolean, p_address, p_enumerated, p_integerTemplate};

    if ( match(ExpectedMatch, ReceivedRecord)) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
 
}


control{

 var MyRecord DefaultValues  := {
  field1 := 0,
  field2 := true,
  field3 := null,
  field4 := e_black,
  field5 := 1			//any number can be used here to correspond with ? matching
 }

 var MyRecord ModifiedValues  := {
  field1 := 1,
  field2 := false,
  field3 := 1,
  field4 := e_white,
  field5 := 1
 }

 var MyRecord PartlyModifiedValues  := {
  field1 := 0,
  field2 := false,
  field3 := null,
  field4 := e_white,
  field5 := 1
 }

//possible ways of invoking assignment of actual parameters
    execute(TC_Sem_050402_actual_parameters_001(DefaultValues));
    execute(TC_Sem_050402_actual_parameters_001(DefaultValues,-,-,-,-,-));
    execute(TC_Sem_050402_actual_parameters_001(ExpectedMatch:=DefaultValues));
    
    execute(TC_Sem_050402_actual_parameters_001(ModifiedValues,1,false,1,e_white,1));
    execute(TC_Sem_050402_actual_parameters_001(p_integerTemplate:=1,p_boolean:=false,p_enumerated:=e_white,p_integer:=1,p_address:=1,ExpectedMatch:=ModifiedValues));
    
    execute(TC_Sem_050402_actual_parameters_001(PartlyModifiedValues,-,false,-,e_white,-));
    execute(TC_Sem_050402_actual_parameters_001(p_boolean:=false,p_enumerated:=e_white,ExpectedMatch:=PartlyModifiedValues));
    
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that literals can be used as in formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_099 { 

    type component GeneralComp {
	}	

    testcase TC_Sem_050402_actual_parameters_099(in template integer p_val) runs on GeneralComp {
        if (match(1, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_099(1)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that variables can be used as inout formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_039 { 

    type component GeneralComp {
    }
    
    function f_test(inout integer p_val) {
        if (p_val == 4) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_039() runs on GeneralComp {
        var integer v_val := 4;
        f_test(v_val); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_039());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that inout value parameters can be used as in formal value parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_019 { 

    type component GeneralComp {
    }
    
    template integer m_test(in integer p_val) := 11 + p_val;

    function f_caller(inout integer p_val) {
        if (match(19, m_test(p_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }
    
    testcase TC_Sem_050402_actual_parameters_019() runs on GeneralComp {
        var integer v_val := 8;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_019());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template in parameters can be used as out formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_120 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(out template integer p_val) runs on GeneralComp {
        []t.timeout {
            p_val := 0;
        }
    }

    function f_caller(in template integer p_val) runs on GeneralComp {
        a_test(p_val); // tested parameter passing
        if (match(0, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    
    testcase TC_Sem_050402_actual_parameters_120() runs on GeneralComp {
        t.start;
        f_caller(3); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_120());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that variables can be used as inout formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_051 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_051(inout integer p_val) runs on GeneralComp {
        if (p_val == 4) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
        var integer v_val := 4;
		execute(TC_Sem_050402_actual_parameters_051(v_val)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template inout parameters can be used as in formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_112 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_112(in template integer p_val) runs on GeneralComp {
        if (match(5, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

    function f_caller(inout template integer p_val) {
        execute(TC_Sem_050402_actual_parameters_112(p_val)); // tested parameter passing
    }

	control {
        var template integer vm_val := 5;
		f_caller(vm_val);
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that timer parameters can be passed to timer parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to formal timer parameters shall be component 
// timers, local timers or formal timer parameters of the current scope.

module Sem_050402_actual_parameters_159 { 

    type component GeneralComp {
	}

    function f_test(timer t_par) {
        t_par.stop;
    }
    
    function f_caller(timer t_par) {
        f_test(t_par);  // tested parameter passing
    }

    testcase TC_Sem_050402_actual_parameters_159() runs on GeneralComp {
        timer t_tmr := 5.0;
        t_tmr.start;
        f_caller(t_tmr); // this parameter passing is not a subject of the test
        if (not t_tmr.running) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_159());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that referencing rules are correctly applied to actual parameters of in formal value parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When actual parameters that are passed to in formal value or template parameters 
// contain a value or template reference, rules for using references on the right hand 
// side of assignments apply. 

module Sem_050402_actual_parameters_149 { 

    type component GeneralComp {
	}
    
    type record R {
        integer field1,
        record {
            integer subfield1,
            integer subfield2
        } field2 optional
    }

    function f_test(in integer p_val) {
        if (p_val == 2) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_149() runs on GeneralComp {
        var R v_rec := {
            field1 := 1,
            field2 := {
                subfield1 := 2,
                subfield2 := 3
            }
        }
        f_test(v_rec.field2.subfield1); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_149());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that variables can be used as in formal template parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_074 { 

    type component GeneralComp {
    }
    
    template integer m_test(in template integer p_val) := 11 + valueof(p_val);

    testcase TC_Sem_050402_actual_parameters_074() runs on GeneralComp {
        var integer v_val := 4;
        if (match(15, m_test(v_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_074());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that constants can be used as in formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_101 { 

    type component GeneralComp {
	}	

    const integer c_val := 3;

    testcase TC_Sem_050402_actual_parameters_101(in template integer p_val) runs on GeneralComp {
        if (match(3, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_101(c_val)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that constants can be used as in formal value parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_014 { 

    type component GeneralComp {
	}	

    const integer c_val := 3;
    
    template integer m_test(in integer p_val) := 11 + p_val;

    testcase TC_Sem_050402_actual_parameters_014() runs on GeneralComp {
        if (match(14, m_test(c_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_014());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that actual parameters at the end of list notation can be explicitly skipped
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The actual parameter of a formal parameter with default value can be skipped by using 
// dash "-" as actual parameter.

module Sem_050402_actual_parameters_177 { 

    type component GeneralComp {
	}

    function f_test (integer p_val1, integer p_val2 := 20) {
        if (match(p_val1, 1) and match(p_val2, 20)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_177() runs on GeneralComp {
        f_test(1, -);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_177());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that in value parameters can be used as in formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_035 { 

    type component GeneralComp {
    }
  
    testcase TC_Sem_050402_actual_parameters_035(in integer p_val) runs on GeneralComp {
        if (p_val == 6) { setverdict(pass); }
        else { setverdict(fail); }
	}
    
    function f_caller(in integer p_val) {
        execute(TC_Sem_050402_actual_parameters_035(p_val)); // tested parameter passing
    }

	control {
		f_caller(6); // this parameter passing is not a subject of the test
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that reference to elements of formal value parameters can be used as inout formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_142 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    type record R {
        integer field1
    }
    
    altstep a_test(inout template(present) integer p_val) runs on GeneralComp {
        []t.timeout {
           if (match(11, p_val)) { setverdict(pass); }
           else { setverdict(fail); }
        }
    }
    
    function f_caller(in template R p_param) runs on GeneralComp {
        a_test(p_param.field1); // tested parameter passing
    }

    testcase TC_Sem_050402_actual_parameters_142() runs on GeneralComp {
        t.start;
        f_caller({field1 := 11 });        
	}

	control {
		execute(TC_Sem_050402_actual_parameters_142());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variables can be used as out formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_125 { 

    type component GeneralComp {
	}
    
    testcase TC_Sem_050402_actual_parameters_125(out template integer p_val) runs on GeneralComp {
        p_val := ?;
        setverdict(pass);
	}

	control {
        var template integer vm_msg := 2;
		execute(TC_Sem_050402_actual_parameters_125(vm_msg)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that component timers can be passed to timer parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to formal timer parameters shall be component 
// timers, local timers or formal timer parameters of the current scope.

module Sem_050402_actual_parameters_157 { 

    type component GeneralComp {
        timer tc_tmr := 5.0;
	}
    
    function f_test(timer t_par) {
        t_par.stop;
    }

    testcase TC_Sem_050402_actual_parameters_157() runs on GeneralComp {
        tc_tmr.start;        
        f_test(tc_tmr); // tested parameter passing
        if (not tc_tmr.running) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_157());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that out value parameters can be used as in formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_009 { 

    type component GeneralComp {
    }
    
    function f_test(in integer p_val) {
        if (p_val == 7) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(out integer p_val) {
        p_val := 7; // out parameter shall have a value before we can pass it to a function
        f_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_009() runs on GeneralComp {
        var integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_009());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that default parameters are evaluated in order of the formal parameter list (list notation)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// If for some formal parameters no actual parameter has been provided, their default 
// values are taken and evaluated in the order of the formal parameter list.

module Sem_050402_actual_parameters_170 { 

    type component GeneralComp {
	}

    function f_eval1() return integer {
        setverdict(pass);
        return 1;
    }
    
    function f_eval2() return integer {
        if (getverdict != pass) { setverdict(fail); } // if f_eval was called, the verdict would be already pass
        return 2;
    }
    
    function f_test(integer p_par1, integer p_par2 := f_eval1(), integer p_par3 := f_eval2()) {
    }

    testcase TC_Sem_050402_actual_parameters_170() runs on GeneralComp {
        f_test(0, -, -); // tested feature: f_eval1 shall be called before f_eval2
	}

	control {
		execute(TC_Sem_050402_actual_parameters_170());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that expressions can be used as in formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_011 { 

    type component GeneralComp {
    }
    
    function f_ret() return integer {
        return 4;
    }
    
    function f_test(in integer p_val) {
        if (p_val == 9) { setverdict(pass); }
        else { setverdict(fail); }
    }
    
    testcase TC_Sem_050402_actual_parameters_011() runs on GeneralComp {
        var integer v_val := 5;
        f_test(10 + f_ret() - v_val); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_011());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that out value parameters can be used as inout formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_053 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_053(inout integer p_val) runs on GeneralComp {
        if (p_val == 7) { setverdict(pass); }
        else { setverdict(fail); }
	}
    
    function f_caller(out integer p_val) {
        p_val := 7; // out parameter shall have a value before we can pass it to a function
        execute(TC_Sem_050402_actual_parameters_053(p_val)); // tested parameter passing
    }


	control {
		var integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that in value parameters can be used as in formal value parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_017 { 

    type component GeneralComp {
    }
    
    template integer m_test(in integer p_val) := 11 + p_val;

    function f_caller(in integer p_val) {
        if (match(17, m_test(p_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    
    testcase TC_Sem_050402_actual_parameters_017() runs on GeneralComp {
        f_caller(6); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_017());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variables can be used as in formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_067 { 

    type component GeneralComp {
	}
    
    function f_test(in template integer p_val) {
        if (match(2, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_067() runs on GeneralComp {
        var template integer vm_msg := 2;
        f_test(vm_msg); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_067());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that variables can be used as in formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_060 { 

    type component GeneralComp {
    }
    
    function f_test(in template integer p_val) {
        if (match(4, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_060() runs on GeneralComp {
        var integer v_val := 4;
        f_test(v_val); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_060());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template out parameters can be used as out formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_121 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(out template integer p_val) runs on GeneralComp {
        []t.timeout {
            p_val := 0;
        }
    }

    function f_caller(out template integer p_val) runs on GeneralComp {
        p_val := 4; // out parameter shall have a value before we can pass it to a function
        a_test(p_val); // tested parameter passing
        if (match(0 , p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    
    testcase TC_Sem_050402_actual_parameters_121() runs on GeneralComp {
        var template integer v_val;
        t.start;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_121());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that empty actual parameter list can be used for altsteps with no parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// If the formal parameter list of TTCN-3 objects function, testcase, signature, 
// altstep or external function is empty, then the empty parentheses shall be 
// included both in the declaration and in the invocation of that object. In all 
// other cases the empty parentheses shall be omitted.

module Sem_050402_actual_parameters_190 { 

    type component GeneralComp {
	}

    altstep a_test () {
        [] any timer.timeout { setverdict(pass); }
    }

    testcase TC_Sem_050402_actual_parameters_190() runs on GeneralComp {
        timer t_instant := 0.0;
        t_instant.start;
        a_test();
	}

	control {
		execute(TC_Sem_050402_actual_parameters_190());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that variable element reference can be used as inout formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_043 { 

    type component GeneralComp {
    }
    
    type record R {
        integer field1
    }
    
    function f_test(inout integer p_val) {
        if (p_val == 10) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_043() runs on GeneralComp {
        var R v_val := { field1 := 10 };
        f_test(v_val.field1); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_043());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that expressions can be used as in formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_065 { 

    type component GeneralComp {
    }
    
    function f_ret() return integer {
        return 4;
    }
    
    function f_test(in template integer p_val) {
        if (match(9, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }
    
    testcase TC_Sem_050402_actual_parameters_065() runs on GeneralComp {
        var integer v_val := 5;
        f_test(10 + f_ret() - v_val); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_065());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that function calls can be used as in formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_103 { 

    type component GeneralComp {
    }
    
    function f_ret() return integer {
        return 5;
    }

    testcase TC_Sem_050402_actual_parameters_103(in template integer p_val) runs on GeneralComp {
        if (match(5, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_103(f_ret())); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that module parameters can be used as in formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_100 { 

    type component GeneralComp {
	}	

    modulepar integer PX_VAL := 2;    

    testcase TC_Sem_050402_actual_parameters_100(in template integer p_val) runs on GeneralComp {
        if (match(2, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_100(PX_VAL)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that Example 2 can be executed
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_050402_actual_parameters_194 { 

    type component GeneralComp {
	}
    
    type integer MyTemplateType;
    
    template MyTemplateType MyGlobalTemplate := ?;
    
    function MyFunction(in template MyTemplateType MyValueParameter){
        setverdict(pass);
    };
    // MyValueParameter is in parameter, the in keyword is optional
    
    testcase TC_Sem_050402_actual_parameters_194() runs on GeneralComp {
        // A function call with an actual parameter
        MyFunction(MyGlobalTemplate);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_194());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that rules for referencing are applied to actual paremeters before passing to out formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Before passing the actual parameter, the rules for referencing the element on 
// the left hand side of assignments are applied, expanding the structured value 
// so that the referenced element becomes accessible (see clauses 6.2 and 15.6 for 
// more details).

module Sem_050402_actual_parameters_168 { 

    type component GeneralComp {
        var integer vc_index := 0;
	}
    
    type record of integer RI;
    
    function f_test(out integer p_par1) runs on GeneralComp {        
        vc_index := 1;
        p_par1 := 10;
    }

    testcase TC_Sem_050402_actual_parameters_168() runs on GeneralComp {
        var RI v_ri := { 1, 2 }
        f_test(v_ri[vc_index]); // tested parameter passing
        if (v_ri == { 10, 2 }) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_168());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that variables can be used as inout formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_045 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(inout integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 4) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_045() runs on GeneralComp {
        var integer v_val := 4;
        t.start;
        a_test(v_val); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_045());
	}
}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:5.4.2, Ensure that the IUT accepts nested assignment of actual parameters.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
 
module Sem_050402_actual_parameters_002 {

type enumerated MyEnumeratedType {e_black, e_white}
type integer address;

type record MyRecord {
 integer field1,
 boolean field2,
 address field3,
 MyEnumeratedType field4,
 integer field5
}

template MyRecord m_parametrizedTemplate1 
 (
  integer p_integer := 0,
  boolean p_boolean := true,
  address p_address := null,
  MyEnumeratedType p_enumerated := e_black,
  template integer p_integerTemplate := ?
 ) := {
  field1 := p_integer,
  field2 := p_boolean,
  field3 := p_address,
  field4 := p_enumerated,
  field5 := p_integerTemplate
}


template MyRecord m_parametrizedTemplate2
 (
  integer p_integer := 0,
  boolean p_boolean := true,
  address p_address := null,
  MyEnumeratedType p_enumerated := e_black,
  template integer p_integerTemplate := ?
 ) := {
  field1 := p_integer+1,		//this line is different from the previous template
  field2 := not p_boolean,		//this line is different from the previous template
  field3 := p_address,
  field4 := p_enumerated,
  field5 := p_integerTemplate
}



type component GeneralComp {	    	    

}	


testcase TC_Sem_050402_actual_parameters_002(template MyRecord p_templateSelection) runs on GeneralComp {


 var MyRecord ExpectedValues  := {
  field1 := 1,
  field2 := false,
  field3 := 1,
  field4 := e_white,
  field5 := 1
 }

    if (match(ExpectedValues, p_templateSelection)) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
 
}


control{
    execute(TC_Sem_050402_actual_parameters_002(m_parametrizedTemplate1(1,false,1,e_white,1)) );
    execute(TC_Sem_050402_actual_parameters_002(m_parametrizedTemplate2(0,true,1,e_white,1)) );
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that out formal parameters are passed to actual parameter in correct (assignment notation)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The values of out formal parameters are passed to the actual parameters in the same 
// order as is the order of formal parameters in the definition of the parameterized 
// TTCN-3 object.

module Sem_050402_actual_parameters_156 { 

    type component GeneralComp {
	}
    
    function f_test(out integer p_val1, out integer p_val2, out integer p_val3) {
        p_val1 := 1;
        p_val2 := 2;
        p_val3 := 3;
    }

    testcase TC_Sem_050402_actual_parameters_156() runs on GeneralComp {
        var integer v_val;
        f_test(p_val3 := v_val, p_val2 := v_val, p_val1 := v_val); // tested parameter passing
        if (v_val == 3) { setverdict(pass); }
        else { setverdict(fail); }

	}

	control {
		execute(TC_Sem_050402_actual_parameters_156());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template inout parameters can be used as out formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_122 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(out template integer p_val) runs on GeneralComp {
        []t.timeout {
            p_val := 0;
        }
    }

    function f_caller(inout template integer p_val) runs on GeneralComp {
        a_test(p_val); // tested parameter passing
        if (match(0, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    
    testcase TC_Sem_050402_actual_parameters_122() runs on GeneralComp {
        var template integer v_val := 5;
        t.start;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_122());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that referencing rules are correctly applied to actual parameters of out formal value parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When actual parameters that are passed to inout and out formal value or template 
// parameters contain a value or template reference, rules for using references on 
// the left hand side of assignments apply.

module Sem_050402_actual_parameters_151 { 

    type component GeneralComp {
	}
    
    type record R {
        integer field1,
        record {
            integer subfield1,
            integer subfield2
        } field2 optional
    }

    function f_test(out integer p_val) {
        p_val := 10;
    }

    testcase TC_Sem_050402_actual_parameters_151() runs on GeneralComp {
        var R v_rec := {
            field1 := 1,
            field2 := {
                subfield1 := 2,
                subfield2 := 3
            }
        };
        f_test(v_rec.field2.subfield1); // tested parameter passing
        if (v_rec.field2.subfield1 == 10) { setverdict(pass); }
        else { setverdict(fail); }

	}

	control {
		execute(TC_Sem_050402_actual_parameters_151());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that the the Example 4 can be executed
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_050402_actual_parameters_198 { 

    type component GeneralComp {
	}
    
    // A function definition with an empty parameter list shall be written as
    function MyFunction() { setverdict(pass); }

    // A record definition with an empty parameter list shall be written as
    type record MyRecord { }
    // and shall be used as
    template MyRecord Mytemplate := { }

    testcase TC_Sem_050402_actual_parameters_198() runs on GeneralComp {
        // and shall be called as
        MyFunction();
	}

	control {
		execute(TC_Sem_050402_actual_parameters_198());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that out value parameters can be used as in formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_063 { 

    type component GeneralComp {
    }
    
    function f_test(in template integer p_val) {
        if (match(7, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(out integer p_val) {
        p_val := 7; // out parameter shall have a value before we can pass it to a function
        f_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_063() runs on GeneralComp {
        var integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_063());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that module parameters can be used as in formal template parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_072 { 

    type component GeneralComp {
	}	

    modulepar integer PX_VAL := 2;
    
    template integer m_test(in template integer p_val) := 11 + valueof(p_val);

    testcase TC_Sem_050402_actual_parameters_072() runs on GeneralComp {
        if (match(13, m_test(PX_VAL))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_072());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that inout value parameters can be used as in formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_092 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(in template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(8, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(inout integer p_val) runs on GeneralComp {
        t.start;
        a_test(p_val); // tested parameter passing
    }
    
    testcase TC_Sem_050402_actual_parameters_092() runs on GeneralComp {
        var integer v_val := 8;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_092());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variables can be used as inout formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_131 { 

    type component GeneralComp {
	}
    
    function f_test(inout template integer p_val) {
        if (match(2, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_131() runs on GeneralComp {
        var template integer vm_msg := 2;
        f_test(vm_msg); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_131());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that out value parameters can be used as inout formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_047 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(inout integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 7) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(out integer p_val) runs on GeneralComp {
        t.start;
        p_val := 7; // out parameter shall have a value before we can pass it to a function
        a_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_047() runs on GeneralComp {
        var integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_047());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that reference to elements of formal value parameters can be used as inout formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_136 { 

    type component GeneralComp {
    }
    
    type record R {
        integer field1
    }
    
    function f_test(inout template(present) integer p_val) {
        if (match(11, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }
    
    function f_caller(in template R p_param) {
        f_test(p_param.field1); // tested parameter passing
    }

    testcase TC_Sem_050402_actual_parameters_136() runs on GeneralComp {
        f_caller({field1 := 11 });        
	}

	control {
		execute(TC_Sem_050402_actual_parameters_136());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that function calls can be used as in formal template parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_075 { 

    type component GeneralComp {
    }
    
    function f_ret() return integer {
        return 5;
    }
    
    template integer m_test(in template integer p_val) := 11 + valueof(p_val);

    testcase TC_Sem_050402_actual_parameters_075() runs on GeneralComp {
        if (match(16, m_test(f_ret()))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_075());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template inout parameters can be used as in formal template parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_084 { 

    type component GeneralComp {
    }
    
    template integer m_test(in template integer p_val) := 5 + valueof(p_val);

    function f_caller(inout template integer p_val) {
        if (match(10, m_test(p_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    
    testcase TC_Sem_050402_actual_parameters_084() runs on GeneralComp {
        var template integer v_val := 5;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_084());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that reference to elements of formal value parameters can be used as inout formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_056 { 

    type component GeneralComp {
    }
    
    type record R {
        integer field1
    }

    testcase TC_Sem_050402_actual_parameters_056(inout integer p_val) runs on GeneralComp {
        if (p_val == 11) { setverdict(pass); }
        else { setverdict(fail); }
	}
    
    function f_caller(in R p_param) {
        execute(TC_Sem_050402_actual_parameters_056(p_param.field1)); // tested parameter passing
    }

	control {
        f_caller({field1 := 11 });
		
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that the first part of the Example 3 can be executed
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_050402_actual_parameters_195 { 

    type component GeneralComp {
	}
    
    function MyFunction(inout boolean MyReferenceParameter)  { 
        // MyReferenceParameter is an inout parameter
        setverdict(pass);
    }

    testcase TC_Sem_050402_actual_parameters_195() runs on GeneralComp {
        var boolean MyBooleanVariable := false;
        // A function call with an actual parameter
        MyFunction(MyBooleanVariable);
        // The actual parameter can be read and set within the function
	}

	control {
		execute(TC_Sem_050402_actual_parameters_195());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that expressions can be used as in formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_107 { 

    type component GeneralComp {
    }
    
    function f_ret() return integer {
        return 4;
    }
    
    testcase TC_Sem_050402_actual_parameters_107(in template integer p_val) runs on GeneralComp {
        if (match(9, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
        var integer v_val := 5;
		execute(TC_Sem_050402_actual_parameters_107(10 + f_ret() - v_val)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that in value parameters can be used as in formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_062 { 

    type component GeneralComp {
    }
    
    function f_test(in template integer p_val) {
        if (match(6, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(in integer p_val) {
        f_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_062() runs on GeneralComp {
        f_caller(6); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_062());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that the Example 6 can be executed
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_050402_actual_parameters_200 { 

    type component GeneralComp {
	}
    
    modulepar boolean logMessage := true;
    function logMsg(@lazy charstring complex) {
        if (logMessage) {
            log(complex);
        }
    }
    
    function computeComplexMessage() return charstring {
        // some complicated computation
        setverdict(pass);
        return "hello";
    }

    testcase TC_Sem_050402_actual_parameters_200() runs on GeneralComp {
        logMsg(computeComplexMessage()); // computeComplexMessage() is only invoked if
            // logMessage is true
	}

	control {
		execute(TC_Sem_050402_actual_parameters_200());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that rules for referencing are applied to actual paremeters before passing to inout formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Before passing the actual parameter, the rules for referencing the element on 
// the left hand side of assignments are applied, expanding the structured value 
// so that the referenced element becomes accessible (see clauses 6.2 and 15.6 for 
// more details).

module Sem_050402_actual_parameters_169 { 

    type component GeneralComp {
        var integer vc_index := 0;
	}
    
    type record of integer RI;
    
    function f_test(inout integer p_par1) runs on GeneralComp {        
        vc_index := 1;
        p_par1 := 10;
    }

    testcase TC_Sem_050402_actual_parameters_169() runs on GeneralComp {
        var RI v_ri := { 1, 2 }
        f_test(v_ri[vc_index]); // tested parameter passing
        if (v_ri == { 10, 2 }) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_169());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that inout value parameters can be used as inout formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_042 { 

    type component GeneralComp {
    }
    
    function f_test(inout integer p_val) {
        if (p_val == 8) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(inout integer p_val) {
        f_test(p_val); // tested parameter passing
    }
    
    testcase TC_Sem_050402_actual_parameters_042() runs on GeneralComp {
        var integer v_val := 8;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_042());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template out parameters can be used as out formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_115 { 

    type component GeneralComp {
    }
    
    function f_test(out template integer p_val) {
        p_val := 0;
    }

    function f_caller(out template integer p_val) {
        p_val := 4; // out parameter shall have a value before we can pass it to a function
        f_test(p_val); // tested parameter passing
        if (match(0, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    
    testcase TC_Sem_050402_actual_parameters_115() runs on GeneralComp {
        var template integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_115());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template out parameters can be used as in formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_111 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_111(in template integer p_val) runs on GeneralComp {
        if (match(4, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}
    
    function f_caller(out template integer p_val) {
        p_val := 4; // out parameter shall have a value before we can pass it to a function
        execute(TC_Sem_050402_actual_parameters_111(p_val)); // tested parameter passing
    }

	control {
        var template integer vm_val;
        f_caller(vm_val);
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that variables can be used as in formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_024 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 4) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_024() runs on GeneralComp {
        var integer v_val := 4;
        t.start;
        a_test(v_val); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_024());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template parameters can be used as in formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_108 { 

    type component GeneralComp {
	}
    
    template integer m_msg := 1;

    testcase TC_Sem_050402_actual_parameters_108(in template integer p_val) runs on GeneralComp {
        if (match(1, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_108(m_msg)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that constants can be used as in formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_005 { 

    type component GeneralComp {
	}	

    const integer c_val := 3;
    
    function f_test(in integer p_val) {
        if (p_val == 3) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_005() runs on GeneralComp {
        f_test(c_val); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_005());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that referencing rules are correctly applied to actual parameters of inout formal template parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When actual parameters that are passed to inout and out formal value or template 
// parameters contain a value or template reference, rules for using references on 
// the left hand side of assignments apply.

module Sem_050402_actual_parameters_154 { 

    type component GeneralComp {
	}
    
    type record R {
        integer field1,
        record {
            integer subfield1,
            integer subfield2
        } field2 optional
    }

    function f_test(inout template(present) integer p_val) {
        if (match(25, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
        p_val := 10;
    }

    testcase TC_Sem_050402_actual_parameters_154() runs on GeneralComp {
        var template R v_rec := {
            field1 := 1,
            field2 := ?
        };
        f_test(v_rec.field2.subfield1); // tested parameter passing (using referencing rules specified at 15.6.2)
        if (match(valueof(v_rec.field2.subfield1), 10) and match(0, v_rec.field2.subfield2)) { setverdict(pass); }
        else { setverdict(fail); }

	}

	control {
		execute(TC_Sem_050402_actual_parameters_154());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variables can be used as in formal template parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_081 { 

    type component GeneralComp {
	}
    
    template integer m_test(in template integer p_val) := 5 + valueof(p_val);

    testcase TC_Sem_050402_actual_parameters_081() runs on GeneralComp {
        var template integer vm_msg := 2;
        if (match(7, m_test(vm_msg))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_081());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that in value parameters can be used as in formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_026 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 6) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(in integer p_val) runs on GeneralComp{
        t.start;
        a_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_026() runs on GeneralComp {
        f_caller(6); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_026());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variables can be used as out formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_113 { 

    type component GeneralComp {
	}
    
    function f_test(out template integer p_val) {
        p_val := 2;
    }

    testcase TC_Sem_050402_actual_parameters_113() runs on GeneralComp {
        var template integer vm_msg;
        f_test(vm_msg); // tested parameter passing
        if (match(2, vm_msg)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_113());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that partially initialized values can be passed to in formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Unless specified differently in the relevant clause(s), actual parameters 
// passed to in or inout formal parameters shall be at least partially 
// initialized (for an exemption see e.g. clause 16.1.2 of the present document).

module Sem_050402_actual_parameters_191 { 

    type component GeneralComp {
	}
    
    type record R {
        integer field1,
        integer field2 optional
    }

    function f_test (R p_val) {
        if (match(p_val.field1, 1) and not isbound(p_val.field2)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_191() runs on GeneralComp {
        var R v_rec;
        v_rec.field1 := 1;
        f_test(v_rec);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_191());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that module parameters can be used as in formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_086 { 

    type component GeneralComp {
        timer t := 0.0;
	}	

    modulepar integer PX_VAL := 2;
    
    altstep a_test(in template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(2, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_086() runs on GeneralComp {
        t.start;
        a_test(PX_VAL); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_086());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variables can be used as inout formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_143 { 

    type component GeneralComp {
	}
    
    testcase TC_Sem_050402_actual_parameters_143(inout template integer p_val) runs on GeneralComp {
        if (match(2, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
        var template integer vm_msg := 2;
		execute(TC_Sem_050402_actual_parameters_143(vm_msg)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that inout value parameters can be used as in formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_064 { 

    type component GeneralComp {
    }
    
    function f_test(in template integer p_val) {
        if (match(8, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(inout integer p_val) {
        f_test(p_val); // tested parameter passing
    }
    
    testcase TC_Sem_050402_actual_parameters_064() runs on GeneralComp {
        var integer v_val := 8;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_064());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that variable element reference can be used as inout formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_049 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    type record R {
        integer field1
    }
    
    altstep a_test(inout integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 10) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_049() runs on GeneralComp {
        var R v_val := { field1 := 10 };
        t.start;
        a_test(v_val.field1); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_049());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that out value parameters can be used as in formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_036 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_036(in integer p_val) runs on GeneralComp {
        if (p_val == 7) { setverdict(pass); }
        else { setverdict(fail); }
	}
    
    function f_caller(out integer p_val) {
        p_val := 7; // out parameter shall have a value before we can pass it to a function
        execute(TC_Sem_050402_actual_parameters_036(p_val)); // tested parameter passing
    }


	control {
		var integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that out value parameters can be used as in formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_091 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(in template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(7, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(out integer p_val) runs on GeneralComp {
        t.start;
        p_val := 7; // out parameter shall have a value before we can pass it to a function
        a_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_091() runs on GeneralComp {
        var integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_091());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template out parameters can be used as in formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_069 { 

    type component GeneralComp {
    }
    
    function f_test(in template integer p_val) {
        if (match(4, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(out template integer p_val) {
        p_val := 4; // out parameter shall have a value before we can pass it to a function
        f_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_069() runs on GeneralComp {
        var template integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_069());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variable element reference can be used as out formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_129 { 

    type component GeneralComp {
    }
    
    type record R {
        integer field1
    }

    testcase TC_Sem_050402_actual_parameters_129(out template integer p_val) runs on GeneralComp {
        p_val := ?;
        setverdict(pass);
	}

	control {
        var template R v_val := { field1 := 10 };
		execute(TC_Sem_050402_actual_parameters_129(v_val.field1)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that variables can be used as in formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_088 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(in template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(4, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_088() runs on GeneralComp {
        var integer v_val := 4;
        t.start;
        a_test(v_val); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_088());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variables can be used as in formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_109 { 

    type component GeneralComp {
	}
    
    testcase TC_Sem_050402_actual_parameters_109(in template integer p_val) runs on GeneralComp {
        if (match(2, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
        var template integer vm_msg := 2;
		execute(TC_Sem_050402_actual_parameters_109(vm_msg)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template in parameters can be used as inout formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_138 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(inout template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(3, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(in template integer p_val) runs on GeneralComp {
        a_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_138() runs on GeneralComp {
        t.start;
        f_caller(3); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_138());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variable element reference can be used as inout formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_135 { 

    type component GeneralComp {
    }
    
    type record R {
        integer field1
    }
    
    function f_test(inout template(present) integer p_val) {
        if (match(10, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_135() runs on GeneralComp {
        var template R v_val := { field1 := 10 };
        f_test(v_val.field1); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_135());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that reference to elements of formal value parameters can be used as out formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_124 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    type record R {
        integer field1
    }
    
    altstep a_test(out template integer p_val) runs on GeneralComp {
        []t.timeout {
           p_val := 5; 
        }
    }
    
    function f_caller(in template R p_param) runs on GeneralComp {
        a_test(p_param.field1); // tested parameter passing
        if (match({ field1 := 5 }, p_param)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_124() runs on GeneralComp {
        t.start;
        f_caller({field1 := 11 });        
	}

	control {
		execute(TC_Sem_050402_actual_parameters_124());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template inout parameters can be used as inout formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_140 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(inout template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(5, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(inout template integer p_val) runs on GeneralComp {
        a_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_140() runs on GeneralComp {
        var template integer v_val := 5;
        t.start;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_140());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that in value parameters can be used as in formal template parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_076 { 

    type component GeneralComp {
    }
    
    template integer m_test(in template integer p_val) := 11 + valueof(p_val);

    function f_caller(in integer p_val) {
        if (match(17, m_test(p_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    
    testcase TC_Sem_050402_actual_parameters_076() runs on GeneralComp {
        f_caller(6); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_076());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variable element reference can be used as out formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_117 { 

    type component GeneralComp {
    }
    
    type record R {
        integer field1
    }
    
    function f_test(out template integer p_val) {
        p_val := ?;
    }

    testcase TC_Sem_050402_actual_parameters_117() runs on GeneralComp {
        var template R v_val := { field1 := 10 };
        f_test(v_val.field1); // tested parameter passing
        if (match( { field1 := 0 }, v_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_117());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that out value parameters can be used as in formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_027 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 7) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(out integer p_val) runs on GeneralComp {
        t.start;
        p_val := 7; // out parameter shall have a value before we can pass it to a function
        a_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_027() runs on GeneralComp {
        var integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_027());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that function calls can be used as in formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_034 { 

    type component GeneralComp {
    }
    
    function f_ret() return integer {
        return 5;
    }

    testcase TC_Sem_050402_actual_parameters_034(in integer p_val) runs on GeneralComp {
        if (p_val == 5) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_034(f_ret())); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that missing actual parameters at the end of list notation are considered to be skipped (multiple parameter)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// An actual parameter can also be skipped by just leaving it out if no other actual 
// parameter follows in the actual parameter list - either because the parameter is 
// last or because all following formal parameters have default values and are left out.

module Sem_050402_actual_parameters_179 { 

    type component GeneralComp {
        var integer vc_counter := 0;
	}

    function f_test (integer p_val1, integer p_val2 := 20, integer p_val3 := 30, integer p_val4 := 40) {
        if (match(p_val1, 1) and match(p_val2, 20) and match(p_val3, 30) and match(p_val4, 40)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_179() runs on GeneralComp {
        f_test(1, -);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_179());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that reference to elements of formal value parameters can be used as out formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_130 { 

    type component GeneralComp {
    }
    
    type record R {
        integer field1
    } 

    testcase TC_Sem_050402_actual_parameters_130(out template integer p_val) runs on GeneralComp {
        p_val := ?;
        setverdict(pass);            
	}
    
    function f_caller(in template R p_param) {
        execute(TC_Sem_050402_actual_parameters_130(p_param.field1)); // tested parameter passing
    }

	control {
        var template R mw_t := { field1 := 1 };
		f_caller(mw_t);
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that variable element reference can be used as inout formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_055 { 

    type component GeneralComp {
    }
    
    type record R {
        integer field1
    }

    testcase TC_Sem_050402_actual_parameters_055(inout integer p_val) runs on GeneralComp {
        if (p_val == 10) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
        var R v_val := { field1 := 10 };
		execute(TC_Sem_050402_actual_parameters_055(v_val.field1)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that in value parameters can be used as in formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_008 { 

    type component GeneralComp {
    }
    
    function f_test(in integer p_val) {
        if (p_val == 6) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(in integer p_val) {
        f_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_008() runs on GeneralComp {
        f_caller(6); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_008());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that function calls can be used as in formal value parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_016 { 

    type component GeneralComp {
    }
    
    function f_ret() return integer {
        return 5;
    }
    
    template integer m_test(in integer p_val) := 11 + p_val;

    testcase TC_Sem_050402_actual_parameters_016() runs on GeneralComp {
        if (match(16, m_test(f_ret()))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_016());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template in parameters can be used as inout formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_132 { 

    type component GeneralComp {
    }
    
    function f_test(inout template integer p_val) {
        if (match(3, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(in template integer p_val) {
        f_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_132() runs on GeneralComp {
        f_caller(3); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_132());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that compatible values can be passed to in formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The type of each actual parameter shall be compatible with the type of each 
// corresponding formal parameter.

module Sem_050402_actual_parameters_183 { 

    type component GeneralComp {
	}
    
    type record R1 {
        integer field1,
        integer field2 optional
    }
    
    type record R2 {
        integer elem1,
        integer elem2 optional
    }

    function f_test (R1 p_val) {
        if (p_val == { field1 := 1, field2 := 2 }) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_183() runs on GeneralComp {
        var R2 v_rec := { 1, 2 };
        f_test(v_rec);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_183());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that constants can be used as in formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_087 { 

    type component GeneralComp {
        timer t := 0.0;
	}	

    const integer c_val := 3;
    
    altstep a_test(in template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(3, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_087() runs on GeneralComp {
        t.start;
        a_test(c_val); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_087());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that expressions can be used as in formal value parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_020 { 

    type component GeneralComp {
	}	
    
    function f_ret() return integer {
        return 4;
    }

    template integer m_test(in integer p_val) := 11 + p_val;

    testcase TC_Sem_050402_actual_parameters_020() runs on GeneralComp {
        var integer v_val := 5;
        if (match(20, m_test(10 + f_ret() - v_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_020());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that literals can be used as in formal template parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_071 { 

    type component GeneralComp {
	}	

    template integer m_test(in template integer p_val) := 11 + valueof(p_val);

    testcase TC_Sem_050402_actual_parameters_071() runs on GeneralComp {
        if (match(12, m_test(1))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_071());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that function calls can be used as in formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_089 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    function f_ret() return integer {
        return 5;
    }
    
    altstep a_test(in template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(5, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_089() runs on GeneralComp {
        t.start;
        a_test(f_ret()); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_089());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that referencing rules are correctly applied to actual parameters of out formal template parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When actual parameters that are passed to inout and out formal value or template 
// parameters contain a value or template reference, rules for using references on 
// the left hand side of assignments apply.

module Sem_050402_actual_parameters_152 { 

    type component GeneralComp {
	}
    
    type record R {
        integer field1,
        record {
            integer subfield1,
            integer subfield2
        } field2 optional
    }

    function f_test(out template integer p_val) {
        p_val := 10;
    }

    testcase TC_Sem_050402_actual_parameters_152() runs on GeneralComp {
        var template R v_rec := {
            field1 := 1,
            field2 := ?
        };
        f_test(v_rec.field2.subfield1); // tested parameter passing (using referencing rules specified at 15.6.2)
        if (match(valueof(v_rec.field2.subfield1), 10) and match(0, v_rec.field2.subfield2)) { setverdict(pass); }
        else { setverdict(fail); }

	}

	control {
		execute(TC_Sem_050402_actual_parameters_152());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that reference to elements of formal value parameters can be used as inout formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_044 { 

    type component GeneralComp {
    }
    
    type record R {
        integer field1
    }
    
    function f_test(inout integer p_val) {
        if (p_val == 11) { setverdict(pass); }
        else { setverdict(fail); }
    }
    
    function f_caller(in R p_param) {
        f_test(p_param.field1); // tested parameter passing
    }

    testcase TC_Sem_050402_actual_parameters_044() runs on GeneralComp {
        f_caller({field1 := 11 });        
	}

	control {
		execute(TC_Sem_050402_actual_parameters_044());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that variables can be used as in formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_033 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_033(in integer p_val) runs on GeneralComp {
        if (p_val == 4) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
        var integer v_val := 4;
		execute(TC_Sem_050402_actual_parameters_033(v_val)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that module parameters can be used as in formal value parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_013 { 

    type component GeneralComp {
	}	

    modulepar integer PX_VAL := 2;
    
    template integer m_test(in integer p_val) := 11 + p_val;

    testcase TC_Sem_050402_actual_parameters_013() runs on GeneralComp {
        if (match(13, m_test(PX_VAL))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_013());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template out parameters can be used as in formal template parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_083 { 

    type component GeneralComp {
    }
    
    template integer m_test(in template integer p_val) := 5 + valueof(p_val);

    function f_caller(out template integer p_val) {
        p_val := 4; // out parameter shall have a value before we can pass it to a function
        if (match(9, m_test(p_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    
    testcase TC_Sem_050402_actual_parameters_083() runs on GeneralComp {
        var template integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_083());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template inout parameters can be used as out formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_116 { 

    type component GeneralComp {
    }
    
    function f_test(out template integer p_val) {
        p_val := 0;
    }

    function f_caller(inout template integer p_val) {
        f_test(p_val); // tested parameter passing
        if (match(0, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    
    testcase TC_Sem_050402_actual_parameters_116() runs on GeneralComp {
        var template integer v_val := 5;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_116());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that expressions can be used as in formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_093 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    function f_ret() return integer {
        return 4;
    }
    
    altstep a_test(in template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(9, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }
    
    testcase TC_Sem_050402_actual_parameters_093() runs on GeneralComp {
        var integer v_val := 5;
        t.start;
        a_test(10 + f_ret() - v_val); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_093());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that it is possible to use parametrized template with empty parentheses
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The empty brackets for instances of parameterized templates that have only parameters 
// with default values are optional when no actual parameters are provided, i.e. all 
// formal parameters use their default values.

module Sem_050402_actual_parameters_173 { 

    type component GeneralComp {
	}

    template integer mw_int (integer p_val := 10):= (0..p_val);

    testcase TC_Sem_050402_actual_parameters_173() runs on GeneralComp {
        if (match(5, mw_int())) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_173());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template out parameters can be used as inout formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_139 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(inout template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(4, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(out template integer p_val) runs on GeneralComp {
        p_val := 4; // out parameter shall have a value before we can pass it to a function
        a_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_139() runs on GeneralComp {
        var template integer v_val;
        t.start;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_139());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template out parameters can be used as inout formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_133 { 

    type component GeneralComp {
    }
    
    function f_test(inout template integer p_val) {
        if (match(4, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(out template integer p_val) {
        p_val := 4; // out parameter shall have a value before we can pass it to a function
        f_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_133() runs on GeneralComp {
        var template integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_133());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that reference to elements of formal value parameters can be used as inout formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_148 { 

    type component GeneralComp {
    }
    
    type record R {
        integer field1
    } 

    testcase TC_Sem_050402_actual_parameters_148(inout template(present) integer p_val) runs on GeneralComp {
        if (match(11, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}
    
    function f_caller(in template R p_param) {
        execute(TC_Sem_050402_actual_parameters_148(p_param.field1)); // tested parameter passing
    }

	control {
		f_caller({field1 := 11 });
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that literals can be used as in formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_057 { 

    type component GeneralComp {
	}	

    function f_test(in template integer p_val) {
        if (match(1, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_057() runs on GeneralComp {
        f_test(1); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_057());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that out value parameters can be used as in formal template parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_077 { 

    type component GeneralComp {
    }
    
    template integer m_test(in template integer p_val) := 11 + valueof(p_val);

    function f_caller(out integer p_val) {
        p_val := 7; // out parameter shall have a value before we can pass it to a function
        if (match(18, m_test(p_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    
    testcase TC_Sem_050402_actual_parameters_077() runs on GeneralComp {
        var integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_077());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that port parameters can be passed to port parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to formal port parameters shall be component 
// ports or formal port parameters of the current scope.

module Sem_050402_actual_parameters_161 { 

    type port IntPort message {
        inout integer;
    }
    
    type component GeneralComp {
        port IntPort p;
	}
    
    function f_test(IntPort p_port) {
        p_port.stop;
    }

    function f_caller(IntPort p_port) {
        f_test(p_port); // tested parameter passing
    }

    testcase TC_Sem_050402_actual_parameters_161() runs on GeneralComp {
        f_test(p); // this component port passing is not a subject of this test
        if (p.checkstate("Stopped")) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_161());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template out parameters can be used as out formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_127 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_127(out template integer p_val) runs on GeneralComp {
        p_val := ?;
        setverdict(pass);
	}
    
    function f_caller(out template integer p_val) {
        execute(TC_Sem_050402_actual_parameters_127(p_val)); // tested parameter passing
    }

	control {
        var template integer vm_val;
        f_caller(vm_val);
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that in value parameters can be used as in formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_090 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(in template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(6, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(in integer p_val) runs on GeneralComp{
        t.start;
        a_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_090() runs on GeneralComp {
        f_caller(6); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_090());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that module parameters can be used as in formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_058 { 

    type component GeneralComp {
	}	

    modulepar integer PX_VAL := 2;
    
    function f_test(in template integer p_val) {
        if (match(2, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_058() runs on GeneralComp {
        f_test(PX_VAL); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_058());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that literals can be used as in formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_021 { 

    type component GeneralComp {
        timer t := 0.0;
	}	

    altstep a_test(integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 1) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_021() runs on GeneralComp {
        t.start;
        a_test(1); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_021());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that actual parameters are evaluated in order of their appearance (list notation)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The actual parameters are evaluated in the order of their appearance.

module Sem_050402_actual_parameters_166 { 

    type component GeneralComp {
        var integer vc_counter := 0;
	}

    function f_eval1() runs on GeneralComp return integer {
        if (vc_counter == 0) 
        { 
            setverdict(pass); 
            vc_counter := vc_counter + 1;
        }
        else { setverdict(fail); }
        return vc_counter;
    }
    
    function f_eval2() runs on GeneralComp return integer {
        if (vc_counter == 1) 
        { 
            setverdict(pass); 
            vc_counter := vc_counter + 1;
        }
        else { setverdict(fail); }
        return vc_counter;
    }
    
    function f_test(integer p_par1, integer p_par2) {        
    }

    testcase TC_Sem_050402_actual_parameters_166() runs on GeneralComp {
        f_test(f_eval1(), f_eval2()); // tested feature: f_eval1 shall be called before f_eval2
	}

	control {
		execute(TC_Sem_050402_actual_parameters_166());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template in parameters can be used as inout formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_144 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_144(inout template integer p_val) runs on GeneralComp {
        if (match(3, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}
    
    function f_caller(in template integer p_val) {
        execute(TC_Sem_050402_actual_parameters_144(p_val)); // tested parameter passing
    }

	control {
		f_caller(3); // this parameter passing is not a subject of the test
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that reference to elements of formal value parameters can be used as inout formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_050 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    type record R {
        integer field1
    }
    
    altstep a_test(inout integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 11) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }
    
    function f_caller(in R p_param) runs on GeneralComp {
        a_test(p_param.field1); // tested parameter passing
    }

    testcase TC_Sem_050402_actual_parameters_050() runs on GeneralComp {
        t.start;
        f_caller({field1 := 11 });        
	}

	control {
		execute(TC_Sem_050402_actual_parameters_050());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that expressions can be used as in formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_038 { 

    type component GeneralComp {
    }
    
    function f_ret() return integer {
        return 4;
    }
    
    testcase TC_Sem_050402_actual_parameters_038(in integer p_val) runs on GeneralComp {
        if (p_val == 9) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
        var integer v_val := 5;
		execute(TC_Sem_050402_actual_parameters_038(10 + f_ret() - v_val)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that component timers can be passed to timer parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to formal timer parameters shall be component 
// timers, local timers or formal timer parameters of the current scope.

module Sem_050402_actual_parameters_158 { 

    type component GeneralComp {
	}
    
    function f_test(timer t_par) {
        t_par.stop;
    }

    testcase TC_Sem_050402_actual_parameters_158() runs on GeneralComp {
        timer t_tmr := 5.0;
        t_tmr.start;        
        f_test(t_tmr); // tested parameter passing
        if (not t_tmr.running) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_158());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that the Example 5 can be executed
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_050402_actual_parameters_199 { 

    type port P message {
        inout MyMessageType;
    }
    
    type component GeneralComp {
        port P MyPCO;
	}
    
    // Given the message definition
    type record MyMessageType
    {
        integer field1,
        charstring field2,
        boolean field3
    }
    
    // A message template might be
    template MyMessageType MyTemplate(integer MyValue) :=
    {
        field1 := MyValue,
        field2 := pattern "abc*xyz",
        field3 := true
    }

    testcase TC_Sem_050402_actual_parameters_199(template MyMessageType RxMsg) runs on GeneralComp {
        MyPCO.send(MyMessageType:{7, "abcdefxyz", true });
        MyPCO.receive(RxMsg);
        setverdict(pass);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_199(MyTemplate(7)));
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that compatible templates can be passed to template parameters with omit restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters passed to restricted formal template parameters shall obey 
// the restrictions given in clause 15.8.

module Sem_050402_actual_parameters_185 { 

    type component GeneralComp {
	}

    function f_test (omit integer p_val) {
        if (match(1, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_185() runs on GeneralComp {
        f_test(1);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_185());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that constants can be used as in formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_032 { 

    type component GeneralComp {
	}	

    const integer c_val := 3;

    testcase TC_Sem_050402_actual_parameters_032(in integer p_val) runs on GeneralComp {
        if (p_val == 3) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_032(c_val)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that empty actual parameter list can be used for functions with no parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// If the formal parameter list of TTCN-3 objects function, testcase, signature, 
// altstep or external function is empty, then the empty parentheses shall be 
// included both in the declaration and in the invocation of that object. In all 
// other cases the empty parentheses shall be omitted.

module Sem_050402_actual_parameters_189 { 

    type component GeneralComp {
	}

    function f_test () {
        setverdict(pass);
    }

    testcase TC_Sem_050402_actual_parameters_189() runs on GeneralComp {
        f_test();
	}

	control {
		execute(TC_Sem_050402_actual_parameters_189());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template inout parameters can be used as in formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_098 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(in template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(5, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(inout template integer p_val) runs on GeneralComp {
        a_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_098() runs on GeneralComp {
        var template integer v_val := 5;
        t.start;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_098());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that out value parameters can be used as in formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_105 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_105(in template integer p_val) runs on GeneralComp {
        if (match(7, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}
    
    function f_caller(out integer p_val) {
        p_val := 7; // out parameter shall have a value before we can pass it to a function
        execute(TC_Sem_050402_actual_parameters_105(p_val)); // tested parameter passing
    }


	control {
		var integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that in value parameters can be used as in formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_104 { 

    type component GeneralComp {
    }
  
    testcase TC_Sem_050402_actual_parameters_104(in template integer p_val) runs on GeneralComp {
        if (match(6, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}
    
    function f_caller(in integer p_val) {
        execute(TC_Sem_050402_actual_parameters_104(p_val)); // tested parameter passing
    }

	control {
		f_caller(6); // this parameter passing is not a subject of the test
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that the Example 8 can be executed
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_050402_actual_parameters_202 { 

    type component GeneralComp {
	}
    
    function f_initValues (out integer p_par1, out integer p_par2) {
        p_par1 := 1;
        p_par2 := 2;
    }

    testcase TC_Sem_050402_actual_parameters_202() runs on GeneralComp {
        var integer v_var1;
        f_initValues(p_par2 := v_var1, p_par1 := v_var1);
        // After this function call, v_var1 will contain 2, as parameters are assigned in
        // the same order as in the definition of the f_initValues function. Thus p_par1 is
        // assigned first to v_var1 and p_par2 after that ovewriting the previous value.
        if (v_var1 == 2) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_202());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that reference to elements of formal value parameters can be used as out formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.
module Sem_050402_actual_parameters_118 { 

    type component GeneralComp {
    }
    
    type record R {
        integer field1
    }
    
    function f_test(out template integer p_val) {
        p_val := ?;
    }
    
    function f_caller(in template R p_param) {
        f_test(p_param.field1); // tested parameter passing
        if (match( { field1 := 0 }, p_param)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_118() runs on GeneralComp {
        f_caller({field1 := 11 });        
	}

	control {
		execute(TC_Sem_050402_actual_parameters_118());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that in value parameters can be used as inout formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_040 { 

    type component GeneralComp {
    }
    
    function f_test(inout integer p_val) {
        if (p_val == 6) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(in integer p_val) {
        f_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_040() runs on GeneralComp {
        f_caller(6); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_040());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that multiple actual parameters of list notation can be skipped
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The actual parameter of a formal parameter with default value can be skipped by using 
// dash "-" as actual parameter.

module Sem_050402_actual_parameters_176 { 

    type component GeneralComp {
	}

    function f_test (integer p_val1, integer p_val2 := 20, integer p_val3, integer p_val4 := 40, integer p_val5) {
        if ( match(p_val1, 1) and match(p_val2, 20) and match(p_val3, 3) and match(p_val4, 40) and match(p_val5, 5)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_176() runs on GeneralComp {
        f_test(1, -, 3, -, 5);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_176());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that inout value parameters can be used as in formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_037 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_037(in integer p_val) runs on GeneralComp {
        if (p_val == 8) { setverdict(pass); }
        else { setverdict(fail); }
	}

    function f_caller(inout integer p_val) {
        execute(TC_Sem_050402_actual_parameters_037(p_val)); // tested parameter passing
    }

	control {
        var integer v_val := 8;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that it is possible to use parametrized template with no parentheses if all parameters have default values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The empty brackets for instances of parameterized templates that have only parameters 
// with default values are optional when no actual parameters are provided, i.e. all 
// formal parameters use their default values.

module Sem_050402_actual_parameters_172 { 

    type component GeneralComp {
	}

    template integer mw_int (integer p_val := 10):= (0..p_val);

    testcase TC_Sem_050402_actual_parameters_172() runs on GeneralComp {
        if (match(5, mw_int)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_172());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that in value parameters can be used as inout formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_052 { 

    type component GeneralComp {
    }
  
    testcase TC_Sem_050402_actual_parameters_052(inout integer p_val) runs on GeneralComp {
        if (p_val == 6) { setverdict(pass); }
        else { setverdict(fail); }
	}
    
    function f_caller(in integer p_val) {
        execute(TC_Sem_050402_actual_parameters_052(p_val)); // tested parameter passing
    }

	control {
		f_caller(6); // this parameter passing is not a subject of the test
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that literals can be used as in formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_030 { 

    type component GeneralComp {
	}	

    testcase TC_Sem_050402_actual_parameters_030(in integer p_val) runs on GeneralComp {
        if (p_val == 1) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_030(1)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template parameters can be used as in formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_066 { 

    type component GeneralComp {
	}
    
    template integer m_msg := 1;
    
    function f_test(in template integer p_val) {
        if (match(1, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_066() runs on GeneralComp {
        f_test(m_msg); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_066());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that it is possible to use nested actual parameter lists
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// All parameterized entities specified as an actual parameter shall have their
// own parameters resolved in the top-level actual parameter list.

module Sem_050402_actual_parameters_188 { 

    type component GeneralComp {
	}
    
    type record R {
        integer field1,
        integer field2
    }
    
    template integer mw_int (integer p_upper) := (0..p_upper);
    
    template R mw_rec(template integer p_field2) := {
        field1 := 1,
        field2 := p_field2
    }

    function f_test (template R p_match) {
        if (match({1, 5}, p_match)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_188() runs on GeneralComp {
        f_test(mw_rec(mw_int(10)));
	}

	control {
		execute(TC_Sem_050402_actual_parameters_188());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that default parameters are evaluated in order of the formal parameter list (assignment notation)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// If for some formal parameters no actual parameter has been provided, their default 
// values are taken and evaluated in the order of the formal parameter list.

module Sem_050402_actual_parameters_171 { 

    type component GeneralComp {
	}

    function f_eval1() return integer {
        setverdict(pass);
        return 1;
    }
    
    function f_eval2() return integer {
        if (getverdict != pass) { setverdict(fail); } // if f_eval was called, the verdict would be already pass
        return 2;
    }
    
    function f_test(integer p_par1 := f_eval1(), integer p_par2, integer p_par3 := f_eval2()) {
    }

    testcase TC_Sem_050402_actual_parameters_171() runs on GeneralComp {
        f_test(p_par2 := 0); // tested feature: f_eval1 shall be called before f_eval2
	}

	control {
		execute(TC_Sem_050402_actual_parameters_171());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template in parameters can be used as in formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_096 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(in template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(3, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(in template integer p_val) runs on GeneralComp {
        a_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_096() runs on GeneralComp {
        t.start;
        f_caller(3); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_096());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that default templates are used if actual parameters are missing
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When a formal parameter has been defined with a default value or template, 
// respectively, then it is not necessary to provide an actual parameter.

module Sem_050402_actual_parameters_165 { 

    type component GeneralComp {
	}
    
    function f_test(template integer p_val := (0..5)) {
        if (match(3, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_165() runs on GeneralComp {
        f_test(-); // tested parameter passing        
	}

	control {
		execute(TC_Sem_050402_actual_parameters_165());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that function calls can be used as in formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_025 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    function f_ret() return integer {
        return 5;
    }
    
    altstep a_test(integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 5) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_025() runs on GeneralComp {
        t.start;
        a_test(f_ret()); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_025());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that variables can be used as in formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_006 { 

    type component GeneralComp {
    }
    
    function f_test(in integer p_val) {
        if (p_val == 4) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_006() runs on GeneralComp {
        var integer v_val := 4;
        f_test(v_val); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_006());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that actual parameters in the beginning of list notation can be skipped
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The actual parameter of a formal parameter with default value can be skipped by using 
// dash "-" as actual parameter.

module Sem_050402_actual_parameters_175 { 

    type component GeneralComp {
	}

    function f_test (integer p_val1 := 10, integer p_val2) {
        if (match(p_val1, 10) and match(p_val2, 2)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_175() runs on GeneralComp {
        f_test(-, 2);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_175());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template in parameters can be used as out formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.
module Sem_050402_actual_parameters_114 { 

    type component GeneralComp {
    }
    
    function f_test(out template integer p_val) {
        p_val := 0;
    }

    function f_caller(in template integer p_val) {
        f_test(p_val); // tested parameter passing
        if (match(0, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    
    testcase TC_Sem_050402_actual_parameters_114() runs on GeneralComp {
        f_caller(3); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_114());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that inout value parameters can be used as in formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_028 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 8) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(inout integer p_val) runs on GeneralComp {
        t.start;
        a_test(p_val); // tested parameter passing
    }
    
    testcase TC_Sem_050402_actual_parameters_028() runs on GeneralComp {
        var integer v_val := 8;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_028());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that constants can be used as in formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_059 { 

    type component GeneralComp {
	}	

    const integer c_val := 3;
    
    function f_test(in template integer p_val) {
        if (match(3, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_059() runs on GeneralComp {
        f_test(c_val); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_059());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that referencing rules are correctly applied to actual parameters of inout formal value parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When actual parameters that are passed to inout and out formal value or template 
// parameters contain a value or template reference, rules for using references on 
// the left hand side of assignments apply.

module Sem_050402_actual_parameters_153 { 

    type component GeneralComp {
	}
    
    type record R {
        integer field1,
        record {
            integer subfield1,
            integer subfield2
        } field2 optional
    }

    function f_test(inout integer p_val) {
        if (p_val == 2) { setverdict(pass); }
        else { setverdict(fail); }
        p_val := 10;
    }

    testcase TC_Sem_050402_actual_parameters_153() runs on GeneralComp {
        var R v_rec := {
            field1 := 1,
            field2 := {
                subfield1 := 2,
                subfield2 := 3
            }
        };
        f_test(v_rec.field2.subfield1); // tested parameter passing
        if (v_rec.field2.subfield1 == 10) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_153());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that in value parameters can be used as inout formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_046 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(inout integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 6) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(in integer p_val) runs on GeneralComp{
        t.start;
        a_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_046() runs on GeneralComp {
        f_caller(6); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_046());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template out parameters can be used as inout formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_145 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_145(inout template integer p_val) runs on GeneralComp {
        if (match(4, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}
    
    function f_caller(out template integer p_val) {
        p_val := 4; // out parameter shall have a value before we can pass it to a function
        execute(TC_Sem_050402_actual_parameters_145(p_val)); // tested parameter passing
    }

	control {
        var template integer vm_val;
        f_caller(vm_val);
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that Example 1 can be executed
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_050402_actual_parameters_193 { 

    type component GeneralComp {
	}
    
    // A function definition with a formal parameter list
    function MyFunction(integer FormalPar1, boolean FormalPar2, bitstring FormalPar3) { 
        setverdict(pass);
    }

    testcase TC_Sem_050402_actual_parameters_193() runs on GeneralComp {
        // A function call with an actual parameter list
        MyFunction(123, true,'1100'B);
        // A function call with assignment notation for actual parameters
        MyFunction(FormalPar1 := 123, FormalPar3 := '1100'B, FormalPar2 := true);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_193());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that literals can be used as in formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_085 { 

    type component GeneralComp {
        timer t := 0.0;
	}	

    altstep a_test(in template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(1, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_085() runs on GeneralComp {
        t.start;
        a_test(1); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_085());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that referencing rules are correctly applied to actual parameters of in formal template parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When actual parameters that are passed to in formal value or template parameters 
// contain a value or template reference, rules for using references on the right hand 
// side of assignments apply. 

module Sem_050402_actual_parameters_150 { 

    type component GeneralComp {
	}
    
    type record R {
        integer field1,
        record {
            integer subfield1,
            integer subfield2
        } field2 optional
    }
    
    template R mw_rec := {
        field1 := 1,
        field2 := ?
    }

    function f_test(in template integer p_val) {
        if (match(255, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_150() runs on GeneralComp {        
        f_test(mw_rec.field2.subfield1); // tested parameter passing (using referencing rules specified at 15.6.2)
	}

	control {
		execute(TC_Sem_050402_actual_parameters_150());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template parameters can be used as in formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_094 { 

    type component GeneralComp {
        timer t := 0.0;
	}	

    template integer m_msg := 1;
    
    altstep a_test(in template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(1, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_094() runs on GeneralComp {
        t.start;
        a_test(m_msg); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_094());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template in parameters can be used as out formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_126 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_126(out template integer p_val) runs on GeneralComp {
        p_val := ?;
        setverdict(pass);
	}
    
    function f_caller(in template integer p_val) {
        execute(TC_Sem_050402_actual_parameters_126(p_val)); // tested parameter passing
    }

	control {
		f_caller(3); // this parameter passing is not a subject of the test
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that compatible templates can be passed to template parameters with value restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters passed to restricted formal template parameters shall obey 
// the restrictions given in clause 15.8.

module Sem_050402_actual_parameters_186 { 

    type component GeneralComp {
	}

    function f_test (template(value) integer p_val) {
        if (match(1, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_186() runs on GeneralComp {
        f_test(1);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_186());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template in parameters can be used as in formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_068 { 

    type component GeneralComp {
    }
    
    function f_test(in template integer p_val) {
        if (match(3, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(in template integer p_val) {
        f_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_068() runs on GeneralComp {
        f_caller(3); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_068());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variable element reference can be used as out formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_123 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    type record R {
        integer field1
    }
    
    altstep a_test(out template integer p_val) runs on GeneralComp {
        []t.timeout {
            p_val := 5; 
        }
    }

    testcase TC_Sem_050402_actual_parameters_123() runs on GeneralComp {
        var template R v_val := { field1 := 10 };
        t.start;
        a_test(v_val.field1); // tested parameter passing
        if (match({ field1 := 5 }, v_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_123());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that the Example 7 can be executed
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_050402_actual_parameters_201 { 

    type component GeneralComp {
        var integer v_id;
        port MyPortType P;
    }
    
    type record MyMessage { integer id, float number }
    type port MyPortType message { inout MyMessage }

    function sendLazy(@lazy MyMessage pdu) runs on GeneralComp {
        for (v_id := 1; v_id<9; v_id:=v_id+1){
        P.send(pdu); // the actual parameter passed to the formal parameter pdu is evaluated only in
        // the first loop;let say rnd() returns 0.924946; the message { 1, 0.924946 } is
        // sent out 8 times
        }
        setverdict(pass,"messages has been sent out")
    }
    function sendFuzzy(@fuzzy MyMessage pdu) runs on GeneralComp {
        for (v_id := 1; v_id<9; v_id:=v_id+1){
        P.send(pdu); // the actual parameter passed to the formal parameter pdu is evaluated in each
        // loop; let say rnd() returns 0.924946, 0.680497, 0.630836, 0.648681, 0.428501,
        // 0.262539, 0.646990, 0.265262 in subsuent calls; the messages 1, 0.924946 },
        // {{ 2, 0.680497 }, { 3, 0.630836 }, { 4, 0.648681 }, { 5, 0.428501 },
        // { 6, 0.262539 }, { 7, 0.646990 } and { 8, 0.265262 } are sent out in sequence
    }
    setverdict(pass,"messages has been sent out")
    }

    testcase TC_Sem_050402_actual_parameters_201() runs on GeneralComp system GeneralComp {
        connect(self:P,self:P);
        sendLazy({v_id, rnd()}); //note that at this point v_id is unintialized yet
        sendFuzzy({v_id, rnd()})
	}

	control {
		execute(TC_Sem_050402_actual_parameters_201());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variable element reference can be used as inout formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_147 { 

    type component GeneralComp {
    }
    
    type record R {
        integer field1
    }

    testcase TC_Sem_050402_actual_parameters_147(inout template(present) integer p_val) runs on GeneralComp {
        if (match(10, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
        var template R v_val := { field1 := 10 };
		execute(TC_Sem_050402_actual_parameters_147(v_val.field1)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template out parameters can be used as in formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_097 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(in template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(4, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(out template integer p_val) runs on GeneralComp {
        p_val := 4; // out parameter shall have a value before we can pass it to a function
        a_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_097() runs on GeneralComp {
        var template integer v_val;
        t.start;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_097());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that actual parameter values override default values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The actual parameter of a formal parameter with default value can be skipped by using 
// dash "-" as actual parameter.

module Sem_050402_actual_parameters_174 { 

    type component GeneralComp {
	}

    function f_test (integer p_val := 10) {
        if (p_val != 10) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_174() runs on GeneralComp {
        f_test(0);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_174());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variables can be used as inout formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_137 { 

    type component GeneralComp {
        timer t := 0.0;
	}
    
    altstep a_test(inout template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(2, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_137() runs on GeneralComp {
        var template integer vm_msg := 2;
        t.start;
        a_test(vm_msg); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_137());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that inout value parameters can be used as in formal template parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_078 { 

    type component GeneralComp {
    }
    
    template integer m_test(in template integer p_val) := 11 + valueof(p_val);

    function f_caller(inout integer p_val) {
        if (match(19, m_test(p_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }
    
    testcase TC_Sem_050402_actual_parameters_078() runs on GeneralComp {
        var integer v_val := 8;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_078());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that the first part of the Example 3 can be executed
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_050402_actual_parameters_197 { 

    type component GeneralComp {
	}
    
    function MyFunction(inout boolean MyReferenceParameter)  { 
        // MyReferenceParameter is an inout parameter
        setverdict(pass);
    }

    testcase TC_Sem_050402_actual_parameters_197() runs on GeneralComp {
        var boolean MyBooleanVariable := false;
        // A function call with an actual parameter
        MyFunction(MyBooleanVariable);
        // The actual parameter can be read and set within the function
	}

	control {
		execute(TC_Sem_050402_actual_parameters_197());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that module parameters can be used as in formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_004 { 

    type component GeneralComp {
	}	

    modulepar integer PX_VAL := 2;
    
    function f_test(in integer p_val) {
        if (p_val == 2) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_004() runs on GeneralComp {
        f_test(PX_VAL); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_004());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variables can be used as in formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_095 { 

    type component GeneralComp {
        timer t := 0.0;
	}
    
    altstep a_test(in template integer p_val) runs on GeneralComp {
        []t.timeout {
            if (match(2, p_val)) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_095() runs on GeneralComp {
        var template integer vm_msg := 2;
        t.start;
        a_test(vm_msg); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_095());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that out value parameters can be used as inout formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_041 { 

    type component GeneralComp {
    }
    
    function f_test(inout integer p_val) {
        if (p_val == 7) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(out integer p_val) {
        p_val := 7; // out parameter shall have a value before we can pass it to a function
        f_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_041() runs on GeneralComp {
        var integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_041());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template inout parameters can be used as out formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_128 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_128(out template integer p_val) runs on GeneralComp {
        p_val := ?;
        setverdict(pass);
	}

    function f_caller(inout template integer p_val) {
        execute(TC_Sem_050402_actual_parameters_128(p_val)); // tested parameter passing
    }

	control {
        var template integer vm_val := 5;
		f_caller(vm_val);
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that literals can be used as in formal value parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_012 { 

    type component GeneralComp {
	}	

    template integer m_test(in integer p_val) := 11 + p_val;

    testcase TC_Sem_050402_actual_parameters_012() runs on GeneralComp {
        if (match(12, m_test(1))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_012());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template inout parameters can be used as inout formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_134 { 

    type component GeneralComp {
    }
    
    function f_test(inout template integer p_val) {
        if (match(5, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(inout template integer p_val) {
        f_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_134() runs on GeneralComp {
        var template integer v_val := 5;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_134());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that the third part of the Example 3 can be executed
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_050402_actual_parameters_196 { 

    type component GeneralComp {
	}
    
    type record of integer RoI;
    
    function f_swapElements (inout integer p_int1, inout integer p_int2) {
        var integer v_tmp := p_int1;
        p_int1 := p_int2;
        p_int2 := v_tmp;
    }

    testcase TC_Sem_050402_actual_parameters_196() runs on GeneralComp {
        var RoI v_roi := { 0, 1, 2, 3, 4, 5 };
        f_swapElements(v_roi[0], v_roi[5]); // after the function call, v_roi is { 5, 1, 2, 3, 4, 0 }
        if (v_roi == { 5, 1, 2, 3, 4, 0 }) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_196());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that partially initialized values can be passed to inout formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Unless specified differently in the relevant clause(s), actual parameters 
// passed to in or inout formal parameters shall be at least partially 
// initialized (for an exemption see e.g. clause 16.1.2 of the present document).

module Sem_050402_actual_parameters_192 { 

    type component GeneralComp {
	}
    
    type record R {
        integer field1,
        integer field2 optional
    }

    function f_test (inout R p_val) {
        if (match(p_val.field1, 1) and not isbound(p_val.field2)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_192() runs on GeneralComp {
        var R v_rec;
        v_rec.field1 := 1;
        f_test(v_rec);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_192());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that component ports can be passed to port parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to formal port parameters shall be component 
// ports or formal port parameters of the current scope.

module Sem_050402_actual_parameters_160 { 

    type port IntPort message {
        inout integer;
    }
    
    type component GeneralComp {
        port IntPort p;
	}
    
    function f_test(IntPort p_port) {
        p_port.stop;
    }

    testcase TC_Sem_050402_actual_parameters_160() runs on GeneralComp {
        f_test(p); // tested parameter passing
        if (p.checkstate("Stopped")) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_160());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that inout value parameters can be used as inout formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_048 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    altstep a_test(inout integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 8) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    function f_caller(inout integer p_val) runs on GeneralComp {
        t.start;
        a_test(p_val); // tested parameter passing
    }
    
    testcase TC_Sem_050402_actual_parameters_048() runs on GeneralComp {
        var integer v_val := 8;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_048());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that expressions can be used as in formal template parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_079 { 

    type component GeneralComp {
	}	
    
    function f_ret() return integer {
        return 4;
    }

    template integer m_test(in template integer p_val) := 11 + valueof(p_val);

    testcase TC_Sem_050402_actual_parameters_079() runs on GeneralComp {
        var integer v_val := 5;
        if (match(20, m_test(10 + f_ret() - v_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_079());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that actual parameters override default values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When a formal parameter has been defined with a default value or template, 
// respectively, then it is not necessary to provide an actual parameter.

module Sem_050402_actual_parameters_162 { 

    type component GeneralComp {
	}
    
    function f_test(integer p_val := 5) {
        if (p_val != 5) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_162() runs on GeneralComp {
        f_test(0); // tested parameter passing        
	}

	control {
		execute(TC_Sem_050402_actual_parameters_162());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that constants can be used as in formal template parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_073 { 

    type component GeneralComp {
	}	

    const integer c_val := 3;
    
    template integer m_test(in template integer p_val) := 11 + valueof(p_val);

    testcase TC_Sem_050402_actual_parameters_073() runs on GeneralComp {
        if (match(14, m_test(c_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_073());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that expressions can be used as in formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_029 { 

    type component GeneralComp {
        timer t := 0.0;
    }
    
    function f_ret() return integer {
        return 4;
    }
    
    altstep a_test(integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 9) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }
    
    testcase TC_Sem_050402_actual_parameters_029() runs on GeneralComp {
        var integer v_val := 5;
        t.start;
        a_test(10 + f_ret() - v_val); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_029());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that compatible values can be passed from out formal parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The type of each actual parameter shall be compatible with the type of each 
// corresponding formal parameter.

module Sem_050402_actual_parameters_184 { 

    type component GeneralComp {
	}
    
    type record R1 {
        integer field1,
        integer field2 optional
    }
    
    type record R2 {
        integer elem1,
        integer elem2 optional
    }

    function f_test (out R1 p_val) {
        p_val.field1 := 1;
        p_val.field2 := 2;
    }

    testcase TC_Sem_050402_actual_parameters_184() runs on GeneralComp {
        var R2 v_rec;
        f_test(v_rec);
        if (v_rec == { elem1 := 1, elem2 := 2 }) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_184());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that out value parameters can be used as in formal value parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_018 { 

    type component GeneralComp {
    }
    
    template integer m_test(in integer p_val) := 11 + p_val;

    function f_caller(out integer p_val) {
        p_val := 7; // out parameter shall have a value before we can pass it to a function
        if (match(18, m_test(p_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    
    testcase TC_Sem_050402_actual_parameters_018() runs on GeneralComp {
        var integer v_val;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_018());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that out formal parameters are passed to actual parameter in correct (list notation)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The values of out formal parameters are passed to the actual parameters in the same 
// order as is the order of formal parameters in the definition of the parameterized 
// TTCN-3 object.

module Sem_050402_actual_parameters_155 { 

    type component GeneralComp {
	}
    
    function f_test(out integer p_val1, out integer p_val2, out integer p_val3) {
        p_val1 := 1;
        p_val2 := 2;
        p_val3 := 3;
    }

    testcase TC_Sem_050402_actual_parameters_155() runs on GeneralComp {
        var integer v_val;
        f_test(v_val, v_val, v_val); // tested parameter passing
        if (v_val == 3) { setverdict(pass); }
        else { setverdict(fail); }

	}

	control {
		execute(TC_Sem_050402_actual_parameters_155());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that module parameters can be used as in formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_031 { 

    type component GeneralComp {
	}	

    modulepar integer PX_VAL := 2;    

    testcase TC_Sem_050402_actual_parameters_031(in integer p_val) runs on GeneralComp {
        if (p_val == 2) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_031(PX_VAL)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template in parameters can be used as in formal template parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_082 { 

    type component GeneralComp {
    }
    
    template integer m_test(in template integer p_val) := 5 + valueof(p_val);

    function f_caller(in template integer p_val) {
        if (match(8, m_test(p_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    
    testcase TC_Sem_050402_actual_parameters_082() runs on GeneralComp {
        f_caller(3); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_082());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template inout parameters can be used as inout formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal template parameters shall be variables, 
// template variables, formal value or template parameters (of in, inout or out 
// parameterization) of the current scope or references to elements of (template) variables 
// or formal (template) parameters of structured types.

module Sem_050402_actual_parameters_146 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_146(inout template integer p_val) runs on GeneralComp {
        if (match(5, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

    function f_caller(inout template integer p_val) {
        execute(TC_Sem_050402_actual_parameters_146(p_val)); // tested parameter passing
    }

	control {
        var template integer vm_val := 5;
		f_caller(vm_val);
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that assignment notation can omit parameters with default value
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// In order to use the default value of a formal parameter, no assignment for this 
// specific parameter shall be provided.

module Sem_050402_actual_parameters_182 { 

    type component GeneralComp {
	}

    function f_test (integer p_val1 := 10, charstring p_val2, integer p_val3) {
        if ( match(p_val1, 10) and match(p_val2, "test") and match(p_val3, 3)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_182() runs on GeneralComp {
        f_test(p_val2 := "test", p_val3 := 3);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_182());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template variables can be used as out formal template parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to out formal template parameters shall be variables, 
// template variables, formal value parameters, formal template parameters or references 
// to elements of variables, template variables, formal value parameters or formal template 
// parameters of structured types.

module Sem_050402_actual_parameters_119 { 

    type component GeneralComp {
        timer t := 0.0;
	}
    
    altstep a_test(out template integer p_val) runs on GeneralComp {
        []t.timeout {
            p_val := 0;
        }
    }

    testcase TC_Sem_050402_actual_parameters_119() runs on GeneralComp {
        var template integer vm_msg := 2;
        t.start;
        a_test(vm_msg); // tested parameter passing
        if (match(0, vm_msg)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_119());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that missing actual parameters at the end of list notation are considered to be skipped (single parameter)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// An actual parameter can also be skipped by just leaving it out if no other actual 
// parameter follows in the actual parameter list - either because the parameter is 
// last or because all following formal parameters have default values and are left out.

module Sem_050402_actual_parameters_178 { 

    type component GeneralComp {
	}

    function f_test (integer p_val1, integer p_val2 := 20) {
        if (match(p_val1, 1) and match(p_val2, 20)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_178() runs on GeneralComp {
        f_test(1);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_178());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that function calls can be used as in formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_061 { 

    type component GeneralComp {
    }
    
    function f_ret() return integer {
        return 5;
    }
    
    function f_test(in template integer p_val) {
        if (match(5, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_061() runs on GeneralComp {
        f_test(f_ret()); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_061());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template in parameters can be used as in formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_110 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_110(in template integer p_val) runs on GeneralComp {
        if (match(3, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}
    
    function f_caller(in template integer p_val) {
        execute(TC_Sem_050402_actual_parameters_110(p_val)); // tested parameter passing
    }

	control {
		f_caller(3); // this parameter passing is not a subject of the test
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that variables can be used as in formal value parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_015 { 

    type component GeneralComp {
    }
    
    template integer m_test(in integer p_val) := 11 + p_val;

    testcase TC_Sem_050402_actual_parameters_015() runs on GeneralComp {
        var integer v_val := 4;
        if (match(15, m_test(v_val))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_015());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template parameters can be used as in formal template parameters of templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_080 { 

    type component GeneralComp {
	}	

    template integer m_msg := 1;
    
    template integer m_test(in template integer p_val) := 5 + valueof(p_val);

    testcase TC_Sem_050402_actual_parameters_080() runs on GeneralComp {
        if (match(6, m_test(m_msg))) { // tested parameter passing
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}

	control {
		execute(TC_Sem_050402_actual_parameters_080());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that variables can be used as in formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_102 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_102(in template integer p_val) runs on GeneralComp {
        if (match(4, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control {
        var integer v_val := 4;
		execute(TC_Sem_050402_actual_parameters_102(v_val)); // tested parameter passing
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that template inout parameters can be used as in formal template parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_070 { 

    type component GeneralComp {
    }
    
    function f_test(in template integer p_val) {
        if (match(5, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    function f_caller(inout template integer p_val) {
        f_test(p_val); // tested parameter passing
    }

    
    testcase TC_Sem_050402_actual_parameters_070() runs on GeneralComp {
        var template integer v_val := 5;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}

	control {
		execute(TC_Sem_050402_actual_parameters_070());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that module parameters can be used as in formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_022 { 

    type component GeneralComp {
        timer t := 0.0;
	}	

    modulepar integer PX_VAL := 2;
    
    altstep a_test(integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 2) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_022() runs on GeneralComp {
        t.start;
        a_test(PX_VAL); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_022());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that inout value parameters can be used as inout formal value parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to inout formal value parameters shall be variables 
// or formal value parameters (of in, inout or out parameterization) or references to 
// elements of variables or formal value parameters of structured types.

module Sem_050402_actual_parameters_054 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_054(inout integer p_val) runs on GeneralComp {
        if (p_val == 8) { setverdict(pass); }
        else { setverdict(fail); }
	}

    function f_caller(inout integer p_val) {
        execute(TC_Sem_050402_actual_parameters_054(p_val)); // tested parameter passing
    }

	control {
        var integer v_val := 8;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that assignment notation containing all parameters in declaration order is accepted
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For each formal parameter without default value, there shall be an actual parameter.

module Sem_050402_actual_parameters_180 { 

    type component GeneralComp {
	}

    function f_test (integer p_val1, charstring p_val2, integer p_val3) {
        if ( match(p_val1, 1) and match(p_val2, "test") and match(p_val3, 3)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_180() runs on GeneralComp {
        f_test(p_val1 := 1, p_val2 := "test", p_val3 := 3);
	}

	control {
		execute(TC_Sem_050402_actual_parameters_180());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that compatible templates can be passed to template parameters with present restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters passed to restricted formal template parameters shall obey 
// the restrictions given in clause 15.8.

module Sem_050402_actual_parameters_187 { 

    type component GeneralComp {
	}

    function f_test (template(present) integer p_val) {
        if (match(1, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_187() runs on GeneralComp {
        f_test((0..10));
	}

	control {
		execute(TC_Sem_050402_actual_parameters_187());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that actual parameters override default templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When a formal parameter has been defined with a default value or template, 
// respectively, then it is not necessary to provide an actual parameter.

module Sem_050402_actual_parameters_164 { 

    type component GeneralComp {
	}
    
    function f_test(template integer p_val := (0..5)) {
        if (match(10, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_164() runs on GeneralComp {
        f_test(?); // tested parameter passing        
	}

	control {
		execute(TC_Sem_050402_actual_parameters_164());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that assignment notation containing all parameters in random order is accepted
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For each formal parameter without default value, there shall be an actual parameter.

module Sem_050402_actual_parameters_181 { 

    type component GeneralComp {
	}

    function f_test (integer p_val1, charstring p_val2, integer p_val3) {
        if ( match(p_val1, 1) and match(p_val2, "test") and match(p_val3, 3)) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_181() runs on GeneralComp {
        f_test(p_val3 := 3, p_val1 := 1, p_val2 := "test");
	}

	control {
		execute(TC_Sem_050402_actual_parameters_181());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that inout value parameters can be used as in formal template parameters of test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed to in formal template parameters shall be literal 
// values, module parameters, constants, variables, value or template returning (external)
// functions, formal value parameters (of in, inout or out parameterization) of the current 
// scope or expressions composed of the above, as well as templates, template variables or 
// formal template parameters (of in, inout or out parameterization) of the current scope.

module Sem_050402_actual_parameters_106 { 

    type component GeneralComp {
    }
    
    testcase TC_Sem_050402_actual_parameters_106(in template integer p_val) runs on GeneralComp {
        if (match(8, p_val)) { setverdict(pass); }
        else { setverdict(fail); }
	}

    function f_caller(inout integer p_val) {
        execute(TC_Sem_050402_actual_parameters_106(p_val)); // tested parameter passing
    }

	control {
        var integer v_val := 8;
        f_caller(v_val); // this parameter passing is not a subject of the test
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that actual parameters are evaluated in order of their appearance (assignment notation)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The actual parameters are evaluated in the order of their appearance.

module Sem_050402_actual_parameters_167 { 

    type component GeneralComp {
        var integer vc_counter := 0;
	}

    function f_eval1() runs on GeneralComp return integer {
        log("f_eval1");
        if (vc_counter == 0) 
        { 
            setverdict(pass); 
            vc_counter := vc_counter + 1;
        }
        else { setverdict(fail); }
        return vc_counter;
    }
    
    function f_eval2() runs on GeneralComp return integer {
        log("f_eval2");
        if (vc_counter == 1) 
        { 
            setverdict(pass); 
            vc_counter := vc_counter + 1;
        }
        else { setverdict(fail); }
        return vc_counter;
    }
    
    function f_test(integer p_par1, integer p_par2) {        
    }

    testcase TC_Sem_050402_actual_parameters_167() runs on GeneralComp {
        f_test(p_par2 := f_eval1(), p_par1 := f_eval2()); // tested feature: f_eval1 shall be called before f_eval2
	}

	control {
		execute(TC_Sem_050402_actual_parameters_167());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that literals can be used as in formal value parameters of functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_003 { 

    type component GeneralComp {
	}	

    function f_test(in integer p_val) {
        if (p_val == 1) { setverdict(pass); }
        else { setverdict(fail); }
    }

    testcase TC_Sem_050402_actual_parameters_003() runs on GeneralComp {
        f_test(1); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_003());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:5.4.2, verify that constants can be used as in formal value parameters of altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Actual parameters that are passed by value to in formal value parameters shall be 
// variables, literal values, module parameters, constants, variables, value returning 
// (external) functions, formal value parameters (of in, inout or out parameterization) 
// of the current scope or expressions composed of the above.

module Sem_050402_actual_parameters_023 { 

    type component GeneralComp {
        timer t := 0.0;
	}	

    const integer c_val := 3;
    
    altstep a_test(integer p_val) runs on GeneralComp {
        []t.timeout {
            if (p_val == 3) { setverdict(pass); }
            else { setverdict(fail); }
        }
    }

    testcase TC_Sem_050402_actual_parameters_023() runs on GeneralComp {
        t.start;
        a_test(c_val); // tested parameter passing
	}

	control {
		execute(TC_Sem_050402_actual_parameters_023());
	}
}
/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:5.2, Ensure that the IUT handle scope hieararchy of component constants.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0502_Scope_001 {

type component GeneralComp {	    	    
    const integer cl_int := 0;
}	

testcase TC_Sem_0502_Scope_001() runs on GeneralComp {
    if ( match(cl_int, 0) ){
		setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}	

control{  
    execute(TC_Sem_0502_Scope_001());
}
}
/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:5.2, Ensure that the IUT correctly handles the scope of definitions made in the module part.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0502_Scope_004 {

    const integer c_int := 0;

type component GeneralComp {	    	    
}	

testcase TC_Sem_0502_Scope_004() runs on GeneralComp {
    if (c_int == 0){
		setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}	

control{  
    execute(TC_Sem_0502_Scope_004());
}
}


module Sem_0502_Scope_004_import {

import from Sem_0502_Scope_004 {
 const all
}

type component GeneralComp {	    	    
}	

testcase TC_Sem_0502_Scope_004_import() runs on GeneralComp {
    if (c_int == 0){
		setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}	

control{  
    execute(TC_Sem_0502_Scope_004_import());
}
}


/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:5.2, Ensure that the IUT handles scope hierarchy via functions.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0502_Scope_003 {

type component GeneralComp {	    	    
    var integer vc_int := 0;
}	

function f_funcScope() runs on GeneralComp {	    
    vc_int := 1;                          
    if (vc_int == 1){
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}		

testcase TC_Sem_0502_Scope_003_a() runs on GeneralComp {
    f_funcScope();
}

testcase TC_Sem_0502_Scope_003_b() runs on GeneralComp {
    f_funcScope();
    if (vc_int == 1){
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}

control{
    execute(TC_Sem_0502_Scope_003_a());
    execute(TC_Sem_0502_Scope_003_b());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @desc     Test cases for clause 5.2 Scope rules                     
 ** @purpose  1:5.2, Ensure that the IUT correctly handles definitions of extended component scope
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0502_Scope_008 {

type component GeneralComp {	    	    
    var integer vc_component := 1;
}	

type component ExtendedComp extends GeneralComp {	    	    
}	


testcase TC_Sem_0502_Scope_008() runs on ExtendedComp {
    if (vc_component == 1) {
	setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}

control{
    execute(TC_Sem_0502_Scope_008());
}

}
/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:5.2, Ensure that the IUT supports all the nine scope units.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Syn_0502_Scope_001 {

const integer c_intModule := 0;          // scope a) module definitions part 
type integer IntegerMod;

type component GeneralComp {	    	    
    const integer cl_int := 0;
    var integer vc_int := 0;
    var boolean vc_bool := false;
    timer tc_timer := 0.1;                // scope c) component types
}	

testcase TC_Syn_0502_Scope_001() runs on GeneralComp {  // scope f) test cases
    f_funcScope();
    tc_timer.start;                       
    a_altstepScope();
    if (c_intModule == 0){
		setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
    if (cl_int == 0){
		setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}	

group recordGroup {                       // scope g) statement block
    type record RecScope {                // scope i) user defined named types
      IntegerMod field1,         
      boolean field2
    }
}

group templateGroup {
    template RecScope m_scope := {  // scope h) templates
      field1 := 0,
      field2 := true
    }
}
  
function f_funcScope() runs on GeneralComp {	    
    vc_int := 1;                          // scope d) functions
    if (vc_int == 1){
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}		

altstep a_altstepScope() runs on GeneralComp {
    var integer v_intAltStep := 2;           // scope e) altsteps
    []tc_timer.timeout{
        if (v_intAltStep == 2) {
            setverdict(pass);
        } else {
            setverdict(fail)
        }
    }
}
		

control{
    var integer v_intControl := 0;       // scope b) control part of a module
  
    execute(TC_Syn_0502_Scope_001());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:5.2, Ensure that the IUT handle scope hieararchy with component booleans.  
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0502_Scope_002 {

type component GeneralComp {	    	    
    var boolean vc_bool := false;
}	

testcase TC_Sem_0502_Scope_002_a() runs on GeneralComp {
    if (vc_bool == false){
		vc_bool := true;
		setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}
/*********************************************************************************************
 ** @desc  Test case TC_Sem_0502_Scope_002_a shall not effect of the value of boolean vc_bool
 ********************************************************************************************/
testcase TC_Sem_0502_Scope_002_b() runs on GeneralComp {	    
    if (vc_bool == false){
		setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}

control{  
    execute(TC_Sem_0502_Scope_002_a());
    execute(TC_Sem_0502_Scope_002_b());
}

}
/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @desc     Test cases for clause 5.2 Scope rules                     
 ** @purpose  1:5.2.1, Ensure that the IUT correctly handles scope of formal function parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_050201_Scope_of_parameters_002 {

type component GeneralComp {	    	    
}


function f_formalParameterScope_inout(inout integer p_myParameter) {
 p_myParameter := 1;
}



testcase TC_Sem_050201_Scope_of_parameters_002()  runs on GeneralComp  {

    var integer v_int := 0;
    f_formalParameterScope_inout(v_int);

    if (v_int == 1) {
	setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}


control{
    execute(TC_Sem_050201_Scope_of_parameters_002());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.2
 ** @desc     Test cases for clause 5.2 Scope rules                     
 ** @purpose  1:5.2.1, Ensure that the IUT correctly handles scope of formal function parameters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_050201_Scope_of_parameters_001 {

type component GeneralComp {	    	    
}

function f_formalParameterScope_in(in integer p_myParameter) {
 p_myParameter := 1;
    if (p_myParameter == 1){
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}


testcase TC_Sem_050201_Scope_of_parameters_001()  runs on GeneralComp  {

    var integer v_int := 0;
    f_formalParameterScope_in(v_int);

    if (v_int == 0) {
	setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}


control{
    execute(TC_Sem_050201_Scope_of_parameters_001());
   
}

}
/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:5.2.2, Ensure that the IUT correctly handles the uniqueness of variable names in its scope
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_050202_Uniqueness_003 {
	type component GeneralComp {
	}

	function f_funcScope() {
		const integer cl_int := 0;
	}

	testcase TC_Sem_050202_Uniqueness_003() runs on GeneralComp {
		const integer cl_int := 1;
		f_funcScope();
		if (cl_int == 1) { // local value
			setverdict(pass);
		} else {
		    setverdict(fail);
		}
	}
	control {
		execute(TC_Sem_050202_Uniqueness_003());
	}
}
/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:5.2.2, Ensure that the IUT correctly handles the uniqueness of variable names in its scope
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_050202_Uniqueness_002 {
	type component GeneralComp {
		const integer cl_int := 0;
	}

	function f_funcScope() {
		const integer cl_int := 1;
	}

	testcase TC_Sem_050202_Uniqueness_002() runs on GeneralComp {
		f_funcScope();
        if (cl_int == 0) { // component value
            setverdict(pass);
        } else {
            setverdict(fail);
        }
	}
	control {
		execute(TC_Sem_050202_Uniqueness_002());
	}
}
module Sem_050202_Uniqueness_001_import {
    const integer repeatedIdentifier := 0; 	  // repeated indentifier from imported module is allowed 
}
 
/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:5.2.2, Ensure that the IUT correctly handles the uniqueness of variable names in its scope
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_050202_Uniqueness_001 {
	import from Sem_050202_Uniqueness_001_import {
	    const all;
	}

	type component GeneralComp {
	}

	function f_funcScope() {
		var boolean repeatedIdentifier := true;

		if(repeatedIdentifier==true) { setverdict(pass); }
	}

	testcase TC_Sem_050202_Uniqueness_001() runs on GeneralComp {
		f_funcScope();
	}
	control {
		execute(TC_Sem_050202_Uniqueness_001());
	}
}

/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26.1, Ensure that the verdict pass works correctly.
 ** @verdict  pass accept, ttcn3verdict:fail
 *****************************************************************/

module Sem_2601_ExecuteStatement_005 {

type component GeneralComp { }

testcase TC_Sem_2601_ExecuteStatement_005() runs on GeneralComp {
	setverdict(pass);
}

testcase TC_Sem_2601_ExecuteStatement_005_second(verdicttype p_verdict) runs on GeneralComp {
	if (p_verdict == pass) {
		setverdict(fail);
	} else {
		setverdict(pass);
	}
}

control {
	var verdicttype v_result;
	
	v_result := execute(TC_Sem_2601_ExecuteStatement_005());
	execute(TC_Sem_2601_ExecuteStatement_005_second(v_result));
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26.1, Ensure that the verdict none works correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2601_ExecuteStatement_004 {

type component GeneralComp { }

testcase TC_Sem_2601_ExecuteStatement_004() runs on GeneralComp {
	setverdict(none);
}

testcase TC_Sem_2601_ExecuteStatement_004_second(verdicttype p_verdict) runs on GeneralComp {
	if (p_verdict == none) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control {
	var verdicttype v_result;
	
	v_result := execute(TC_Sem_2601_ExecuteStatement_004());
	execute(TC_Sem_2601_ExecuteStatement_004_second(v_result));
}

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:26.1, Ensure that host id restriction is correctly handled.
 ** @verdict  pass accept, ttcn3verdict:error
 *****************************************************************/

module Sem_2601_ExecuteStatement_009 {

    type component GeneralComp { }

    testcase TC_Sem_2601_ExecuteStatement_009(integer p_value, charstring p_string, boolean p_bool) runs on GeneralComp {
        setverdict(pass);
    }

    control {
        var integer v_test := 20;
        execute(TC_Sem_2601_ExecuteStatement_009(v_test, "hello", true), -, "wrong_host4232432432432432432432432432");
    }

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26.1, Ensure that the user error sets the verdict error correctly.
 ** @verdict  pass accept, ttcn3verdict:error
 *****************************************************************/

module Sem_2601_ExecuteStatement_008 {

    type component GeneralComp { }

    testcase TC_Sem_2601_ExecuteStatement_008() runs on GeneralComp {
        testcase.stop("User error!");
    }

    control {
        var verdicttype v_result;
	
        execute(TC_Sem_2601_ExecuteStatement_008());
    }

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26.1, Ensure that the verdict inconc works correctly.
 ** @verdict  pass accept, ttcn3verdict:inconc
 *****************************************************************/

module Sem_2601_ExecuteStatement_006 {

type component GeneralComp { }

testcase TC_Sem_2601_ExecuteStatement_006() runs on GeneralComp {
	setverdict(inconc);
}

testcase TC_Sem_2601_ExecuteStatement_006_second(verdicttype p_verdict) runs on GeneralComp {
	if (p_verdict == inconc) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control {
	var verdicttype v_result;
	
	v_result := execute(TC_Sem_2601_ExecuteStatement_006());
	execute(TC_Sem_2601_ExecuteStatement_006_second(v_result));
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26.1, Ensure that parameters are passed correctly into the test case.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2601_ExecuteStatement_001 {

type component GeneralComp { }

testcase TC_Sem_2601_ExecuteStatement_001(integer p_value) runs on GeneralComp {
	if (p_value == 20) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control {
	var integer v_test := 20;
	execute(TC_Sem_2601_ExecuteStatement_001(v_test));
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26.1, Ensure that the timeout specified with the execute statement is respected.
 ** @verdict  pass accept, ttcn3verdict:error
 *****************************************************************/

module Sem_2601_ExecuteStatement_007 {

    type component GeneralComp { }

    testcase TC_Sem_2601_ExecuteStatement_007() runs on GeneralComp {
        while(true) {
        // infinite loop
        }
        setverdict(pass);
    }

    control {
        execute(TC_Sem_2601_ExecuteStatement_007(), 2.0); // let the testcase execution timeout after 2 seconds
    }

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26.1, Ensure that multiple parameters of different types are passed correctly into the test case.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2601_ExecuteStatement_002 {

type component GeneralComp { }

testcase TC_Sem_2601_ExecuteStatement_002(integer p_value, charstring p_string, boolean p_bool) runs on GeneralComp {
	if (match(p_value, 20) and
	    match(p_string, "hello") and
	    match(p_bool, true) 
	   ){
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control {
	var integer v_test := 20;
	execute(TC_Sem_2601_ExecuteStatement_002(v_test, "hello", true));
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26.1, Ensure that the timeout specified with the execute statement is respected.
 ** @verdict  pass accept, ttcn3verdict:error
 *****************************************************************/

module Sem_2601_ExecuteStatement_003 {

type component GeneralComp { }

testcase TC_Sem_2601_ExecuteStatement_003() runs on GeneralComp {
	alt { // this alt is intentionally blocking!
		[] any port.receive {
			repeat;
		}
	}
	setverdict(pass);
}

control {
	execute(TC_Sem_2601_ExecuteStatement_003(), 2.0); // let the testcase timeout after 2 seconds
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that for loop constructs in the control part are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_004 {

control{
	for (var integer v_i:=0; v_i < 10; v_i := v_i + 1) {
		// do something
	}
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that the alt/timeout construct in the control part is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_011 {

control{
	timer t_timer;
	t_timer.start(20E-3);
	alt {
		[] t_timer.timeout {
			// do something
		}
	}
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that assignments in the control part are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_001 {

control{
	var integer v_foo := 2;
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that the continue construct in the control part is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_010 {

control{
	log("Hello World");
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that the interleave construct in the control part is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_013 {

control{
	timer t_timerOne;
	timer t_timerTwo;
	t_timerOne.start(20E-3);
	t_timerTwo.start(30E-3);
	interleave {
		[] t_timerOne.timeout {
		}
		[] t_timerTwo.timeout {
		}
	}
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that the repeat construct in the control part is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_012 {

control{
	timer t_timer;
	t_timer.start(20E-3);
	alt {
		[] t_timer.timeout {
			repeat;
		}
	}
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that the execute construct in the control part is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_017 {

type component GeneralComp { }

testcase t_myTestCase() runs on GeneralComp {
}

control{
	execute(t_myTestCase());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that label and goto constructs in the control part are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_006 {

control{
	var integer v_i:=0;
label loop;
	v_i := v_i + 1;
	if (v_i > 10) {
		goto end;
	}
	goto loop;
label end;
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that if-else constructs in the control part are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_002 {

control{
	if (1 == 1) {
		// do something
	} else {
		// do something else
	}	
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that the break construct in the control part is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_008 {

control{
	for (var integer v_i:=0; v_i < 10; v_i := v_i + 1) {
		break;
	}
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that start/stop/read/running timer constructs in the control part are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_015 {

type component GeneralComp { }

altstep a_test(timer p_timer) runs on GeneralComp {
	[] p_timer.timeout {
	}
}

control{
	timer t_timer;
	var float v_value;
	t_timer.start(20E-3);
	v_value := t_timer.read;
	if (t_timer.running) {
		// do something
	}
	
	t_timer.stop;
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that the continue construct in the control part is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_009 {

control{
	for (var integer v_i:=0; v_i < 10; v_i := v_i + 1) {
		continue;
	}
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that while loop constructs in the control part are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_005 {

control{
	var integer v_i:=0;
	while (v_i < 10) {
		v_i := v_i + 1;
	}
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that the stop construct in the control part is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_007 {

control{
	stop;
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that the action construct in the control part is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_016 {

control{
	action("Send template on lower PCO now!");
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26, Ensure that select-case constructs in the control part are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_26_ModuleControl_003 {

control{
	var integer v_test := 1;
	select(v_test) {
		case(1) {
			// do something
		}
		case(2) {
			// do something else
		}
		case else {
			// do something else
		}
	}
}

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that the selection/deselection of test cases using boolean conditions works as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2602_TheControlPart_001 {

    type component GeneralComp { }

    testcase TC_Sem_2602_TheControlPart_001() runs on GeneralComp {
        setverdict(fail);
    }

    testcase TC_Sem_2602_TheControlPart_001_second() runs on GeneralComp {
        setverdict(pass);
    }

    control {
        if (false) {
            execute(TC_Sem_2602_TheControlPart_001());
        }
	
        if (true) {
            execute(TC_Sem_2602_TheControlPart_001_second());
        }

        if (not(1 == 1)) {
            execute(TC_Sem_2602_TheControlPart_001());
        }
    }

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that the execution of test cases works from within a function.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2602_TheControlPart_002 {

    type component GeneralComp { }

    testcase TC_Sem_2602_TheControlPart_002() runs on GeneralComp {
        setverdict(pass);
    }

    function f_testCaseExecutionFunction() {
        execute(TC_Sem_2602_TheControlPart_002());
    }

    control {
        f_testCaseExecutionFunction();
    }

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:26.2, Ensure that the selection of test cases can be achieven based on resulting verdict types.
 ** @verdict  pass accept, ttcn3verdict:fail
 *****************************************************************/

module Sem_2602_TheControlPart_003 {

    type component GeneralComp { }

    testcase TC_Sem_2602_TheControlPart_003() runs on GeneralComp {
        setverdict(pass);
    }

    testcase TC_Sem_2602_TheControlPart_003_second() runs on GeneralComp {
        setverdict(fail);
    }

    control {
        var verdicttype v_result;
        v_result := execute(TC_Sem_2602_TheControlPart_003());
	
        if (v_result == pass) {
            execute(TC_Sem_2602_TheControlPart_003_second());
        }
    }

}/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:C.6.2, Ensure that the IUT correctly handles the hostid function
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * check that  hostid function correctly evalutes the IPv4 or IPv6 address of the host.
 * 
 * */

module Sem_C0602_The_hostid_function_001 {

    type component GeneralComp {}
    type charstring IPaddressV4 (pattern "[0-9,.]#(7,15)");  // size of chastring is limited to 7-15 and contains numbers from 1-9 and "."
    type charstring IPaddressV6 (pattern @nocase "[0-9,a-f,:]#(1,37)");    // contains numbers from 1-9, a-f and ":". The size of chastring is limited to 37 
    
    testcase TC_Sem_C0602_The_hostid_function_001() runs on GeneralComp {

    var IPaddressV4 v_ipv4hostid;
    var IPaddressV6 v_ipv6hostid;
        
    if ((lengthof(hostid("IPv4")) == 0) or (lengthof(hostid("IPv6"))==0 ))    // in case of no ip address is given
        {
            setverdict(pass, "No ip address on interface");
        }

    else{
        
        v_ipv4hostid := hostid("IPv4");    // check IPv4 address with subtyping
              setverdict(pass, v_ipv4hostid);    
            
        v_ipv6hostid := hostid("IPv6");    // check IPv6 address with subtyping
                setverdict(pass, v_ipv6hostid);
        }
        
        
 }
    control{
    //  execute(TC_Sem_C0602_The_hostid_function_001(), -, "127.0.0.1"); //not supported by TestCast
        execute(TC_Sem_C0602_The_hostid_function_001());

    }

}/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:C.6.2, Ensure that the IUT correctly handles the testcasename function
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_C0602_The_testcasename_function_001 {

    type component GeneralComp {
    }

	// add a second testcase in order to see that the right TC name is returned
    testcase TC_Sem_C0602_The_testcasename_function_001_other() runs on GeneralComp {
    }

    testcase TC_Sem_C0602_The_testcasename_function_001() runs on GeneralComp {
        var charstring v_TCname := testcasename();
        if (match(v_TCname, "TC_Sem_C0602_The_testcasename_function_001")) {
            setverdict(pass);
        } else {
            setverdict(fail, "Expected TC name TC_Sem_C0602_The_testcasename_function_001 observer " & v_TCname);
        }
    }

    control{
        execute(TC_Sem_C0602_The_testcasename_function_001());
    }

}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:14, Ensure that with noblock signature the IUT can raise exception
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// Singature exception is a charsting with noblock signature

module Sem_1400_procedure_signatures_002 {

    signature p_Sig1_001(in integer p_par1) noblock
	exception (charstring);  //execption is a string


    type port remotePort procedure {
        inout  p_Sig1_001;
    }

    type component GeneralComp {
        port remotePort PCO;
		var integer MyComp;
    }
	

    function f_Server() runs on GeneralComp {
	PCO.raise(p_Sig1_001,"My string"); // raise exception
	}  
	
	function f_client() runs on GeneralComp {
	timer t_timeout:=30.0;
	
		t_timeout.start;
	
	 alt {
	  
      [] PCO.catch(p_Sig1_001,charstring:"My string") {
		setverdict(pass); // receive exception
	  }
	   
	  [] PCO.catch(p_Sig1_001,charstring:?) //receive anything else
	    {
		setverdict(fail);
	  }
      [] t_timeout.timeout {
        setverdict(fail);
      }
		
		} 
}
	
	testcase TC_Sem_1400_procedure_signatures_002() runs on GeneralComp system GeneralComp {
      
		var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
	   var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
       
	
       connect(server:PCO, client:PCO);

		
       server.start(f_Server());
	   client.start(f_client());
		
		       alt {
           [] client.done {
               server.stop;
           }
       }

       alt {
           [] all component.done {}
       }

       disconnect(server:PCO);
   }

    control{
        execute(TC_Sem_1400_procedure_signatures_002());
    }

}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:14, Ensure that the IUT calls signature exception 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Exception is a charstring

module Sem_1400_procedure_signatures_001 {

    signature p_Sig1_001(in integer p_par1, out integer p_par2, inout integer p_par3) return integer
	exception (charstring);  //execption is a string


    type port remotePort procedure {
        inout  p_Sig1_001;
    }

    type component GeneralComp {
        port remotePort PCO;
		var integer MyComp;
    }
	

    function f_Server() runs on GeneralComp {
	PCO.raise(p_Sig1_001,"My string"); // raise exception
	}  
	
	function f_client() runs on GeneralComp {
	timer t_timeout:=30.0;
	
		t_timeout.start;
	
	 alt {
	  [] PCO.catch(p_Sig1_001,charstring:"My string") {
		setverdict(pass); // receive exception
		}
	  [] PCO.catch(p_Sig1_001,charstring:?)  // receive anything else
	   {
		setverdict(fail);
	  }
    
      [] t_timeout.timeout {
        setverdict(fail);
      }
		
		} 
}
	
	testcase TC_Sem_1400_procedure_signatures_001() runs on GeneralComp system GeneralComp {
      
		var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
	   var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
       
	
       connect(server:PCO, client:PCO);

		
       server.start(f_Server());
	   client.start(f_client());
		
		       alt {
           [] client.done {
               server.stop;
           }
       }

       alt {
           [] all component.done {}
       }

       disconnect(server:PCO);
   }

    control{
        execute(TC_Sem_1400_procedure_signatures_001());
    }

}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:14, Ensure that multiple calls can be send without ack using non-blocking signature
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// Multiple calls without response or execption need noblock signature

module Sem_1400_procedure_signatures_004 {

	signature p_Sig1_001( in charstring key ) noblock;


	type port remotePort procedure {
		inout  p_Sig1_001;
	}

	type component GeneralComp {
		port remotePort PCO;
		var integer MyComp;
	}
    
	type component SystemComp {
	}
	
	const charstring key[3] := {"My String1", "hello", "Probe string"};

	function f_Server() runs on GeneralComp {
		for (var integer i := 0; i < lengthof(key); i := i + 1) {
			PCO.getcall(p_Sig1_001:{key[i]});
		}
		setverdict(pass);
	}
	
	function f_client() runs on GeneralComp {
		for (var integer i := 0; i < lengthof(key); i := i + 1) {
			PCO.call(p_Sig1_001:{key[i]}) ;
		}
	}
	
	testcase TC_Sem_1400_procedure_signatures_004() runs on GeneralComp system SystemComp {
      
		var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
		var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
		timer t_guard;
	
		connect(server:PCO, client:PCO);

		server.start(f_Server());
		client.start(f_client());

		t_guard.start( 5.0 );
		alt {
			[] all component.done {}
			[] t_guard.timeout {
				setverdict(fail);
				all component.stop;
			}
		}

		disconnect(server:PCO);
	}

	control{
		execute(TC_Sem_1400_procedure_signatures_004(), 10.0);
	}

}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:14, Ensure that non blocking signatures can raise exception
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// Singature exception is an integer

module Sem_1400_procedure_signatures_003 {

    signature p_Sig1_001(in integer p_par1) noblock
	exception (integer);  //execption is an integer

    type port remotePort procedure {
        inout  p_Sig1_001;
    }

    type component GeneralComp {
        port remotePort PCO;
		var integer MyComp;
    }
	

    function f_Server() runs on GeneralComp {
	PCO.raise(p_Sig1_001,5); // raise exception
	}  
	
	function f_client() runs on GeneralComp {
	timer t_timeout:=30.0;
	var integer temp;
		t_timeout.start;
	
	PCO.catch(p_Sig1_001,integer:5)-> value temp;
		if (temp==5)
		{
		setverdict(pass); // receive exception
		}
		else{
		setverdict(fail);	
		}
}
	
	testcase TC_Sem_1400_procedure_signatures_003() runs on GeneralComp system GeneralComp {
      
		var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
	   var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
       
	
       connect(server:PCO, client:PCO);

		
       server.start(f_Server());
	   client.start(f_client());
		
		       alt {
           [] client.done {
               server.stop;
           }
       }

       alt {
           [] all component.done {}
       }

       disconnect(server:PCO);
   }

    control{
        execute(TC_Sem_1400_procedure_signatures_003());
    }

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.5, Ensure that explicitly defined public definitions (in this case a sample constant) are visible when imported by a friend module.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_080205_VisibilityOfDefinitions_002 {

import from Sem_080205_VisibilityOfDefinitions_002_import all;

type component GeneralComp {}

testcase TC_Sem_080205_VisibilityOfDefinitions_002() runs on GeneralComp {
	if (c_myconst == 32532) { // c_myconst shall be visible on import when it is explicitly set to public.
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_080205_VisibilityOfDefinitions_002());
}
}

module Sem_080205_VisibilityOfDefinitions_002_import {
	friend module Sem_080205_VisibilityOfDefinitions_002;

	public const integer c_myconst := 32532;
}
module Sem_080205_VisibilityOfDefinitions_001_import {
	public const integer c_myconst := 32532;
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.5, Ensure that explicitly defined public definitions (in this case a sample constant) are visible when imported.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_080205_VisibilityOfDefinitions_001 {

import from Sem_080205_VisibilityOfDefinitions_001_import all;

type component GeneralComp {}

testcase TC_Sem_080205_VisibilityOfDefinitions_001() runs on GeneralComp {
	if (c_myconst == 32532) { // c_myconst shall be visible on import when it is explicitly set to public.
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_080205_VisibilityOfDefinitions_001());
}
}

module Sem_080205_VisibilityOfDefinitions_003_import {
	group CONST_GROUP {
		public const integer c_myconst := 32532;
	}
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.5, Ensure that explicitly defined public definitions (in this case a sample constant) are visible when imported through a group.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_080205_VisibilityOfDefinitions_003 {

import from Sem_080205_VisibilityOfDefinitions_003_import {
	group CONST_GROUP;
};

type component GeneralComp {}

testcase TC_Sem_080205_VisibilityOfDefinitions_003() runs on GeneralComp {
	if (c_myconst == 32532) { // c_myconst shall be visible on import when it is explicitly set to public.
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_080205_VisibilityOfDefinitions_003());
}
}

/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.5, Ensure that friend definitions (in this case a sample constant) are visible when imported through a group of a friend module.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_080205_VisibilityOfDefinitions_005 {

import from Sem_080205_VisibilityOfDefinitions_005_import {
	group CONST_GROUP;
};

type component GeneralComp {}

testcase TC_Sem_080205_VisibilityOfDefinitions_005() runs on GeneralComp {
	if (c_myconst == 32532) { // c_myconst shall be visible on import when it is explicitly set to public.
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_080205_VisibilityOfDefinitions_005());
}
}

module Sem_080205_VisibilityOfDefinitions_005_import {
	friend module Sem_080205_VisibilityOfDefinitions_005;

	group CONST_GROUP {
		friend const integer c_myconst := 32532;
	}
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.5, Ensure that explicitly defined public definitions (in this case a sample constant) are visible when imported through a group of a friend module.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_080205_VisibilityOfDefinitions_004 {

import from Sem_080205_VisibilityOfDefinitions_004_import {
	group CONST_GROUP;
};

type component GeneralComp {}

testcase TC_Sem_080205_VisibilityOfDefinitions_004() runs on GeneralComp {
	if (c_myconst == 32532) { // c_myconst shall be visible on import when it is explicitly set to public.
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_080205_VisibilityOfDefinitions_004());
}
}

module Sem_080205_VisibilityOfDefinitions_004_import {
	friend module Sem_080205_VisibilityOfDefinitions_004;

	group CONST_GROUP {
		public const integer c_myconst := 32532;
	}
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2, Ensure that a TypeDef module definition with public visibility is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/


module Syn_0802_ModuleDefinitionsPart_001 {
	public type record MyRecord1 {
		integer      field1, 
		charstring   field2 
	}
	 
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2, Ensure that a TypeDef module definition with private visibility is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/


module Syn_0802_ModuleDefinitionsPart_002 {
	private type record MyRecord1 {
		integer      field1, 
		charstring   field2 
	}
	 
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.4, Ensure that friend visibility works for a sample constant.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_080204_DefinitionOfFriendModules_001 {

import from Sem_080204_DefinitionOfFriendModules_001_import all;

type component GeneralComp {}

testcase TC_Sem_080204_DefinitionOfFriendModules_001() runs on GeneralComp {
	if (c_myconst == 32532) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_080204_DefinitionOfFriendModules_001());
}
}

module Sem_080204_DefinitionOfFriendModules_001_import {
	friend module Sem_080204_DefinitionOfFriendModules_001;

	friend const integer c_myconst := 32532;
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.2, Ensure that a definition within a group is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/


module Syn_080202_GroupOfDefinitions_001 {
	group TYPEDEF_GROUP {
		group RECORDS_GROUP {
			public type record MyRecord1 {
				integer      field1, 
				charstring   field2 
			}
		}
	}
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.2, Ensure that a definition within a group with public visibility modifier and attributes is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/


module Syn_080202_GroupOfDefinitions_004 {
	public group TYPEDEF_GROUP {
		public type record MyRecord1 {
			integer      field1, 
			charstring   field2 
		}
	} with {
		encode "Encoding 3";
	}
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.2, Ensure that a definition within a group with public visibility modifier is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/


module Syn_080202_GroupOfDefinitions_003 {
	public group TYPEDEF_GROUP {
		public type record MyRecord1 {
			integer      field1, 
			charstring   field2 
		}
	}
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.2, Ensure that a definition within a nested group is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/


module Syn_080202_GroupOfDefinitions_002 {
	group MY_TYPEDEF_GROUP {
		
		public type record MyRecord1 {
			integer      field1, 
			charstring   field2 
		}
	}
}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.8, Verify that modules with explicit language tag can import from older TTCN-3 versions 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Restriction c:
// The TTCN-3 language specification in an import statement shall be lower or equal 
// to the TTCN-3 language specification of the importing module, i.e. a TTCN-3 module 
// can only import from earlier or same editions of TTCN-3 but not from later editions.

module Sem_08020308_CompatibilityOfLanguageSpecificationsInImports_001 language "TTCN-3:2013" {

import from Sem_08020308_CompatibilityOfLanguageSpecificationsInImports_001_import language "TTCN-3:2012" all;

type component GeneralComp {}

testcase TC_Sem_08020308_CompatibilityOfLanguageSpecificationsInImports_001() runs on GeneralComp {			
	if (c_test == 0) { setverdict(pass); }
	else { setverdict(fail); }
}
	
control{
	// testing if parameter names are imported
    execute(TC_Sem_08020308_CompatibilityOfLanguageSpecificationsInImports_001()); 
}
}

module Sem_08020308_CompatibilityOfLanguageSpecificationsInImports_001_import {
	const integer c_test := 0;
}
module Sem_08020308_CompatibilityOfLanguageSpecificationsInImports_002_import language "TTCN-3:2012" {
	const integer c_test := 0;
}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.8, Verify that modules with explicit language tag can import from older TTCN-3 versions 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Restriction c:
// The TTCN-3 language specification in an import statement shall be lower or equal 
// to the TTCN-3 language specification of the importing module, i.e. a TTCN-3 module 
// can only import from earlier or same editions of TTCN-3 but not from later editions.

module Sem_08020308_CompatibilityOfLanguageSpecificationsInImports_002 language "TTCN-3:2013" {

import from Sem_08020308_CompatibilityOfLanguageSpecificationsInImports_002_import all;

type component GeneralComp {}

testcase TC_Sem_08020308_CompatibilityOfLanguageSpecificationsInImports_002() runs on GeneralComp {			
	if (c_test == 0) { setverdict(pass); }
	else { setverdict(fail); }
}
	
control{
	// testing if parameter names are imported
    execute(TC_Sem_08020308_CompatibilityOfLanguageSpecificationsInImports_002()); 
}
}

module Sem_08020307_ImportingOfImportStatementsFromT3Modules_001_importA {
	public import from Sem_08020307_ImportingOfImportStatementsFromT3Modules_001_importB all;
}

module Sem_08020307_ImportingOfImportStatementsFromT3Modules_001_importB {
	const integer c_myconst := 43532;
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.7, Ensure that the import of import statements works for import all.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_08020307_ImportingOfImportStatementsFromT3Modules_001 {

import from Sem_08020307_ImportingOfImportStatementsFromT3Modules_001_importA {
	import all;
};

type component GeneralComp {}

testcase TC_Sem_08020307_ImportingOfImportStatementsFromT3Modules_001() runs on GeneralComp {
	if (c_myconst == 43532) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_08020307_ImportingOfImportStatementsFromT3Modules_001());
}
}

module Sem_08020307_ImportingOfImportStatementsFromT3Modules_002_importA {
    // imports are private by default
	import from NegSem_08020307_ImportingOfImportStatementsFromT3Modules_002_importB all;
}

/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:8.2.3.6, Ensure that it is possible to import from previous language versions.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Sem_08020306_ImportingDefinitionsFromOtherT3EditionsAndFromNonT3Modules_001 language "TTCN-3:2010" {
	import from Sem_08020306_ImportingDefinitionsFromOtherT3EditionsAndFromNonT3Modules_001_import language "TTCN-3:2003" {
		const all;
	} 
}

module Sem_08020306_ImportingDefinitionsFromOtherT3EditionsAndFromNonT3Modules_001_import {
	const integer c_myconst := 1;
}
module Syn_08020306_ImportingDefinitionsFromOtherT3EditionsAndFromNonT3Modules_001_import {
	const integer c_myconst := 1;
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.6, Ensure that imports work with language references when importing definitions of the same kinds (in this case constants) is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_08020306_ImportingDefinitionsFromOtherT3EditionsAndFromNonT3Modules_001 {
	import from Syn_08020306_ImportingDefinitionsFromOtherT3EditionsAndFromNonT3Modules_001_import language "TTCN-3:2003" {
		const all;
	} 
}

/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.6, Ensure that imports work with language references when importing all definitions of another module is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_08020306_ImportingDefinitionsFromOtherT3EditionsAndFromNonT3Modules_002 {
	import from Syn_08020306_ImportingDefinitionsFromOtherT3EditionsAndFromNonT3Modules_002_import language "TTCN-3:2003" all ;
}

module Syn_08020306_ImportingDefinitionsFromOtherT3EditionsAndFromNonT3Modules_002_import {
	const integer c_myconst := 1;
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.5, Ensure that the constant is be visible after multiple imports.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_08020305_ImportingAllDefinitionsOfAModule_001 {

import from Sem_08020305_ImportingAllDefinitionsOfAModule_001_import all;

type component GeneralComp {}

testcase TC_Sem_08020305_ImportingAllDefinitionsOfAModule_001() runs on GeneralComp {
	if (c_myconst == 43532) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_08020305_ImportingAllDefinitionsOfAModule_001());
}
}

module Sem_08020305_ImportingAllDefinitionsOfAModule_001_import {
	const integer c_myconst := 43532;
}
module Sem_08020305_ImportingAllDefinitionsOfAModule_002_import {
	const integer c_myconst := 43532;
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.5, Ensure that the constant is be visible after multiple imports.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_08020305_ImportingAllDefinitionsOfAModule_002 {

import from Sem_08020305_ImportingAllDefinitionsOfAModule_002_import all except { 
	const all;
};
import from Sem_08020305_ImportingAllDefinitionsOfAModule_002_import all; // second import overrides the first

type component GeneralComp {}

testcase TC_Sem_08020305_ImportingAllDefinitionsOfAModule_002() runs on GeneralComp {
	if (c_myconst == 43532) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_08020305_ImportingAllDefinitionsOfAModule_002());
}
}

/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify that information about type of constant is imported together with constant
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Restriction d:
// A definition is imported together with all information of referenced definitions that 
// are necessary for the usage of the imported definition, independent of the visibility 
// of the referenced definitions.
// Table 8:
// Possible referenced definitions for a signature: parameter types

module Sem_08020301_GeneralFormatOfImport_016 {

import from Sem_08020301_GeneralFormatOfImport_016_import { const c_test };

type component GeneralComp {}

testcase TC_Sem_08020301_GeneralFormatOfImport_016() runs on GeneralComp {			
	// type compatibility is checked during assignment: for this check, the type information for c_test
	// should be available at this point to compile the script correctly
	var integer v_test := c_test;
	if (v_test == 0) { setverdict(pass); }
	else { setverdict(fail); }
}
	
control{
	// testing if parameter names are imported
    execute(TC_Sem_08020301_GeneralFormatOfImport_016()); 
}
}

module Sem_08020301_GeneralFormatOfImport_016_import {
	const integer c_test := 0;
}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify that prefixed type is evaluated as expected
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
/*In cases where there are no ambiguities the prefixing need not (but may) be present when the imported definitions are
used. When the definition is referenced in the same module where it is defined, the module identifier of the module (the
current module) also may be used for prefixing the identifier of the definition.*/

module Sem_08020301_GeneralFormatOfImport_020 {

	import from Sem_08020301_GeneralFormatOfImport_020_import {type My_type};

	type float My_type;	//float type

	type component GeneralComp {}	

testcase TC_Sem_08020301_GeneralFormatOfImport_020() runs on GeneralComp {			
    
	var My_type v_1 := 2.5;		//prefixed type
	var Sem_08020301_GeneralFormatOfImport_020_import.My_type v_2 := 1;    //prefix and the identifier 

	if( (match(v_1,2.5)) and (match(v_2,1)))
	{
		setverdict(pass);
	} else {
		setverdict(fail);
	}

}
	
control{
	// testing if parameter names are imported
    execute(TC_Sem_08020301_GeneralFormatOfImport_020()); 
}
}

module Sem_08020301_GeneralFormatOfImport_020_import {	
 	type integer My_type;		//integer type
	
}
/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:8.2.3.4, Ensure that transitive imports are properly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_08020301_GeneralFormatOfImport_001 {

import from Sem_08020301_GeneralFormatOfImport_001_import { import all };

type component GeneralComp {}

testcase TC_Sem_08020301_GeneralFormatOfImport_001() runs on GeneralComp {
	if (c_myconst == 43532) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_08020301_GeneralFormatOfImport_001());
}
}

module Sem_08020301_GeneralFormatOfImport_001_import_2 {
	const integer c_myconst := 43532;
}
module Sem_08020301_GeneralFormatOfImport_001_import {
	public import from Sem_08020301_GeneralFormatOfImport_001_import_2 all;
}


/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify using of import clause with language tag for impoting module with no language tag
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Restriction h:
// The language specification of the import statement shall be identical to the language 
// specification of the source module from which definitions are imported provided 
// a language specification is defined in the source module.

module Sem_08020301_GeneralFormatOfImport_018 {

import from Sem_08020301_GeneralFormatOfImport_018_import language "TTCN-3:2013" all;

type component GeneralComp {}

testcase TC_Sem_08020301_GeneralFormatOfImport_018() runs on GeneralComp {			
	if (c_test == 0) { setverdict(pass); }
	else { setverdict(fail); }
}
	
control{
	// testing if parameter names are imported
    execute(TC_Sem_08020301_GeneralFormatOfImport_018()); 
}
}

module Sem_08020301_GeneralFormatOfImport_018_import {
	const integer c_test := 0;
}
module Sem_08020301_GeneralFormatOfImport_014_import {
	type component GeneralComp {}
	testcase TC_Sem_08020301_GeneralFormatOfImport_014(integer p_param1, integer p_param2) runs on GeneralComp {			
		if ( match(p_param1, 1) and match(p_param2, 2)) { setverdict(pass); }
		else { setverdict(fail); }
	}
}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify that test case is imported together with parameter names
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Restriction c:
// A definition is imported together with its name and all local definitions.
// Restriction d:
// A definition is imported together with all information of referenced definitions that 
// are necessary for the usage of the imported definition, independent of the visibility 
// of the referenced definitions.
// Table 8:
// Test case

module Sem_08020301_GeneralFormatOfImport_014 {

import from Sem_08020301_GeneralFormatOfImport_014_import { testcase TC_Sem_08020301_GeneralFormatOfImport_014 };
	
control{
	// testing if parameter names are imported
    // type compatibility is checked during parameter passing: for this check, the type information for 
	// the test case parameters should be available at this point to compile the script correctly
	execute(TC_Sem_08020301_GeneralFormatOfImport_014(p_param2 := 2, p_param1 := 1)); 
}
}

/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify that type of port is imported from a module as expected
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
/*If the type of the component referenced in a connection operation is known (either when the component reference is a
variable or value returned from a function or the type is defined the runs on, mtc or system clause of the calling
function), the referenced port declaration shall be present in this component type.*/

module Sem_08020301_GeneralFormatOfImport_019 {

import from Sem_08020301_GeneralFormatOfImport_019_import all;

	type component GeneralComp {	    	    
	  port loopbackPort messagePort
	}	

testcase TC_Sem_08020301_GeneralFormatOfImport_019() runs on GeneralComp {			
    
    var My_int v_int := 2;	//type reference from other module
    messagePort.send(v_int);	//send message

    alt {
     [] messagePort.receive(v_int) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}
	
control{
	// testing if parameter names are imported
    execute(TC_Sem_08020301_GeneralFormatOfImport_019()); 
}
}

module Sem_08020301_GeneralFormatOfImport_019_import {	
	type integer My_int;
	type port loopbackPort message{inout My_int};
	
}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Make sure that it is possible to use module prefix for local definitions
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When the definition is referenced in the same module where it is defined, the 
// module identifier of the module (the current module) also may be used for prefixing 
// the identifier of the definition.

module Sem_08020301_GeneralFormatOfImport_005 {

type component GeneralComp {}
const integer c_test := 5;

testcase TC_Sem_08020301_GeneralFormatOfImport_005() runs on GeneralComp {	
	log(Sem_08020301_GeneralFormatOfImport_005.c_test);
	setverdict(pass);
}
	
control{
    execute(TC_Sem_08020301_GeneralFormatOfImport_005());
}
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:8.2.3.4, Ensure that enumerated type definitions are automatically imported when needed
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_08020301_GeneralFormatOfImport_002 {

import from Sem_08020301_GeneralFormatOfImport_002_import {
	modulepar px_enum;
};

type component GeneralComp {}

testcase TC_Sem_08020301_GeneralFormatOfImport_002() runs on GeneralComp {

	if (px_enum == enumX) { //this must be a recognized enum value 
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_08020301_GeneralFormatOfImport_002());
}
}

module Sem_08020301_GeneralFormatOfImport_002_import_2 {
	type enumerated EnumType {enumX, enumY, enumZ};
}
module Sem_08020301_GeneralFormatOfImport_002_import {
	import from Sem_08020301_GeneralFormatOfImport_002_import_2 all;

	modulepar EnumType px_enum:=enumX;
}


module Sem_08020301_GeneralFormatOfImport_013_import {
	altstep a_test(integer p_param1, integer p_param2) {
		[] any timer.timeout {}
		[else] {
			if ( match(p_param1, 1) and match(p_param2, 2) ) { setverdict(pass); }
			else { setverdict(fail); }
		}
	}
}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify that altstep is imported together with parameter names
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Restriction c:
// A definition is imported together with its name and all local definitions.
// Restriction d:
// A definition is imported together with all information of referenced definitions that 
// are necessary for the usage of the imported definition, independent of the visibility 
// of the referenced definitions.
// Table 8:
// Altstep

module Sem_08020301_GeneralFormatOfImport_013 {

import from Sem_08020301_GeneralFormatOfImport_013_import { altstep a_test };

type component GeneralComp {}

testcase TC_Sem_08020301_GeneralFormatOfImport_013() runs on GeneralComp {			
	// testing if parameter names are imported
	// type compatibility is checked during parameter passing: for this check, the type information for 
	// the altstep parameters should be available at this point to compile the script correctly
	a_test(p_param2 := 2, p_param1 := 1); 
}
	
control{
    execute(TC_Sem_08020301_GeneralFormatOfImport_013());
}
}

module Syn_08020301_GeneralFormatOfImport_001_import {
	const integer c_myconst := 1;
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Ensure that import all is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/


module Syn_08020301_GeneralFormatOfImport_001 {
	import from Syn_08020301_GeneralFormatOfImport_001_import all;
}

module Syn_08020301_GeneralFormatOfImport_002_import {
	const integer c_myconst := 1;
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Ensure that import of specific types is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_08020301_GeneralFormatOfImport_002 {
	import from Syn_08020301_GeneralFormatOfImport_002_import {
		type all;
		template all;
		const c_myconst;
		testcase all;
		altstep all;
		function all;
		signature all;
		modulepar all;
	};

}

module Sem_08020301_GeneralFormatOfImport_009_import
{
	type port P message {
		inout integer;
	}
	type component GeneralComp 
	{
		const integer cc_test := 0;
		var integer vc_test := 1;
		timer tc_test := 1.0;
		port P p1;
	}
}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify that component type is imported together with constant, variable, timer and port names
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Restriction c:
// A definition is imported together with its name and all local definitions.
// Restriction d:
// A definition is imported together with all information of referenced definitions that 
// are necessary for the usage of the imported definition, independent of the visibility 
// of the referenced definitions.
// Table 8:
// User-defined type, component type

module Sem_08020301_GeneralFormatOfImport_009 {

import from Sem_08020301_GeneralFormatOfImport_009_import { type GeneralComp };

testcase TC_Sem_08020301_GeneralFormatOfImport_009() runs on GeneralComp {	
	// type compatibility is checked during assignment: 
	// for this check, type information for constant and variable types 
	// should be available at this point to compile the script correctly	
	var integer v_test;
	v_test := cc_test; // testing constant reference
	log(v_test);
	v_test := vc_test; // testing variable reference
	log(v_test);
	tc_test.start; // testing timer reference
	p1.start; // testing port reference
	setverdict(pass);
}
	
control{
    execute(TC_Sem_08020301_GeneralFormatOfImport_009());
}
}

/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify that function is imported together with parameter names
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Restriction c:
// A definition is imported together with its name and all local definitions.
// Restriction d:
// A definition is imported together with all information of referenced definitions that 
// are necessary for the usage of the imported definition, independent of the visibility 
// of the referenced definitions.
// Table 8:
// Function

module Sem_08020301_GeneralFormatOfImport_012 {

import from Sem_08020301_GeneralFormatOfImport_012_import { function f_div };

type component GeneralComp {}

testcase TC_Sem_08020301_GeneralFormatOfImport_012() runs on GeneralComp {		
	
	// testing if function parameter names were imported
	// type compatibility is checked during parameter passing and return value assignment: for 
	// this check, the type information for the function parameters and return values should be 
	// available at this point to compile the script correctly
	var integer v_res := f_div(p_param1 := 10, p_param2 := 5);
	if (v_res == 2) 
		{ setverdict(pass); }
	else
		{ setverdict(fail); }
}
	
control{
    execute(TC_Sem_08020301_GeneralFormatOfImport_012());
}
}

module Sem_08020301_GeneralFormatOfImport_012_import {
	function f_div(integer p_param1, integer p_param2) return integer {
		return p_param1 / p_param2;
	}
}
module Sem_08020301_GeneralFormatOfImport_003_import
{
	const integer c_myconst := 43532;
}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Make sure that local definition takes precedence over imported one when their identifiers are equal
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Name clashes may occur due to import, e.g. import from different modules. Name clashes 
// shall be resolved using qualified name(s) for the imported definition(s), i.e. prefixing 
// the imported definition (which causes the name clash) by the identifier of the module in 
// which it has been defined; the prefix and the identifier shall be separated by a dot (".").

module Sem_08020301_GeneralFormatOfImport_003 {

import from Sem_08020301_GeneralFormatOfImport_003_import all;

type component GeneralComp {}

testcase TC_Sem_08020301_GeneralFormatOfImport_003() runs on GeneralComp {
	if (c_myconst == -1) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

const integer c_myconst := -1;
	
control{
    execute(TC_Sem_08020301_GeneralFormatOfImport_003());
}
}

/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Make sure that it is possible to use module prefix for imported definitions
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Name clashes shall be resolved using qualified name(s) for the imported definition(s), 
// i.e. prefixing the imported definition by the identifier of the module in which it has 
// been defined; the prefix and the identifier shall be separated by a dot (".").
// In cases where there are no ambiguities the prefixing need not (but may) be present 
// when the imported definitions are used.

module Sem_08020301_GeneralFormatOfImport_007 {

import from Sem_08020301_GeneralFormatOfImport_007_import all;

type component GeneralComp {}

testcase TC_Sem_08020301_GeneralFormatOfImport_007() runs on GeneralComp {	
	log(Sem_08020301_GeneralFormatOfImport_007_import.c_test);
	setverdict(pass);
}
	
control{
    execute(TC_Sem_08020301_GeneralFormatOfImport_007());
}
}

module Sem_08020301_GeneralFormatOfImport_007_import
{
	const integer c_test := 5;
}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Make sure that it is possible to use module prefix for local definitions
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When the definition is referenced in the same module where it is defined, the 
// module identifier of the module (the current module) also may be used for prefixing 
// the identifier of the definition.

module Sem_08020301_GeneralFormatOfImport_006 {

type component GeneralComp {}

testcase TC_Sem_08020301_GeneralFormatOfImport_006() runs on GeneralComp {	
	var integer c_test := 5;
	log(Sem_08020301_GeneralFormatOfImport_006.c_test);
	setverdict(pass);
}
	
control{
    execute(TC_Sem_08020301_GeneralFormatOfImport_006());
}
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify that structured type is imported together with its field names and nested type definitions
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Restriction c:
// A definition is imported together with its name and all local definitions.
// Restriction d:
// A definition is imported together with all information of referenced definitions that 
// are necessary for the usage of the imported definition, independent of the visibility 
// of the referenced definitions.
// Table 8:
// User-defined type, structured type

module Sem_08020301_GeneralFormatOfImport_008 {

import from Sem_08020301_GeneralFormatOfImport_008_import { type R, U };

type component GeneralComp {}
	
type U.variant1 Test; // test if nested type is imported

testcase TC_Sem_08020301_GeneralFormatOfImport_008() runs on GeneralComp {	
	var Test v_test1 := { subfield1 := 1, subfield2 := 2 }
	var R v_test2;
	// test if field names are imported and type information is avaiable (necessary for 
	// compatibility check during assignment
	v_test2.field1 := 1;
	v_test2.field2 := 2;
	log (v_test1);
	log (v_test2);
	setverdict(pass);
}
	
control{
    execute(TC_Sem_08020301_GeneralFormatOfImport_008());
}
}

module Sem_08020301_GeneralFormatOfImport_008_import
{
	type record R {
		integer field1,
		integer field2
	}
	
	type union U {
		set {
			integer subfield1,
			integer subfield2
		} variant1,
		integer variant2
	}
}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify using of import clause with language tag for impoting module having identical language tag
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Restriction h:
// The language specification of the import statement shall be identical to the language 
// specification of the source module from which definitions are imported provided 
// a language specification is defined in the source module.

module Sem_08020301_GeneralFormatOfImport_017 {

import from Sem_08020301_GeneralFormatOfImport_017_import language "TTCN-3:2013" all;

type component GeneralComp {}

testcase TC_Sem_08020301_GeneralFormatOfImport_017() runs on GeneralComp {			
	if (c_test == 0) { setverdict(pass); }
	else { setverdict(fail); }
}
	
control{
	// testing if parameter names are imported
    execute(TC_Sem_08020301_GeneralFormatOfImport_017()); 
}
}

module Sem_08020301_GeneralFormatOfImport_017_import language "TTCN-3:2013" {
	const integer c_test := 0;
}
module Sem_08020301_GeneralFormatOfImport_004_import
{
	type enumerated EnumType {enumX, enumY, enumZ};
	const EnumType c_enumVal := enumX;
}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Make sure that imported enumeration values take precedence over local definition
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// There is one exception to this rule: when in the context of an enumerated type 
// (see clause 6.2.4), an enumerated value is clashing with the name of a definition in 
// the importing module, the enumerated value shall take precedence and the definition 
// in the importing module shall be referenced by using its qualified name.

module Sem_08020301_GeneralFormatOfImport_004 {

import from Sem_08020301_GeneralFormatOfImport_004_import all;

type component GeneralComp {}

testcase TC_Sem_08020301_GeneralFormatOfImport_004() runs on GeneralComp {	
	var integer enumX := 1;
	if (c_enumVal == enumX) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}
	
control{
    execute(TC_Sem_08020301_GeneralFormatOfImport_004());
}
}

/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify that parameterized template is imported together with parameter names
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Restriction c:
// A definition is imported together with its name and all local definitions.
// Restriction d:
// A definition is imported together with all information of referenced definitions that 
// are necessary for the usage of the imported definition, independent of the visibility 
// of the referenced definitions.
// Table 8:
// Data template

module Sem_08020301_GeneralFormatOfImport_011 {

import from Sem_08020301_GeneralFormatOfImport_011_import { type R; template m_test1 };

type component GeneralComp {}

type record RLocal { // compatible type with Sem_08020301_GeneralFormatOfImport_011_import.R
	integer field1,
	integer field2
}
testcase TC_Sem_08020301_GeneralFormatOfImport_011() runs on GeneralComp {		
	
	// type compatibility is checked during parameter passing and template assignment: 
	// for this check, type information for the template parameters and template type  
	// should be available at this point to compile the script correctly	
	template RLocal m_res := m_test1(p_param2 := 10);
	if (match({1, 10}, m_res)) // testing if parameter name is imported
		{ setverdict(pass); }
	else
		{ setverdict(fail); }
}
	
control{
    execute(TC_Sem_08020301_GeneralFormatOfImport_011());
}
}

module Sem_08020301_GeneralFormatOfImport_011_import {
	type record R {
		integer field1,
		integer field2
	}
	template R m_test1(integer p_param1 := 1 , integer p_param2 := 2) := {
		field1 := p_param1,
		field2 := p_param2
	}
}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify that information about module parameter type is imported together with module parameter
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Restriction d:
// A definition is imported together with all information of referenced definitions that 
// are necessary for the usage of the imported definition, independent of the visibility 
// of the referenced definitions.
// Table 8:
// Module parameter

module Sem_08020301_GeneralFormatOfImport_015 {

import from Sem_08020301_GeneralFormatOfImport_015_import { modulepar PX_TEST };

type component GeneralComp {}

testcase TC_Sem_08020301_GeneralFormatOfImport_015() runs on GeneralComp {			
	// type compatibility is checked during assignment: for this check, the type information for PX_TEST
	// should be available at this point to compile the script correctly
	var integer v_test := PX_TEST;
	if (v_test == 0) { setverdict(pass); }
	else { setverdict(fail); }
}
	
control{
	// testing if parameter names are imported
    execute(TC_Sem_08020301_GeneralFormatOfImport_015()); 
}
}

module Sem_08020301_GeneralFormatOfImport_015_import {
	modulepar integer PX_TEST := 0;
}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:8.2.3.1, Verify that signature is imported together with parameter names
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Restriction c:
// A definition is imported together with its name and all local definitions.
// Restriction d:
// A definition is imported together with all information of referenced definitions that 
// are necessary for the usage of the imported definition, independent of the visibility 
// of the referenced definitions.
// Table 8:
// Signature

module Sem_08020301_GeneralFormatOfImport_010 {

import from Sem_08020301_GeneralFormatOfImport_010_import { signature Signature1 };

type component GeneralComp {}

// type compatibility is checked during parameter passing: for this check, type 
// information for the signature parameters should be available at this point 
// to compile the script correctly	
template Signature1 s_test := {
	p_param1 := 1 // testing signature parameter name
}

testcase TC_Sem_08020301_GeneralFormatOfImport_010() runs on GeneralComp {	
	log (s_test); 
	setverdict(pass);
}
	
control{
    execute(TC_Sem_08020301_GeneralFormatOfImport_010());
}
}

module Sem_08020301_GeneralFormatOfImport_010_import
{
	signature Signature1 (in integer p_param1);
}
module Sem_08020303_ImportingGroups_001_import {
	group CONST_GROUP {
		const integer c_myconst := 43532;
	}
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.3, Ensure that a const defined in a group can be accessed if the group is imported.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_08020303_ImportingGroups_001 {

import from Sem_08020303_ImportingGroups_001_import {
	group CONST_GROUP;
};

type component GeneralComp {}

testcase TC_Sem_08020303_ImportingGroups_001() runs on GeneralComp {
	if (c_myconst == 43532) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_08020303_ImportingGroups_001());
}
}

module Sem_08020303_ImportingGroups_002_import {
	group CONST_GROUP {
		group CONST_INNER_GROUP {
			const integer c_myconst := 43532;
		}
	}
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.3, Ensure that the IUT properly handles 'except' clause in group import definitions
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_08020303_ImportingGroups_002 {

import from Sem_08020303_ImportingGroups_002_import {
	group CONST_GROUP except {
		const c_myconst;
	};
	const all;
	group CONST_INNER_GROUP except {
		const c_myconst;
	};	
}

type component GeneralComp {}

testcase TC_Sem_08020303_ImportingGroups_002() runs on GeneralComp {
	if (c_myconst == 43532) { // c_myconst shall be imported from const all;, the exception must not removed it from the imports.
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_08020303_ImportingGroups_002());
}
}

module Sem_08020303_ImportingGroups_003_import {
    group CONST_GROUP {
        group CONST_INNER_GROUP {
            const integer c_myconst := 43532;
        }
    }
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.3, but that it is in fact a shortcut notation for explicit imports.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_08020303_ImportingGroups_003 {

    import from Sem_08020303_ImportingGroups_003_import {
        group CONST_GROUP.CONST_INNER_GROUP except {
            const c_myconst;
        };
        const all;
    }

    type component GeneralComp {}

    testcase TC_Sem_08020303_ImportingGroups_003() runs on GeneralComp {
        if (c_myconst == 43532) { // c_myconst shall be imported from const all;, the exception must not removed it from the imports.
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_08020303_ImportingGroups_003());
    }
}

module Sem_08020304_ImportingDefinitionsOfTheSameKind_001_import {
	const integer c_myconst := 43532;
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.4, Ensure that an import of all constants allows access to a sample constant.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_08020304_ImportingDefinitionsOfTheSameKind_001 {

import from Sem_08020304_ImportingDefinitionsOfTheSameKind_001_import {
	const all;
};

type component GeneralComp {}

testcase TC_Sem_08020304_ImportingDefinitionsOfTheSameKind_001() runs on GeneralComp {
	if (c_myconst == 43532) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_08020304_ImportingDefinitionsOfTheSameKind_001());
}
}

module Sem_08020304_ImportingDefinitionsOfTheSameKind_003_import {
	const integer c_myconst := 43532;
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.4, Ensure that a previously valid const import is not removed by a second import statement excluding the same definition.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_08020304_ImportingDefinitionsOfTheSameKind_003 {

import from Sem_08020304_ImportingDefinitionsOfTheSameKind_003_import all;
import from Sem_08020304_ImportingDefinitionsOfTheSameKind_003_import {
	const all except c_myconst;
};

type component GeneralComp {}

testcase TC_Sem_08020304_ImportingDefinitionsOfTheSameKind_003() runs on GeneralComp {
	if (c_myconst == 43532) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_08020304_ImportingDefinitionsOfTheSameKind_003());
}
}

/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.4, Ensure that a previously valid const import is not removed by an import covering the same definition with an except.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_08020304_ImportingDefinitionsOfTheSameKind_002 {

import from Sem_08020304_ImportingDefinitionsOfTheSameKind_002_import {
	const all;
	const all except c_myconst;
};

type component GeneralComp {}

testcase TC_Sem_08020304_ImportingDefinitionsOfTheSameKind_002() runs on GeneralComp {
	if (c_myconst == 43532) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_08020304_ImportingDefinitionsOfTheSameKind_002());
}
}

module Sem_08020304_ImportingDefinitionsOfTheSameKind_002_import {
	const integer c_myconst := 43532;
}
module Sem_08020302_ImportingSingleDefinitions_001_import {
	const integer c_myconst := 43532;
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.2, Ensure that the value of an explicitly imported constant can be read and carries the same value.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_08020302_ImportingSingleDefinitions_001 {

import from Sem_08020302_ImportingSingleDefinitions_001_import {
	const c_myconst;
};

type component GeneralComp {}

testcase TC_Sem_08020302_ImportingSingleDefinitions_001() runs on GeneralComp {
	if (c_myconst == 43532) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}		

control{
    execute(TC_Sem_08020302_ImportingSingleDefinitions_001());
}
}

/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.3.2, Ensure that the value of an explicitly imported template can be read and carries the same value.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_08020302_ImportingSingleDefinitions_002 {

    import from Sem_08020302_ImportingSingleDefinitions_002_import {
        template m_myTemplate;
    };

    type component GeneralComp {}
    type record MyMessageType2 {
        integer	field1,
        charstring field2,
        boolean field3
    }

    testcase TC_Sem_08020302_ImportingSingleDefinitions_002() runs on GeneralComp {
        var MyMessageType2 v_value:={23521, "My String", true};
 
        if (match(v_value, m_myTemplate)) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_08020302_ImportingSingleDefinitions_002());
    }
}

module Sem_08020302_ImportingSingleDefinitions_002_import {
    type record MyMessageType {
        integer	field1,
        charstring field2,
        boolean field3
    }

    template MyMessageType m_myTemplate := {
        field1 := 23521,
        field2 := "My String",
        field3 := true
    }
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.1, Ensure that plain module parameters are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_080201_ModuleParameters_001 {
	modulepar integer MY_INTEGER_MODULE_PARAMETER;
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.1, Ensure that a reference to plain module parameter with a default value delivers the default value unless it is overwritten.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_080201_ModuleParameters_001 {

modulepar integer MY_INTEGER_MODULE_PARAMETER := 2;
	
type component GeneralComp {	    	    
}

testcase TC_Sem_080201_ModuleParameters_001() runs on GeneralComp {
	if (MY_INTEGER_MODULE_PARAMETER == 2) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}
	
control{
    execute(TC_Sem_080201_ModuleParameters_001());
}
	
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.1, Ensure that plain module parameters with default values are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_080201_ModuleParameters_002 {
	modulepar integer MY_INTEGER_MODULE_PARAMETER := 2;
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.2.1, Ensure that plain module parameters with default values and visibility modifiers are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_080201_ModuleParameters_003 {
	private modulepar integer MY_INTEGER_MODULE_PARAMETER := 2;
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.1, Ensure that a module definition with language specification is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_0801_DefinitionOfAModule_002 language "TTCN-3:2005" {

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.1, Ensure that a module definition with language and package is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_0801_DefinitionOfAModule_003 language "TTCN-3:2010", "TTCN-3:2010 Advanced Parameterization" {

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:8.1, Ensure that a module definition with ed4.7.1 language and package is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_0801_DefinitionOfAModule_009 language "TTCN-3:2015" {

}
/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:8.1, Ensure that a module definition with ed4.4.1 language and package is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_0801_DefinitionOfAModule_006 language "TTCN-3:2012" {

}
/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:8.1, Ensure that a module definition with ed4.3.1 language and package is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_0801_DefinitionOfAModule_005 language "TTCN-3:2011", "TTCN-3:2010 Advanced Parameterization" {

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.1, Ensure that a module definition with package and without language is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_0801_DefinitionOfAModule_004 language "TTCN-3:2010 Advanced Parameterization" {

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.1, Ensure that a "plain" module definition is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_0801_DefinitionOfAModule_001 {

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:8.1, Ensure that a module definition with ed4.5.1 language and package is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_0801_DefinitionOfAModule_007 language "TTCN-3:2013" {

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:8.1, Ensure that a module definition with ed4.6.1 language and package is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_0801_DefinitionOfAModule_008 language "TTCN-3:2014" {

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.3, Ensure that the module control part with a few commonly used stateents is accepted.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Syn_0803_ModuleControlPart_002 {

type component GeneralComp {}

type record MyRecordType {
	integer field1,
	charstring field2
}

testcase TC_Syn_0803_ModuleControlPart_002() runs on GeneralComp {
	setverdict(pass);
}

control {
	var integer v_i := 1;
	const charstring v_hello := "Hello World";
	timer t_mytimer;
	t_mytimer.start(1.0);
	if (v_i == 1) {
		execute(TC_Syn_0803_ModuleControlPart_002(), 5.0);
	} else {
		log("something went wrong");
	}
	t_mytimer.stop;
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.3, Ensure that the module control is able to accept execute statements.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_0803_ModuleControlPart_001 {

type component GeneralComp {}

testcase TC_Syn_0803_ModuleControlPart_001() runs on GeneralComp {
	setverdict(pass);
}

control {
	execute(TC_Syn_0803_ModuleControlPart_001());	
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.3, Ensure that the verdict returned from a test case to the control-part does not influence the execution of a second test case. The result of the last test case execution corresponds to the overall test verdict. 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_0803_ModuleControlPart_001 {

type component GeneralComp {}

testcase TC_Sem_0803_ModuleControlPart_001() runs on GeneralComp {
	setverdict(pass);
}

testcase TC_Sem_0803_ModuleControlPart_001_second(verdicttype p_passthroughVerdict) runs on GeneralComp {
	if (match(p_passthroughVerdict, getverdict) and match(getverdict, none) ) { // verdict should be none.
		setverdict(fail);
	} else {
		setverdict(pass);
	}
}


control {
	var verdicttype v_myverdict;
	v_myverdict := execute(TC_Sem_0803_ModuleControlPart_001());
	execute(TC_Sem_0803_ModuleControlPart_001_second(v_myverdict));
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:8.3, Ensure that an empty control part is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_0803_ModuleControlPart_003 {

control {
	
}

}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:13, Port with type anytype can send and receive messages of any basic or structured type: 'bitstring' type.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/13 Declaring messages/Any type can be declared as type of message in a message port type
 

module Sem_13_toplevel_declaring_msg_various_types_006{
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort message{
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout hexstring;
        inout octetstring;
        inout charstring;
        inout universal charstring;
        inout CompositeType;
        inout MySet;
        inout MyUnion;
        inout MyEnum;
        inout MyArray;
    }

    type component Sender{
        timer t_timer := 2.0;
        port MyPort src;
    }
    
    type component Receiver{
        port MyPort dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_values := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := "ab", 
        ucs := "the", 
        rec1 := {1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };

    function f_sender() runs on Sender 
    {
        // bitstring        
        t_timer.start;
        src.send(c_values.bs);
        alt {
            [] src.receive(c_values.bs) { setverdict(pass); }
			[] src.receive { 
				setverdict(fail, "Unexpected data, expected bitstring ", c_values.bs); 
				stop; 
			}
			[] t_timer.timeout {
				setverdict(fail, "No response from echo service");
				stop;
			}
        }
    } 
	
	function f_receiver() runs on Receiver 
	{
	    timer t_timer := 30.0;
	    t_timer.start;
	    alt 
	    {
            [] dst.receive(c_values.bs) { setverdict(pass); dst.send(c_values.bs); }
	        
            [] dst.receive { setverdict(fail, "Unexpected messagem expected bitstring", c_values.bs); stop; }
	        [] t_timer.timeout { setverdict(fail, "No more messages"); stop; }
	    }
	} 
	
    testcase TC_Sem_13_toplevel_declaring_msg_various_types_006() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.kill;
    }
    control {
            execute(TC_Sem_13_toplevel_declaring_msg_various_types_006())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:13, Port with type anytype can send and receive messages of any basic or structured type: 'integer' type.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/13 Declaring messages/Any type can be declared as type of message in a message port type
 

module Sem_13_toplevel_declaring_msg_various_types_011{
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort message{
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout hexstring;
        inout octetstring;
        inout charstring;
        inout universal charstring;
        inout CompositeType;
        inout MySet;
        inout MyUnion;
        inout MyEnum;
        inout MyArray;
    }

    type component Sender{
        timer t_timer := 2.0;
        port MyPort src;
    }
    
    type component Receiver{
        port MyPort dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_values := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := "ab", 
        ucs := "the", 
        rec1 := {1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };

    function f_sender() runs on Sender 
    {
        // integer        
        t_timer.start;
        src.send(c_values.i);
        alt {
            [] src.receive(c_values.i) { setverdict(pass); }
			[] src.receive { 
				setverdict(fail, "Unexpected data, expected integer ", c_values.i); 
				stop; 
			}
			[] t_timer.timeout {
				setverdict(fail, "No response from echo service");
				stop;
			}
        }
    } 
	
	function f_receiver() runs on Receiver 
	{
	    timer t_timer := 30.0;
	    t_timer.start;
	    alt 
	    {
            [] dst.receive(c_values.i) { setverdict(pass); dst.send(c_values.i); }
	        
            [] dst.receive { setverdict(fail, "Unexpected messagem expected integer", c_values.i); stop; }
	        [] t_timer.timeout { setverdict(fail, "No more messages"); stop; }
	    }
	} 
	
    testcase TC_Sem_13_toplevel_declaring_msg_various_types_011() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.kill;
    }
    control {
            execute(TC_Sem_13_toplevel_declaring_msg_various_types_011())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:13, Port with type anytype can send and receive messages of any basic or structured type: 'hexstring' type.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/13 Declaring messages/Any type can be declared as type of message in a message port type
 

module Sem_13_toplevel_declaring_msg_various_types_010{
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort message{
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout hexstring;
        inout octetstring;
        inout charstring;
        inout universal charstring;
        inout CompositeType;
        inout MySet;
        inout MyUnion;
        inout MyEnum;
        inout MyArray;
    }

    type component Sender{
        timer t_timer := 2.0;
        port MyPort src;
    }
    
    type component Receiver{
        port MyPort dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_values := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := "ab", 
        ucs := "the", 
        rec1 := {1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };

    function f_sender() runs on Sender 
    {
        // hexstring        
        t_timer.start;
        src.send(c_values.hs);
        alt {
            [] src.receive(c_values.hs) { setverdict(pass); }
			[] src.receive { 
				setverdict(fail, "Unexpected data, expected hexstring ", c_values.hs); 
				stop; 
			}
			[] t_timer.timeout {
				setverdict(fail, "No response from echo service");
				stop;
			}
        }
    } 
	
	function f_receiver() runs on Receiver 
	{
	    timer t_timer := 30.0;
	    t_timer.start;
	    alt 
	    {
            [] dst.receive(c_values.hs) { setverdict(pass); dst.send(c_values.hs); }
	        
            [] dst.receive { setverdict(fail, "Unexpected messagem expected hexstring", c_values.hs); stop; }
	        [] t_timer.timeout { setverdict(fail, "No more messages"); stop; }
	    }
	} 
	
    testcase TC_Sem_13_toplevel_declaring_msg_various_types_010() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.kill;
    }
    control {
            execute(TC_Sem_13_toplevel_declaring_msg_various_types_010())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure instances of messages can be declared and passed via template parameter
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/13 Declaring messages/Sorts of message insances/Template parameter as a message  
 **/


module Sem_13_declaring_msg_008 {
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort1 message{
        out MsgType1;
        in MsgType2;
    }
    type port MyPort2 message{
        out MsgType2;
        in MsgType1;
    }
    type component Sender{
        port MyPort1 src;
    }
    
    type component Receiver{
        port MyPort2 dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_message := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := """ab""", 
        ucs := "the", 
        rec1 := {i:=1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };
	
    template MsgType1 global:= {i := 1, k:=1.0, b:=true, v:=pass, bs:='0101'B, hs:='123ABD'H,
	    os:='FF96'O, cs:="""ab""", ucs:="the", union1 := make_union(), 
	    rec1:={i:=1}, set1:={int1:=1, str1:="the"},
    	enum1:=Bash, arr1:={1,2,3}
    };
    
    function f_sender(template MsgType1 v_template_message) runs on Sender 
    {
        src.send(v_template_message);
    } 
	
	function f_receiver() runs on Receiver 
	{
		var MsgType1 v_message;
	    timer t_timer := 3.0;
	    t_timer.start;
	    alt 
	    {
	        [] dst.receive(global) -> value v_message { setverdict(pass); }
	        [] t_timer.timeout { setverdict(fail); }
	    }
	} 
	
    testcase TC_Sem_13_declaring_msg_008() runs on MTC system MTC
    {
        var template MsgType1 v_template_message := {
            i := 1, k:=1.0, b:=true, v:=pass, 
            bs:='0101'B, hs:='123ABD'H,
            os:='FF96'O, cs:="""ab""", ucs:="the", 
            union1 := make_union(), 
            rec1:={i:=1}, set1:={int1:=1, str1:="the"},
            enum1:=Bash, arr1:={1,2,3}
        };
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender(v_template_message));
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.done;
    }
    control{
        
            execute(TC_Sem_13_declaring_msg_008())
       
        
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:13, Port with type anytype can send and receive messages of any basic or structured type: 'enum' type.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/13 Declaring messages/Any type can be declared as type of message in a message port type
 

module Sem_13_toplevel_declaring_msg_various_types_003{
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort message{
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout hexstring;
        inout octetstring;
        inout charstring;
        inout universal charstring;
        inout CompositeType;
        inout MySet;
        inout MyUnion;
        inout MyEnum;
        inout MyArray;
    }

    type component Sender{
        timer t_timer := 2.0;
        port MyPort src;
    }
    
    type component Receiver{
        port MyPort dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_values := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := "ab", 
        ucs := "the", 
        rec1 := {1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };

    function f_sender() runs on Sender 
    {
        // MyEnum        
        t_timer.start;
        src.send(c_values.enum1);
        alt {
            [] src.receive(c_values.enum1) { setverdict(pass); }
			[] src.receive { 
				setverdict(fail, "Unexpected data, expected MyEnum ", c_values.enum1); 
				stop; 
			}
			[] t_timer.timeout {
				setverdict(fail, "No response from echo service");
				stop;
			}
        }
    } 
	
	function f_receiver() runs on Receiver 
	{
	    timer t_timer := 30.0;
	    t_timer.start;
	    alt 
	    {
            [] dst.receive(c_values.enum1) { setverdict(pass); dst.send(c_values.enum1); }
	        
            [] dst.receive { setverdict(fail, "Unexpected messagem expected MyEnum", c_values.enum1); stop; }
	        [] t_timer.timeout { setverdict(fail, "No more messages"); stop; }
	    }
	} 
	
    testcase TC_Sem_13_toplevel_declaring_msg_various_types_003() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.kill;
    }
    control {
            execute(TC_Sem_13_toplevel_declaring_msg_various_types_003())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:13, Port with type anytype can send and receive messages of any basic or structured type: 'universal charstring' type.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/13 Declaring messages/Any type can be declared as type of message in a message port type
 

module Sem_13_toplevel_declaring_msg_various_types_013{
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort message{
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout hexstring;
        inout octetstring;
        inout charstring;
        inout universal charstring;
        inout CompositeType;
        inout MySet;
        inout MyUnion;
        inout MyEnum;
        inout MyArray;
    }

    type component Sender{
        timer t_timer := 2.0;
        port MyPort src;
    }
    
    type component Receiver{
        port MyPort dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_values := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := "ab", 
        ucs := "the", 
        rec1 := {1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };

    function f_sender() runs on Sender 
    {
        // universal charstring        
        t_timer.start;
        src.send(c_values.ucs);
        alt {
            [] src.receive(c_values.ucs) { setverdict(pass); }
			[] src.receive { 
				setverdict(fail, "Unexpected data, expected universal charstring ", c_values.ucs); 
				stop; 
			}
			[] t_timer.timeout {
				setverdict(fail, "No response from echo service");
				stop;
			}
        }
    } 
	
	function f_receiver() runs on Receiver 
	{
	    timer t_timer := 30.0;
	    t_timer.start;
	    alt 
	    {
            [] dst.receive(c_values.ucs) { setverdict(pass); dst.send(c_values.ucs); }
	        
            [] dst.receive { setverdict(fail, "Unexpected messagem expected universal charstring", c_values.ucs); stop; }
	        [] t_timer.timeout { setverdict(fail, "No more messages"); stop; }
	    }
	} 
	
    testcase TC_Sem_13_toplevel_declaring_msg_various_types_013() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.kill;
    }
    control {
            execute(TC_Sem_13_toplevel_declaring_msg_various_types_013())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:13, Port with type anytype can send and receive messages of any basic or structured type: 'union' type.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/13 Declaring messages/Any type can be declared as type of message in a message port type
 

module Sem_13_toplevel_declaring_msg_various_types_005{
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort message{
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout hexstring;
        inout octetstring;
        inout charstring;
        inout universal charstring;
        inout CompositeType;
        inout MySet;
        inout MyUnion;
        inout MyEnum;
        inout MyArray;
    }

    type component Sender{
        timer t_timer := 2.0;
        port MyPort src;
    }
    
    type component Receiver{
        port MyPort dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_values := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := "ab", 
        ucs := "the", 
        rec1 := {1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };

    function f_sender() runs on Sender 
    {
        // MyUnion        
        t_timer.start;
        src.send(c_values.union1);
        alt {
            [] src.receive(c_values.union1) { setverdict(pass); }
			[] src.receive { 
				setverdict(fail, "Unexpected data, expected MyUnion ", c_values.union1); 
				stop; 
			}
			[] t_timer.timeout {
				setverdict(fail, "No response from echo service");
				stop;
			}
        }
    } 
	
	function f_receiver() runs on Receiver 
	{
	    timer t_timer := 30.0;
	    t_timer.start;
	    alt 
	    {
            [] dst.receive(c_values.union1) { setverdict(pass); dst.send(c_values.union1); }
	        
            [] dst.receive { setverdict(fail, "Unexpected messagem expected MyUnion", c_values.union1); stop; }
	        [] t_timer.timeout { setverdict(fail, "No more messages"); stop; }
	    }
	} 
	
    testcase TC_Sem_13_toplevel_declaring_msg_various_types_005() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.kill;
    }
    control {
            execute(TC_Sem_13_toplevel_declaring_msg_various_types_005())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:13, Port with type anytype can send and receive messages of any basic or structured type: 'octetstring' type.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/13 Declaring messages/Any type can be declared as type of message in a message port type
 

module Sem_13_toplevel_declaring_msg_various_types_012{
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort message{
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout hexstring;
        inout octetstring;
        inout charstring;
        inout universal charstring;
        inout CompositeType;
        inout MySet;
        inout MyUnion;
        inout MyEnum;
        inout MyArray;
    }

    type component Sender{
        timer t_timer := 2.0;
        port MyPort src;
    }
    
    type component Receiver{
        port MyPort dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_values := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := "ab", 
        ucs := "the", 
        rec1 := {1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };

    function f_sender() runs on Sender 
    {
        // octetstring        
        t_timer.start;
        src.send(c_values.os);
        alt {
            [] src.receive(c_values.os) { setverdict(pass); }
			[] src.receive { 
				setverdict(fail, "Unexpected data, expected octetstring ", c_values.os); 
				stop; 
			}
			[] t_timer.timeout {
				setverdict(fail, "No response from echo service");
				stop;
			}
        }
    } 
	
	function f_receiver() runs on Receiver 
	{
	    timer t_timer := 30.0;
	    t_timer.start;
	    alt 
	    {
            [] dst.receive(c_values.os) { setverdict(pass); dst.send(c_values.os); }
	        
            [] dst.receive { setverdict(fail, "Unexpected messagem expected octetstring", c_values.os); stop; }
	        [] t_timer.timeout { setverdict(fail, "No more messages"); stop; }
	    }
	} 
	
    testcase TC_Sem_13_toplevel_declaring_msg_various_types_012() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.kill;
    }
    control {
            execute(TC_Sem_13_toplevel_declaring_msg_various_types_012())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure instances of messages can be declared and passed via template parameter
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/13 Declaring messages/Sorts of message insances/Local template as a message
 **/


module Sem_13_declaring_msg_009 {
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort1 message{
        out MsgType1;
        in MsgType2;
    }
    type port MyPort2 message{
        out MsgType2;
        in MsgType1;
    }
    type component Sender{
        port MyPort1 src;
    }
    
    type component Receiver{
        port MyPort2 dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_message := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := """ab""", 
        ucs := "the", 
        rec1 := {i:=1},
        set1 := {int1:=1, str1:="the"}, 
       union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };
	
    template MsgType1 global:= {i := 1, k:=1.0, b:=true, v:=pass, bs:='0101'B, hs:='123ABD'H,
	    os:='FF96'O, cs:="""ab""", ucs:="the", union1 := make_union(), 
	    rec1:={i:=1}, set1:={int1:=1, str1:="the"},
    	enum1:=Bash, arr1:={1,2,3}
    };
    
    function f_sender() runs on Sender 
    {
        template MsgType1 v_template_message := {
            i := 1, k:=1.0, b:=true, v:=pass, 
            bs:='0101'B, hs:='123ABD'H,
            os:='FF96'O, cs:="""ab""", ucs:="the", 
            union1 := make_union(), 
            rec1:={i:=1}, set1:={int1:=1, str1:="the"},
            enum1:=Bash, arr1:={1,2,3}
        };
        src.send(v_template_message);
    } 
	
	function f_receiver() runs on Receiver 
	{
		var MsgType1 v_message;
	    timer t_timer := 3.0;
	    t_timer.start;
	    alt 
	    {
	        [] dst.receive(global) -> value v_message { setverdict(pass); }
	        [] t_timer.timeout { setverdict(fail); }
	    }
	} 
	
    testcase TC_Sem_13_declaring_msg_009() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.done;
    }
    control {
            execute(TC_Sem_13_declaring_msg_009())
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:13, Port with type anytype can send and receive messages of any basic or structured type: 'record of' type.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/13 Declaring messages/Any type can be declared as type of message in a message port type
 

module Sem_13_toplevel_declaring_msg_various_types_002{
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort message{
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout hexstring;
        inout octetstring;
        inout charstring;
        inout universal charstring;
        inout CompositeType;
        inout MySet;
        inout MyUnion;
        inout MyEnum;
        inout MyArray;
    }

    type component Sender{
        timer t_timer := 2.0;
        port MyPort src;
    }
    
    type component Receiver{
        port MyPort dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_values := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := "ab", 
        ucs := "the", 
        rec1 := {1},
        set1 := {int1:=1, str1:="the"}, 
       union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };

    function f_sender() runs on Sender 
    {
        // MyArray        
        t_timer.start;
        src.send(c_values.arr1);
        alt {
            [] src.receive(c_values.arr1) { setverdict(pass); }
			[] src.receive { 
				setverdict(fail, "Unexpected data, expected MyArray ", c_values.arr1); 
				stop; 
			}
			[] t_timer.timeout {
				setverdict(fail, "No response from echo service");
				stop;
			}
        }
    } 
	
	function f_receiver() runs on Receiver 
	{
	    timer t_timer := 30.0;
	    t_timer.start;
	    alt 
	    {
            [] dst.receive(c_values.arr1) { setverdict(pass); dst.send(c_values.arr1); }
	        
            [] dst.receive { setverdict(fail, "Unexpected messagem expected MyArray", c_values.arr1); stop; }
	        [] t_timer.timeout { setverdict(fail, "No more messages"); stop; }
	    }
	} 
	
    testcase TC_Sem_13_toplevel_declaring_msg_various_types_002() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.kill;
    }
    control {
            execute(TC_Sem_13_toplevel_declaring_msg_various_types_002())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:13, Port with type anytype can send and receive messages of any basic or structured type: 'record' type.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/13 Declaring messages/Any type can be declared as type of message in a message port type
 

module Sem_13_toplevel_declaring_msg_various_types_001{
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort message{
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout hexstring;
        inout octetstring;
        inout charstring;
        inout universal charstring;
        inout CompositeType;
        inout MySet;
        inout MyUnion;
        inout MyEnum;
        inout MyArray;
    }

    type component Sender{
        timer t_timer := 2.0;
        port MyPort src;
    }
    
    type component Receiver{
        port MyPort dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_values := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := "ab", 
        ucs := "the", 
        rec1 := {1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };

    function f_sender() runs on Sender 
    {
        // CompositeType        
        t_timer.start;
        src.send(c_values.rec1);
        alt {
            [] src.receive(c_values.rec1) { setverdict(pass); }
			[] src.receive { 
				setverdict(fail, "Unexpected data, expected CompositeType ", c_values.rec1); 
				stop; 
			}
			[] t_timer.timeout {
				setverdict(fail, "No response from echo service");
				stop;
			}
        }
    } 
	
	function f_receiver() runs on Receiver 
	{
	    timer t_timer := 30.0;
	    t_timer.start;
	    alt 
	    {
            [] dst.receive(c_values.rec1) { setverdict(pass); dst.send(c_values.rec1); }
	        
            [] dst.receive { setverdict(fail, "Unexpected messagem expected CompositeType", c_values.rec1); stop; }
	        [] t_timer.timeout { setverdict(fail, "No more messages"); stop; }
	    }
	} 
	
    testcase TC_Sem_13_toplevel_declaring_msg_various_types_001() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.kill;
    }
    control {
            execute(TC_Sem_13_toplevel_declaring_msg_various_types_001())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:13, Port with type anytype can send and receive messages of any basic or structured type: 'float' type.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/13 Declaring messages/Any type can be declared as type of message in a message port type
 

module Sem_13_toplevel_declaring_msg_various_types_009{
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort message{
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout hexstring;
        inout octetstring;
        inout charstring;
        inout universal charstring;
        inout CompositeType;
        inout MySet;
        inout MyUnion;
        inout MyEnum;
        inout MyArray;
    }

    type component Sender{
        timer t_timer := 2.0;
        port MyPort src;
    }
    
    type component Receiver{
        port MyPort dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_values := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := "ab", 
        ucs := "the", 
        rec1 := {1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };

    function f_sender() runs on Sender 
    {
        // float        
        t_timer.start;
        src.send(c_values.k);
        alt {
            [] src.receive(c_values.k) { setverdict(pass); }
			[] src.receive { 
				setverdict(fail, "Unexpected data, expected float ", c_values.k); 
				stop; 
			}
			[] t_timer.timeout {
				setverdict(fail, "No response from echo service");
				stop;
			}
        }
    } 
	
	function f_receiver() runs on Receiver 
	{
	    timer t_timer := 30.0;
	    t_timer.start;
	    alt 
	    {
            [] dst.receive(c_values.k) { setverdict(pass); dst.send(c_values.k); }
	        
            [] dst.receive { setverdict(fail, "Unexpected messagem expected float", c_values.k); stop; }
	        [] t_timer.timeout { setverdict(fail, "No more messages"); stop; }
	    }
	} 
	
    testcase TC_Sem_13_toplevel_declaring_msg_various_types_009() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.kill;
    }
    control {
            execute(TC_Sem_13_toplevel_declaring_msg_various_types_009())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:13, Port with type anytype can send and receive messages of any basic or structured type: 'verdicttype' type.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/13 Declaring messages/Any type can be declared as type of message in a message port type
 

module Sem_13_toplevel_declaring_msg_various_types_014{
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort message{
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout hexstring;
        inout octetstring;
        inout charstring;
        inout universal charstring;
        inout CompositeType;
        inout MySet;
        inout MyUnion;
        inout MyEnum;
        inout MyArray;
    }

    type component Sender{
        timer t_timer := 2.0;
        port MyPort src;
    }
    
    type component Receiver{
        port MyPort dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_values := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := "ab", 
        ucs := "the", 
        rec1 := {1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };

    function f_sender() runs on Sender 
    {
        // verdicttype        
        t_timer.start;
        src.send(c_values.v);
        alt {
            [] src.receive(c_values.v) { setverdict(pass); }
			[] src.receive { 
				setverdict(fail, "Unexpected data, expected verdicttype ", c_values.v); 
				stop; 
			}
			[] t_timer.timeout {
				setverdict(fail, "No response from echo service");
				stop;
			}
        }
    } 
	
	function f_receiver() runs on Receiver 
	{
	    timer t_timer := 30.0;
	    t_timer.start;
	    alt 
	    {
            [] dst.receive(c_values.v) { setverdict(pass); dst.send(c_values.v); }
	        
            [] dst.receive { setverdict(fail, "Unexpected messagem expected verdicttype", c_values.v); stop; }
	        [] t_timer.timeout { setverdict(fail, "No more messages"); stop; }
	    }
	} 
	
    testcase TC_Sem_13_toplevel_declaring_msg_various_types_014() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.kill;
    }
    control {
            execute(TC_Sem_13_toplevel_declaring_msg_various_types_014())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:13, Port with type anytype can send and receive messages of any basic or structured type: 'boolean' type.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/13 Declaring messages/Any type can be declared as type of message in a message port type
 

module Sem_13_toplevel_declaring_msg_various_types_007{
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort message{
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout hexstring;
        inout octetstring;
        inout charstring;
        inout universal charstring;
        inout CompositeType;
        inout MySet;
        inout MyUnion;
        inout MyEnum;
        inout MyArray;
    }

    type component Sender{
        timer t_timer := 2.0;
        port MyPort src;
    }
    
    type component Receiver{
        port MyPort dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_values := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := "ab", 
        ucs := "the", 
        rec1 := {1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };

    function f_sender() runs on Sender 
    {
        // boolean        
        t_timer.start;
        src.send(c_values.b);
        alt {
            [] src.receive(c_values.b) { setverdict(pass); }
			[] src.receive { 
				setverdict(fail, "Unexpected data, expected boolean ", c_values.b); 
				stop; 
			}
			[] t_timer.timeout {
				setverdict(fail, "No response from echo service");
				stop;
			}
        }
    } 
	
	function f_receiver() runs on Receiver 
	{
	    timer t_timer := 30.0;
	    t_timer.start;
	    alt 
	    {
            [] dst.receive(c_values.b) { setverdict(pass); dst.send(c_values.b); }
	        
            [] dst.receive { setverdict(fail, "Unexpected messagem expected boolean", c_values.b); stop; }
	        [] t_timer.timeout { setverdict(fail, "No more messages"); stop; }
	    }
	} 
	
    testcase TC_Sem_13_toplevel_declaring_msg_various_types_007() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.kill;
    }
    control {
            execute(TC_Sem_13_toplevel_declaring_msg_various_types_007())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:13, Port with type anytype can send and receive messages of any basic or structured type: 'set' type.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/13 Declaring messages/Any type can be declared as type of message in a message port type
 

module Sem_13_toplevel_declaring_msg_various_types_004{
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort message{
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout hexstring;
        inout octetstring;
        inout charstring;
        inout universal charstring;
        inout CompositeType;
        inout MySet;
        inout MyUnion;
        inout MyEnum;
        inout MyArray;
    }

    type component Sender{
        timer t_timer := 2.0;
        port MyPort src;
    }
    
    type component Receiver{
        port MyPort dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_values := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := "ab", 
        ucs := "the", 
        rec1 := {1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };

    function f_sender() runs on Sender 
    {
        // MySet        
        t_timer.start;
        src.send(c_values.set1);
        alt {
            [] src.receive(c_values.set1) { setverdict(pass); }
			[] src.receive { 
				setverdict(fail, "Unexpected data, expected MySet ", c_values.set1); 
				stop; 
			}
			[] t_timer.timeout {
				setverdict(fail, "No response from echo service");
				stop;
			}
        }
    } 
	
	function f_receiver() runs on Receiver 
	{
	    timer t_timer := 30.0;
	    t_timer.start;
	    alt 
	    {
            [] dst.receive(c_values.set1) { setverdict(pass); dst.send(c_values.set1); }
	        
            [] dst.receive { setverdict(fail, "Unexpected messagem expected MySet", c_values.set1); stop; }
	        [] t_timer.timeout { setverdict(fail, "No more messages"); stop; }
	    }
	} 
	
    testcase TC_Sem_13_toplevel_declaring_msg_various_types_004() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.kill;
    }
    control {
            execute(TC_Sem_13_toplevel_declaring_msg_various_types_004())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure instances of messages can be declared and passed via parameter
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/13 Declaring messages/Sorts of message insances/Parameter as a message
 **/


module Sem_13_declaring_msg_007 {
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort1 message{
        out MsgType1;
        in MsgType2;
    }
    type port MyPort2 message{
        out MsgType2;
        in MsgType1;
    }
    type component Sender{
        port MyPort1 src;
    }
    
    type component Receiver{
        port MyPort2 dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_message := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := """ab""", 
        ucs := "the", 
        rec1 := {i:=1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };
	
    template MsgType1 global:= {i := 1, k:=1.0, b:=true, v:=pass, bs:='0101'B, hs:='123ABD'H,
	    os:='FF96'O, cs:="""ab""", ucs:="the", union1 := make_union(), 
	    rec1:={i:=1}, set1:={int1:=1, str1:="the"},
    	enum1:=Bash, arr1:={1,2,3}
    };
    
    function f_sender(in MsgType1 v_message) runs on Sender 
    {
        src.send(v_message);
    } 
	
	function f_receiver() runs on Receiver 
	{
		var MsgType1 v_message;
	    timer t_timer := 3.0;
	    t_timer.start;
	    alt 
	    {
	        [] dst.receive(global) -> value v_message { setverdict(pass); }
	        [] t_timer.timeout { setverdict(fail); }
	    }
	} 
	
    testcase TC_Sem_13_declaring_msg_007() runs on MTC system MTC
    {
        var MsgType1 v_message := {
            i := 1, k:=1.0, b:=true, v:=pass, 
            bs:='0101'B, hs:='123ABD'H,
            os:='FF96'O, cs:="""ab""", ucs:="the", 
            union1 := make_union(), 
            rec1:={i:=1}, set1:={int1:=1, str1:="the"},
            enum1:=Bash, arr1:={1,2,3}
        };
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender(v_message));
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.done;
    }
    control{
        
            execute(TC_Sem_13_declaring_msg_007())
       
        
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure instances of messages can be declared by global templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/13 Declaring messages/Sorts of message insances/Global template as a message
 **/


module Sem_13_declaring_msg_004 {
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort1 message{
        out MsgType1;
        in MsgType2;
    }
    type port MyPort2 message{
        out MsgType2;
        in MsgType1;
    }
    type component Sender{
        port MyPort1 src;
    }
    
    type component Receiver{
        port MyPort2 dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_message := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := """ab""", 
        ucs := "the", 
        rec1 := {i:=1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };
	
	template MsgType1 global:= {i := 1, k:=1.0, b:=true, v:=pass, bs:='0101'B, hs:='123ABD'H,
    	os:='FF96'O, cs:="""ab""", ucs:="the", union1 := make_union(), rec1:={i:=1}, set1:={int1:=1, str1:="the"},
    	enum1:=Bash, arr1:={1,2,3}
    };
    
	
    function f_sender() runs on Sender 
    {
        src.send(global);
    } 
	
	function f_receiver() runs on Receiver 
	{
    	template MsgType1 local:= {i := 1, k:=1.0, b:=true, v:=pass, bs:='0101'B, hs:='123ABD'H,
        	os:='FF96'O, cs:="""ab""", ucs:="the", union1 := ?, rec1:={i:=1}, set1:={int1:=1, str1:="the"},
        	enum1:=Bash, arr1:={1,2,3}
        };
	    timer t_timer := 3.0;
	    t_timer.start;
	    alt 
	    {
	        [] dst.receive(local) { setverdict(pass); }
	        [] t_timer.timeout { setverdict(fail, "Failed to match global template"); }
	    }
	} 
	
    testcase TC_Sem_13_declaring_msg_004() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.done;
    }
    control{
        
            execute(TC_Sem_13_declaring_msg_004())
       
        
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure instances of messages can be declared and passed via inline template
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/13 Declaring messages/Sorts of message insances/Inline template as a message  
 **/


module Sem_13_declaring_msg_006 {
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort1 message{
        out MsgType1;
        in MsgType2;
    }
    type port MyPort2 message{
        out MsgType2;
        in MsgType1;
    }
    type component Sender{
        port MyPort1 src;
    }
    
    type component Receiver{
        port MyPort2 dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_message := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := """ab""", 
        ucs := "the", 
        rec1 := {i:=1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };
	
    template MsgType1 global:= {i := 1, k:=1.0, b:=true, v:=pass, bs:='0101'B, hs:='123ABD'H,
	    os:='FF96'O, cs:="""ab""", ucs:="the", union1 := make_union(), 
	    rec1:={i:=1}, set1:={int1:=1, str1:="the"},
    	enum1:=Bash, arr1:={1,2,3}
    };
    
    function f_sender() runs on Sender 
    {
        src.send(MsgType1:{
	        i := 1, k:=1.0, b:=true, v:=pass, 
            bs:='0101'B, hs:='123ABD'H,
            os:='FF96'O, cs:="""ab""", ucs:="the", 
            union1 := make_union(), 
            rec1:={i:=1}, set1:={int1:=1, str1:="the"},
            enum1:=Bash, arr1:={1,2,3}
        });
    } 
	
	function f_receiver() runs on Receiver 
	{
		var MsgType1 v_message;
	    timer t_timer := 3.0;
	    t_timer.start;
	    alt 
	    {
	        [] dst.receive(global) -> value v_message { setverdict(pass); }
	        [] t_timer.timeout { setverdict(fail); }
	    }
	} 
	
    testcase TC_Sem_13_declaring_msg_006() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.done;
    }
    control{
        
            execute(TC_Sem_13_declaring_msg_006())
       
        
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure instances of messages can be declared and passed via template variables
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/13 Declaring messages/Sorts of message insances/Template variable as a message
 **/


module Sem_13_declaring_msg_005 {
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort1 message{
        out MsgType1;
        in MsgType2;
    }
    type port MyPort2 message{
        out MsgType2;
        in MsgType1;
    }
    type component Sender{
        port MyPort1 src;
    }
    
    type component Receiver{
        port MyPort2 dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_message := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := """ab""", 
        ucs := "the", 
        rec1 := {i:=1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };
	
    template MsgType1 global:= {i := 1, k:=1.0, b:=true, v:=pass, bs:='0101'B, hs:='123ABD'H,
	    os:='FF96'O, cs:="""ab""", ucs:="the", union1 := make_union(), 
	    rec1:={i:=1}, set1:={int1:=1, str1:="the"},
    	enum1:=Bash, arr1:={1,2,3}
    };
    
    function f_sender() runs on Sender 
    {
		var template MsgType1 template_var:= {
		    i := 1, k:=1.0, b:=true, v:=pass, 
		    bs:='0101'B, hs:='123ABD'H,
        	os:='FF96'O, cs:="""ab""", ucs:="the", 
        	union1 := make_union(), 
        	rec1:={i:=1}, set1:={int1:=1, str1:="the"},
        	enum1:=Bash, arr1:={1,2,3}
    	};
		
        src.send(template_var);
    } 
	
	function f_receiver() runs on Receiver 
	{
		var MsgType1 v_message;
	    timer t_timer := 3.0;
	    t_timer.start;
	    alt 
	    {
	        [] dst.receive(global) -> value v_message { setverdict(pass); }
	        [] t_timer.timeout { setverdict(fail); }
	    }
	} 
	
    testcase TC_Sem_13_declaring_msg_005() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.done;
    }
    control{
        
            execute(TC_Sem_13_declaring_msg_005())
       
        
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:13, Port with type anytype can send and receive messages of any basic or structured type: 'charstring' type.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/13 Declaring messages/Any type can be declared as type of message in a message port type
 

module Sem_13_toplevel_declaring_msg_various_types_008{
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort message{
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout hexstring;
        inout octetstring;
        inout charstring;
        inout universal charstring;
        inout CompositeType;
        inout MySet;
        inout MyUnion;
        inout MyEnum;
        inout MyArray;
    }

    type component Sender{
        timer t_timer := 2.0;
        port MyPort src;
    }
    
    type component Receiver{
        port MyPort dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_values := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := "ab", 
        ucs := "the", 
        rec1 := {1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };

    function f_sender() runs on Sender 
    {
        // charstring        
        t_timer.start;
        src.send(c_values.cs);
        alt {
            [] src.receive(c_values.cs) { setverdict(pass); }
			[] src.receive { 
				setverdict(fail, "Unexpected data, expected charstring ", c_values.cs); 
				stop; 
			}
			[] t_timer.timeout {
				setverdict(fail, "No response from echo service");
				stop;
			}
        }
    } 
	
	function f_receiver() runs on Receiver 
	{
	    timer t_timer := 30.0;
	    t_timer.start;
	    alt 
	    {
            [] dst.receive(c_values.cs) { setverdict(pass); dst.send(c_values.cs); }
	        
            [] dst.receive { setverdict(fail, "Unexpected messagem expected charstring", c_values.cs); stop; }
	        [] t_timer.timeout { setverdict(fail, "No more messages"); stop; }
	    }
	} 
	
    testcase TC_Sem_13_toplevel_declaring_msg_various_types_008() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.kill;
    }
    control {
            execute(TC_Sem_13_toplevel_declaring_msg_various_types_008())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure instances of messages can be declared by in-line templates
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/13 Declaring messages/Sorts of message insances/Variable as a message
 **/


module Sem_13_declaring_msg_003 {
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort1 message{
        out MsgType1;
        in MsgType2;
    }
    type port MyPort2 message{
        out MsgType2;
        in MsgType1;
    }
    type component Sender{
        port MyPort1 src;
    }
    
    type component Receiver{
        port MyPort2 dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_message := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := """ab""", 
        ucs := "the", 
        rec1 := {i:=1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };
	
    function f_sender() runs on Sender 
    {
        var MsgType1 msg1 := c_message;
        src.send(msg1);
    } 
		
	function f_receiver() runs on Receiver 
	{
		var MsgType1 v_message;
	    timer t_timer := 3.0;
	    t_timer.start;
	    alt 
	    {
	        [] dst.receive(MsgType1: {1, 1.0, true, pass, '0101'B, '123ABD'H, 'FF96'O,
            """ab""", "the", {i:=1}, {int1:=1, str1:="the"}, make_union(), Bash, {1,2,3}})
            -> value v_message
	        { 
	            setverdict(pass); 
	        }
	        [] t_timer.timeout { setverdict(fail, "The template failed to match the message"); }
	    }
	} 
	
    testcase TC_Sem_13_declaring_msg_003() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.done;
    }
    control{
        
            execute(TC_Sem_13_declaring_msg_003())
       
        
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure received messages can be a combination of value and matching mechanism
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/13 Declaring messages/Messages are instances of types declared in the in-out-inout clauses of message port type definition
 **/
/*
 * #reqname  /Requirements/13 Declaring messages/Received messages can also be declared as a combination of value and matching mechanisms
 **/
/*
 * #reqname  /Requirements/13 Declaring messages/Sorts of message insances/Variable as a message
 **/


module Sem_13_declaring_msg_001 {
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort1 message{
	    out MsgType1;
        in MsgType2;
    }
    type port MyPort2 message{
        out MsgType2;
        in MsgType1;
    }
    type component Sender{
        port MyPort1 src;
    }
    
    type component Receiver{
        port MyPort2 dst;
    }
	type component MTC {}
	   
	function make_union() return MyUnion
	{
        var MyUnion result;
        result.int := 1;
        return result;
	}
	
	const MsgType1 c_message := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := """ab""", 
        ucs := "the", 
        rec1 := {i:=1},
        set1 := {int1:=1, str1:="the"}, 
        union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };
	
    function f_sender() runs on Sender 
    {
        var MsgType1 msg1 := c_message;
        src.send(msg1);
    } 
	
	function f_receiver() runs on Receiver 
	{
	    template MsgType1 t_msg := {
	        i := 1, 
	        k:=1.0, 
	        b:=true, 
	        v:=pass, 
	        bs:='0101'B, 
	        hs:='123ABD'H,
	        os:='FF96'O, 
	        cs:="""ab""", 
	        ucs:="the", 
	        rec1:={i:=1}, 
	        set1:={int1:=1, str1:="the"}, 
	        union1:=make_union(),
	        enum1:=Bash, 
	        arr1:={1,2,3}};
	        
		var MsgType1 v_message;
		
	    timer t_timer := 3.0;
	    t_timer.start;
	    alt 
	    {
	        [] dst.receive(t_msg) -> value v_message { setverdict(pass); }
	        [] t_timer.timeout { setverdict(fail, "The template failed to match the message"); }
	    }
	} 
	
    testcase TC_Sem_13_declaring_msg_001() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.done;
    }
    control{
        
            execute(TC_Sem_13_declaring_msg_001())
       
        
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure received messages can`t be matched with wrong template
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/13 Declaring messages/Received messages can also be declared as a combination of value and matching mechanisms
 **/


module Sem_13_declaring_msg_002 {
    type record CompositeType{
        integer i
    }
    type set MySet{
        integer int1,
        charstring str1
    }
    type enumerated MyEnum{
        Perl,Bash,Python
    }
    type integer MyArray[3];
    type union MyUnion{
        integer int,
        float real
    }
    type record MsgType1{
        integer i,
        float k,
        boolean b,
        verdicttype v,
        bitstring bs,
        hexstring hs,
        octetstring os,
        charstring cs,
        universal charstring ucs,
        CompositeType rec1,
        MySet set1,
        MyUnion union1,
        MyEnum enum1,
        MyArray arr1
    }
    type record MsgType2{
            integer j
    }

    type port MyPort1 message{
        out MsgType1;
        in MsgType2;
    }
    type port MyPort2 message{
        out MsgType2;
        in MsgType1;
    }
    type component Sender{
        port MyPort1 src;
    }
    
    type component Receiver{
        port MyPort2 dst;
    }
    type component MTC {}
	   
    function make_union() return MyUnion
    {
        var MyUnion result;
        result.int := 1;
        return result;
    }
	
    const MsgType1 c_message := {
        i := 1, 
        k := 1.0, 
        b := true, 
        v := pass, 
        bs := '0101'B, 
        hs := '123ABD'H, 
        os := 'FF96'O,
        cs := """ab""", 
        ucs := "the", 
        rec1 := {i:=1},
        set1 := {int1:=1, str1:="the"}, 
       union1 := make_union(), 
        enum1 := Bash, 
        arr1 := {1,2,3}
    };
	
    function f_sender() runs on Sender 
    {
        var MsgType1 msg1 := c_message;
        src.send(msg1);
    } 
		
	function f_receiver() runs on Receiver 
	{
	    // Mismatch in fields i and k 
	    template MsgType1 t_msg := {i := 2, k:=1.3, b:=true, v:=pass, bs:='0101'B, hs:='123ABD'H,
	         os:='FF96'O, cs:="""ab""", ucs:="the", rec1:={i:=1}, set1:={int1:=1, str1:="the"},
	         enum1:=Bash, union1 := ?, arr1:={1,2,3}};
		var MsgType1 v_message;
	    timer t_timer := 3.0;
	    t_timer.start;
	    alt 
	    {
	        [] dst.receive(t_msg) -> value v_message { setverdict(fail, "The template must not match the message"); }
	        [] t_timer.timeout { setverdict(pass); }
	    }
	} 
	
    testcase TC_Sem_13_declaring_msg_002() runs on MTC system MTC
    {
		var Sender c_sender := Sender.create;
		var Receiver c_receiver := Receiver.create;
        connect(c_sender:src, c_receiver:dst);
        c_sender.start(f_sender());
        c_receiver.start(f_receiver());
        c_sender.done;
        c_receiver.done;
    }
    control{
        
            execute(TC_Sem_13_declaring_msg_002())
       
        
    }
}/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.1, Ensure that the IUT correctly handles template matching of character pattern set expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010501_set_expression_001 { 


	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010501_set_expression_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "te[pqrs]t[0-9]",
  field2 := pattern "test[^a-z]", 
  field3 := pattern "[A-Z]est"
 } 

 v_testMessage:=  {  
  field1 := "test1",
  field2 := "test1", 
  field3 := "Test"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010501_set_expression_001());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.1, Ensure that the IUT correctly handles template matching of character pattern set expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010501_set_expression_004 { 


	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010501_set_expression_004() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "te[pqrs]t[0-9]",
  field2 := pattern "test[^a-z]",
  field3 := pattern "[A-Z]est" 	//mismatching small/large caps
 } 

 v_testMessage:=  {  
  field1 := "test1",
  field2 := "test1", 
  field3 := "test"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010501_set_expression_004());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.1, Ensure that the IUT correctly handles template matching of character pattern set expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010501_set_expression_005 { 


	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010501_set_expression_005() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "te[pqrs]t[0-9]",
  field2 := pattern "test[^a-z]",
  field3 := pattern "test[-]string" 	//mismatching literal - separator
 } 

 v_testMessage:=  {  
  field1 := "test1",
  field2 := "test1", 
  field3 := "test string"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010501_set_expression_005());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.1, Ensure that the IUT correctly handles template matching of character pattern set expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010501_set_expression_002 { 


	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010501_set_expression_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "te[pqrs]t[0-9]",	//mismatching set
  field2 := pattern "test[^a-z]", 
  field3 := pattern "[A-Z]est"
 } 

 v_testMessage:=  {  
  field1 := "text1",
  field2 := "test1", 
  field3 := "Test"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010501_set_expression_002());
}

}
 /***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:B.1.5.1, Ensure that the IUT correctly handles template matching of character pattern set expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010501_set_expression_006 { 


	type record MessageType {
  	 universal charstring  	field1, 
  	 universal charstring	field2
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010501_set_expression_006() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "test[\q{0,0,1,113}]",    //accepted \q character is 
  field2 := pattern "test[^\q{0,0,1,113}]"    //accepted characters are: anything execpt 
 } 

 v_testMessage:=  {  
  field1 := "test",
  field2 := "testb"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010501_set_expression_006());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.1, Ensure that the IUT correctly handles template matching of character pattern set expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010501_set_expression_003 { 


	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010501_set_expression_003() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "te[pqrs]t[0-9]",
  field2 := pattern "test[^a-z]", 	//mismatching negation
  field3 := pattern "[A-Z]est"
 } 

 v_testMessage:=  {  
  field1 := "test1",
  field2 := "testx", 
  field3 := "Test"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010501_set_expression_003());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5, Ensure that the IUT correctly handles template matching of character pattern definitions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B0105_toplevel_001 { 


	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3,
  	 charstring  	field4, 
  	 charstring		field5
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B0105_toplevel_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "te?t\?",
  field2 := pattern "test|string", 
  field3 := pattern "test" & " " & "string",
  field4 := pattern "tes\w\b\s\d",
  field5 := pattern "\[\\\]"
 } 

 v_testMessage:=  {  
  field1 := "test?",
  field2 := "string", 
  field3 := "test string",
  field4 := "test 1",
  field5 := "[\]"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B0105_toplevel_001());
}

}
 /***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:B.1.5, Ensure that the IUT correctly handles template quadruple and USI-like syntax matching of character pattern definitions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B0105_toplevel_002 { 


	type record MessageType {
  	 universal charstring  	field1, 
  	 universal charstring	field2,
     universal charstring	field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B0105_toplevel_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "\q{0,0,1,113}",                      //"quadruple" notation for character ""
  field2 := pattern "\q{0,0,1,113}*\q{0,0,1,116}",        //"quadruple" notation for character "" and ""
  field3 := pattern "\q{U0171}"                           // USI like notation for character ""
 }
       
 v_testMessage:=  {  
  field1 := "",
  field2 := "1234",
  field3 := ""
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass,v_testMessage);
     }
     [] messagePort.receive {
        setverdict(fail,"Unexpected decoding result:",v_testMessage);
     }
    }
}

control{
    execute(TC_Sem_B0105_toplevel_002());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.3, Ensure that the IUT correctly handles template matching of character pattern expression multiplicity
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010503_match_n_times_003 { 


	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3,
  	 charstring		field4,
  	 charstring		field5
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010503_match_n_times_003() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "[e-t]#4",
  field2 := pattern "test[e-t]+", 	//mismatching number of characters
  field3 := pattern "[e-t]#(3,5)",
  field4 := pattern "[e-t]#(3,)",
  field5 := pattern "[e-t]#(,5)"
 } 

 v_testMessage:=  {  
  field1 := "test",
  field2 := "test", 
  field3 := "test",
  field4 := "test", 
  field5 := "test"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010503_match_n_times_003());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.3, Ensure that the IUT correctly handles template matching of character pattern expression multiplicity
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010503_match_n_times_001 { 


	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3,
  	 charstring		field4,
  	 charstring		field5
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010503_match_n_times_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "[e-t]#4",
  field2 := pattern "[e-t]+", 
  field3 := pattern "[e-t]#(3,5)",
  field4 := pattern "[e-t]#(3,)",
  field5 := pattern "[e-t]#(,5)"
 } 

 v_testMessage:=  {  
  field1 := "test",
  field2 := "test", 
  field3 := "test",
  field4 := "test", 
  field5 := "test"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010503_match_n_times_001());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.3, Ensure that the IUT correctly handles template matching of character pattern expression multiplicity
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010503_match_n_times_005 { 


	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3,
  	 charstring		field4,
  	 charstring		field5
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010503_match_n_times_005() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "[e-t]#4",
  field2 := pattern "test[e-t]+",
  field3 := pattern "[e-t]#(3,5)",
  field4 := pattern "[e-t]#(3,)",
  field5 := pattern "[e-t]#(,3)" 	//mismatching number of characters
 } 

 v_testMessage:=  {  
  field1 := "test",
  field2 := "test", 
  field3 := "test",
  field4 := "test", 
  field5 := "test"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010503_match_n_times_005());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.3, Ensure that the IUT correctly handles template matching of character pattern expression multiplicity
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010503_match_n_times_004 { 


	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3,
  	 charstring		field4,
  	 charstring		field5
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010503_match_n_times_004() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "[e-t]#4",
  field2 := pattern "test[e-t]+",
  field3 := pattern "[e-t]#(3,5)",
  field4 := pattern "[e-t]#(5,)", 	//mismatching number of characters
  field5 := pattern "[e-t]#(,5)"
 } 

 v_testMessage:=  {  
  field1 := "test",
  field2 := "test", 
  field3 := "test",
  field4 := "test", 
  field5 := "test"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010503_match_n_times_004());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.3, Ensure that the IUT correctly handles template matching of character pattern expression multiplicity
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010503_match_n_times_002 { 


	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3,
  	 charstring		field4,
  	 charstring		field5
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010503_match_n_times_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "[e-t]#5",	//mismatching number of characters
  field2 := pattern "[e-t]+", 
  field3 := pattern "[e-t]#(3,5)",
  field4 := pattern "[e-t]#(3,)",
  field5 := pattern "[e-t]#(,5)"
 } 

 v_testMessage:=  {  
  field1 := "test",
  field2 := "test", 
  field3 := "test",
  field4 := "test", 
  field5 := "test"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010503_match_n_times_002());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.5, Ensure that the IUT correctly handles character pattern compatibility rules of template matching
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010505_pattern_compatibility_001 { 

    modulepar {
     charstring MOD_REF:="modulepar reference";
    }

    type record MessageType {
     universal charstring  		field1, 
     universal charstring		field2,
     universal charstring		field3,
     universal charstring  		field4, 
     universal charstring		field5,
     universal charstring		field6,
     universal charstring		field7
    }

    type port loopbackPort message {
      inout MessageType
    }
	
    const charstring c_Ref:="constant reference";
	

type component GeneralComp {	    	    
      port loopbackPort messagePort
}	

testcase TC_Sem_B010505_pattern_compatibility_001(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="variable reference";
    template charstring m_Ref:= pattern "{c_Ref}";
    template charstring m_RefExp_p1 := "{m_";  
    template charstring m_RefExp_p2 := "Ref}!";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "{v_Ref}",
  field2 := pattern "{c_Ref}", 
  field3 := pattern "{MOD_REF}",
  field4 := pattern "{p_Ref}",
  field5 := pattern "{m_Ref}",
  field6 := pattern "{m_"&"Ref}!",
  field7 := pattern "{m_RefExp_p1}{m_RefExp_p2}"
 } 

 v_testMessage:=  {  
  field1 := "variable reference",
  field2 := "constant reference", 
  field3 := "modulepar reference",
  field4 := "parameter reference",
  field5 := "constant reference",
  field6 := "constant reference!",
  field7 := "{m_Ref}!"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010505_pattern_compatibility_001("parameter reference"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.5, Ensure that the IUT correctly handles character pattern compatibility rules of template matching
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010505_pattern_compatibility_002 { 

    modulepar {
     universal charstring MOD_REF:="modulepar reference";
    }

    type record MessageType {
     charstring  		field1, 
     charstring		field2,
     charstring		field3,
     charstring  		field4, 
     charstring		field5,
     charstring		field6,
     charstring		field7
    }

    type port loopbackPort message {
      inout MessageType
    }

    const universal charstring c_Ref:="constant reference";
	

type component GeneralComp {	    	    
      port loopbackPort messagePort
}	

testcase TC_Sem_B010505_pattern_compatibility_002(universal charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var universal charstring v_Ref:="variable reference";
    template universal charstring m_Ref:= pattern "{c_Ref}";
    template universal charstring m_RefExp_p1 := pattern "{m_";  
    template universal charstring m_RefExp_p2 := pattern "Ref}!";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "{v_Ref}",
  field2 := pattern "{c_Ref}", 
  field3 := pattern "{MOD_REF}",
  field4 := pattern "{p_Ref}",
  field5 := pattern "{m_Ref}",
  field6 := pattern "{m_"&"Ref}!",
  field7 := pattern "{m_RefExp_p1}{m_RefExp_p2}"
 } 

 v_testMessage:=  {  
  field1 := "variable reference",
  field2 := "constant reference", 
  field3 := "modulepar reference",
  field4 := "parameter reference",
  field5 := "constant reference",
  field6 := "constant reference!",
  field7 := "{m_Ref}!"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010505_pattern_compatibility_002("parameter reference"));
}

}
 /***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:B.1.5.6, Ensure that the IUT correctly handles character pattern compatibility rules of template case sensitive matching (@nocase) 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
When the "@nocase" modifier is used after the pattern keyword, the matching is evaluated in a case insensitive way
*/

module Sem_B010506_case_sensitive_pattern_matching_001 { 
    
    modulepar {
     charstring MOD_REF:="modulepar reference";
    }

    type record MessageType {
     universal charstring  		field1, 
     universal charstring		field2,
     universal charstring		field3,
     universal charstring  		field4, 
     universal charstring		field5,
     universal charstring		field6,
     universal charstring		field7,
     universal charstring       field8
    }

    type port loopbackPort message {
      inout MessageType
    }
	
    const charstring c_Ref:="constant reference";
	

type component GeneralComp {	    	    
      port loopbackPort messagePort
}	

testcase TC_Sem_B010506_case_sensitive_pattern_matching_001(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="variable reference";
    template charstring m_Ref:= pattern "{c_Ref}";
    template charstring m_RefExp_p1 := "{m_";  
    template charstring m_RefExp_p2 := "Ref}!";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern @nocase "{v_Ref}",
  field2 := pattern @nocase"{c_Ref}", 
  field3 := pattern @nocase"{MOD_REF}",
  field4 := pattern @nocase"{p_Ref}",
  field5 := pattern @nocase"{m_Ref}",
  field6 := pattern @nocase"{m_"&"Ref}!",
  field7 := pattern @nocase"{m_RefExp_p1}{m_RefExp_p2}",
  field8 := pattern @nocase"var*?e"
 } 

 v_testMessage:=  {  
  field1 := "VaRiAbLe ReFeReNcE",
  field2 := "conSTant ReFeReNcE", 
  field3 := "modulepar ReFeReNcE",
  field4 := "PARAMETER ReFeReNcE",
  field5 := "CONStant ReFeReNcE",
  field6 := "consTANT ReFeReNcE!",
  field7 := "{m_ref}!",
  field8 := "VaRiAbLe ReFeReNcE"
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass,v_testMessage);
     }
     [] messagePort.receive {
        setverdict(fail,v_testMessage);
     }
    }
}

control{
    execute(TC_Sem_B010506_case_sensitive_pattern_matching_001("parameter reference"));
}

}
 /***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:B.1.5.6, Ensure that the IUT correctly handles character pattern compatibility rules of template case sensitive matching (@nocase) 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
When the "@nocase" modifier is used after the pattern keyword, the matching is evaluated in a case insensitive way
*/

module Sem_B010506_case_sensitive_pattern_matching_002 { 
    

    type record MessageType {
     universal charstring  		field1, 
     universal charstring		field2
    }

    type port loopbackPort message {
      inout MessageType
    }

type component GeneralComp {	    	    
      port loopbackPort messagePort
}	
    const universal charstring MyCons :="A"; 
    
testcase TC_Sem_B010506_case_sensitive_pattern_matching_002(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    template charstring m_Ref:= pattern "abc";
  
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern @nocase "{m_Ref} \q{0,0,1,113}",        // expected value: abc 
  field2 := pattern @nocase "\N{MyCons}"                    // expected value: A
 } 

 v_testMessage:=  {  
  field1 := "aBc ",        // with @nocase - this is also valid
  field2 := "a"             // with @nocase - this is also valid
 }     
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass,v_testMessage);
     }
     [] messagePort.receive {
        setverdict(fail,v_testMessage);
     }
    }
}

control{
    execute(TC_Sem_B010506_case_sensitive_pattern_matching_002("parameter reference"));
}

}
 /***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:B.1.5.2, Ensure that the IUT correctly handles template matching of character pattern reference expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010502_reference_expression_010 { 


	type record MessageType {
  	 universal charstring  field1,
     universal charstring  field2,
     universal charstring  field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010502_reference_expression_010() runs on GeneralComp {

    var MessageType v_testMessage;
    const charstring m_Ref:="abc?def?";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "{\m_Ref}",      // this should accept pattern "abc?def?" only	
  field2 := pattern "{m_Ref}\q{0,0,1,113}",   // this should accept pattern "abc?def?" only, with any character in ? 	
  field3 := pattern "{\m_Ref}\q{0,0,1,113}"   // this should accept pattern "abc?def?" only	
     
 };
 v_testMessage:=  {  
  field1 := "abc?def?",
  field2 := "abcDdefG",
  field3 := "abc?def?"  
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass,v_testMessage);
     }
     [] messagePort.receive {
        setverdict(fail,"Unexpected decoding result:",v_testMessage);
     }
    }
}

control{
    execute(TC_Sem_B010502_reference_expression_010());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.2, Ensure that the IUT correctly handles template matching of character pattern reference expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010502_reference_expression_006 { 

    modulepar {
     charstring MOD_REF:="modulepar reference";
    }

    type record MessageType {
     charstring  	field1, 
     charstring		field2,
     charstring		field3,
     charstring  	field4, 
     charstring		field5,
     charstring		field6,
     charstring		field7
    }

    type port loopbackPort message {
      inout MessageType
    }
	
      const charstring c_Ref:="constant reference";

type component GeneralComp {	    	    
      port loopbackPort messagePort
}	

testcase TC_Sem_B010502_reference_expression_006(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="variable reference";
    template charstring m_Ref:= pattern "{c_Ref}";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "{v_Ref}",
  field2 := pattern "{c_Ref}", 
  field3 := pattern "{MOD_REF}",
  field4 := pattern "{p_Ref}",
  field5 := pattern "{m_Ref}",	//mismatch in this reference
  field6 := pattern "{m_"&"Ref}!",
  field7 := pattern "{v_Ref} and {c_Ref}"
 }; 

 v_testMessage:=  {  
  field1 := "variable reference",
  field2 := "constant reference", 
  field3 := "modulepar reference",
  field4 := "parameter reference",
  field5 := "constant reference ",
  field6 := "constant reference!",
  field7 := "variable reference and constant reference"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010502_reference_expression_006("parameter reference"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.2, Ensure that the IUT correctly handles template matching of character pattern reference expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010502_reference_expression_002 { 

    modulepar {
     charstring MOD_REF:="modulepar reference";
    }

    type record MessageType {
     charstring  	field1, 
     charstring		field2,
     charstring		field3,
     charstring  	field4, 
     charstring		field5,
     charstring		field6,
     charstring		field7
    }

    type port loopbackPort message {
      inout MessageType
    }
	
      const charstring c_Ref:="constant reference";

type component GeneralComp {	    	    
      port loopbackPort messagePort
}	

testcase TC_Sem_B010502_reference_expression_002(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="variable reference";
    template charstring m_Ref:= pattern "{c_Ref}";
 
 template MessageType mw_matchingTemplate:= 
 {  	
     field1 := pattern "{v_Ref}",	//mismatch in this reference
     field2 := pattern "{c_Ref}", 
     field3 := pattern "{MOD_REF}",
     field4 := pattern "{p_Ref}",
     field5 := pattern "{m_Ref}",
     field6 := pattern "{m_"&"Ref}!",
     field7 := pattern "{v_Ref} and {c_Ref}"
 }; 

 v_testMessage:=  {  
  field1 := "variable reference ",
  field2 := "constant reference", 
  field3 := "modulepar reference",
  field4 := "parameter reference",
  field5 := "constant reference",
  field6 := "constant reference!",
  field7 := "variable reference and constant reference"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010502_reference_expression_002("parameter reference"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.2, Ensure that the IUT correctly handles template matching of character pattern reference expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010502_reference_expression_005 { 

    modulepar {
     charstring MOD_REF:="modulepar reference";
    }

    type record MessageType {
     charstring  	field1, 
     charstring		field2,
     charstring		field3,
     charstring  	field4, 
     charstring		field5,
     charstring		field6,
     charstring		field7
    }

    type port loopbackPort message {
      inout MessageType
    }
	
      const charstring c_Ref:="constant reference";

type component GeneralComp {	    	    
      port loopbackPort messagePort
}	

testcase TC_Sem_B010502_reference_expression_005(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="variable reference";
    template charstring m_Ref:= pattern "{c_Ref}";
    template charstring m_RefExp_p1 := pattern "{m_";  
    template charstring m_RefExp_p2 := pattern "Ref}!";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "{v_Ref}",
  field2 := pattern "{c_Ref}", 
  field3 := pattern "{MOD_REF}",
  field4 := pattern "{p_Ref}",	//mismatch in this reference
  field5 := pattern "{m_Ref}",
  field6 := pattern "{m_"&"Ref}!",
  field7 := pattern "{v_Ref} and {c_Ref}"
 }; 

 v_testMessage:=  {  
  field1 := "variable reference",
  field2 := "constant reference", 
  field3 := "modulepar reference",
  field4 := "parameter reference ",
  field5 := "constant reference",
  field6 := "constant reference!",
  field7 := "variable reference and constant reference"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010502_reference_expression_005("parameter reference"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.2, Ensure that the IUT correctly handles template matching of character pattern reference expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010502_reference_expression_007 { 

    modulepar {
     charstring MOD_REF:="modulepar reference";
    }

    type record MessageType {
     charstring  	field1, 
     charstring		field2,
     charstring		field3,
     charstring  	field4, 
     charstring		field5,
     charstring		field6,
     charstring		field7
    }

    type port loopbackPort message {
      inout MessageType
    }
	
      const charstring c_Ref:="constant reference";

type component GeneralComp {	    	    
      port loopbackPort messagePort
}	

testcase TC_Sem_B010502_reference_expression_007(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="variable reference";
    template charstring m_Ref:= pattern "{c_Ref}";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "{v_Ref}",
  field2 := pattern "{c_Ref}", 
  field3 := pattern "{MOD_REF}",
  field4 := pattern "{p_Ref}",
  field5 := pattern "{m_Ref}",
  field6 := pattern "{m_"&"Ref}!",	//mismatch in this reference 
  field7 := pattern "{v_Ref} and {c_Ref}"
 }; 

 v_testMessage:=  {  
  field1 := "variable reference",
  field2 := "constant reference", 
  field3 := "modulepar reference",
  field4 := "parameter reference",
  field5 := "constant reference",
  field6 := "{m_Ref}!",
  field7 := "variable reference and constant reference"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010502_reference_expression_007("parameter reference"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.2, Ensure that the IUT correctly handles template matching of character pattern reference expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010502_reference_expression_009 { 


	type record MessageType {
  	 charstring  	field1
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010502_reference_expression_009() runs on GeneralComp {

    var MessageType v_testMessage;
    template charstring m_Ref:="a-z";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "[{m_Ref}]"		//mismatch as {} looses its meaning inside []
 }; 

 v_testMessage:=  {  
  field1 := "x"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010502_reference_expression_009());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.2, Ensure that the IUT correctly handles template matching of character pattern reference expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010502_reference_expression_004 { 

    modulepar {
     charstring MOD_REF:="modulepar reference";
    }

    type record MessageType {
     charstring  	field1, 
     charstring		field2,
     charstring		field3,
     charstring  	field4, 
     charstring		field5,
     charstring		field6,
     charstring		field7
    }

    type port loopbackPort message {
      inout MessageType
    }
	
      const charstring c_Ref:="constant reference";

type component GeneralComp {	    	    
      port loopbackPort messagePort
}	

testcase TC_Sem_B010502_reference_expression_004(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="variable reference";
    template charstring m_Ref:= pattern "{c_Ref}";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "{v_Ref}",
  field2 := pattern "{c_Ref}", 
  field3 := pattern "{MOD_REF}",	//mismatch in this reference
  field4 := pattern "{p_Ref}",
  field5 := pattern "{m_Ref}",
  field6 := pattern "{m_"&"Ref}!",
  field7 := pattern "{v_Ref} and {c_Ref}"
 }; 

 v_testMessage:=  {  
  field1 := "variable reference",
  field2 := "constant reference", 
  field3 := "modulepar reference ",
  field4 := "parameter reference",
  field5 := "constant reference",
  field6 := "constant reference!",
  field7 := "variable reference and constant reference"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010502_reference_expression_004("parameter reference"));
}

}
 /***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:B.1.5.2, Ensure that the IUT correctly handles template matching of character pattern reference expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010502_reference_expression_011 { 


	type record MessageType {
  	 universal charstring  field1,
     universal charstring  field2
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010502_reference_expression_011() runs on GeneralComp {

    var MessageType v_testMessage;
    const MessageType m_Ref:={"1","ABCabc"};
    const charstring referencedConstant_1 := m_Ref.field1;
    const charstring referencedConstant_2 := m_Ref.field2;

 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "{referencedConstant_1}",
  field2 := pattern "{referencedConstant_2}"  
 };
      
 v_testMessage:=  {  
  field1 := "1",
  field2 := "ABCabc" 
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass,v_testMessage);
     }
     [] messagePort.receive {
        setverdict(fail,"Unexpected decoding result:",v_testMessage);
     }
    }
}

control{
    execute(TC_Sem_B010502_reference_expression_011());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.2, Ensure that the IUT correctly handles template matching of character pattern reference expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010502_reference_expression_008 { 

    modulepar {
     charstring MOD_REF:="modulepar reference";
    }

    type record MessageType {
     charstring  	field1, 
     charstring		field2,
     charstring		field3,
     charstring  	field4, 
     charstring		field5,
     charstring		field6,
     charstring		field7
    }

    type port loopbackPort message {
      inout MessageType
    }
	
      const charstring c_Ref:="constant reference";

type component GeneralComp {	    	    
      port loopbackPort messagePort
}	

testcase TC_Sem_B010502_reference_expression_008(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="variable reference";
    template charstring m_Ref:= pattern "{c_Ref}";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "{v_Ref}",
  field2 := pattern "{c_Ref}", 
  field3 := pattern "{MOD_REF}",
  field4 := pattern "{p_Ref}",
  field5 := pattern "{m_Ref}",
  field6 := pattern "{m_"&"Ref}!", 
  field7 := pattern "{v_Ref} and {c_Ref}"	//mismatch in this reference
 }; 

 v_testMessage:=  {  
  field1 := "variable reference",
  field2 := "constant reference", 
  field3 := "modulepar reference",
  field4 := "parameter reference",
  field5 := "constant reference",
  field6 := "constant reference!",
  field7 := " and constant reference"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010502_reference_expression_008("parameter reference"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.2, Ensure that the IUT correctly handles template matching of character pattern reference expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010502_reference_expression_003 { 

    modulepar {
     charstring MOD_REF:="modulepar reference";
    }

    type record MessageType {
     charstring  	field1, 
     charstring		field2,
     charstring		field3,
     charstring  	field4, 
     charstring		field5,
     charstring		field6,
     charstring		field7
    }

    type port loopbackPort message {
      inout MessageType
    }
	
      const charstring c_Ref:="constant reference";

type component GeneralComp {	    	    
      port loopbackPort messagePort
}	

testcase TC_Sem_B010502_reference_expression_003(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="variable reference";
    template charstring m_Ref:= pattern "{c_Ref}";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "{v_Ref}",
  field2 := pattern "{c_Ref}", 	//mismatch in this reference
  field3 := pattern "{MOD_REF}",
  field4 := pattern "{p_Ref}",
  field5 := pattern "{m_Ref}",
  field6 := pattern "{m_"&"Ref}!",
  field7 := pattern "{v_Ref} and {c_Ref}"
 }; 

 v_testMessage:=  {  
  field1 := "variable reference",
  field2 := "constant reference ", 
  field3 := "modulepar reference",
  field4 := "parameter reference",
  field5 := "constant reference",
  field6 := "constant reference!",
  field7 := "variable reference and constant reference"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010502_reference_expression_003("parameter reference"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.2, Ensure that the IUT correctly handles template matching of character pattern reference expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010502_reference_expression_001 { 

    modulepar {
     charstring MOD_REF:="modulepar reference";
    }

    type record MessageType {
     charstring  	field1, 
     charstring		field2,
     charstring		field3,
     charstring  	field4, 
     charstring		field5,
     charstring		field6,
     charstring		field7
    }

    type port loopbackPort message {
      inout MessageType
    }
	
      const charstring c_Ref:="constant reference";

type component GeneralComp {	    	    
      port loopbackPort messagePort;
}	

testcase TC_Sem_B010502_reference_expression_001(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="variable reference";
    template charstring m_Ref:= pattern "{c_Ref}";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "{v_Ref}",
  field2 := pattern "{c_Ref}", 
  field3 := pattern "{MOD_REF}",
  field4 := pattern "{p_Ref}",
  field5 := pattern "{m_Ref}",
  field6 := pattern "{m_"&"Ref}!",
  field7 := pattern "{v_Ref} and {c_Ref}"
 };

 v_testMessage:=  {  
  field1 := "variable reference",
  field2 := "constant reference", 
  field3 := "modulepar reference",
  field4 := "parameter reference",
  field5 := "constant reference",
  field6 := "constant reference!",
  field7 := "variable reference and constant reference"
 };
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010502_reference_expression_001("parameter reference"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.4, Ensure that the IUT correctly handles template matching of character pattern reference characters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010504_match_referenced_characters_007 { 

    modulepar {
     charstring MOD_REF:="e";
    }
    
	type charstring CharRange ("e".."t"); 

	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3,
  	 charstring  	field4, 
  	 charstring		field5,
  	 charstring		field6
	}

    type port loopbackPort message {
	  inout MessageType
	}
	
      const charstring c_Ref:="s";

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010504_match_referenced_characters_007(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="s";
    template charstring m_Ref:="{c_Ref}";	//assuming dereferencing is only done once, no chained references
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "te[\N{v_Ref}]t",
  field2 := pattern "[\N{c_Ref}et]+", 
  field3 := pattern "[\N{MOD_REF}-t]+",
  field4 := pattern "te[\N{p_Ref}]t",
  field5 := pattern "te{m_Ref}t",
  field6 := pattern "\N{CharRange}+"
 }; 

 v_testMessage:=  {  
  field1 := "test",
  field2 := "test", 
  field3 := "test",
  field4 := "test",
  field5 := "te{c_Ref}t",
  field6 := "test"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010504_match_referenced_characters_007("s"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.4, Ensure that the IUT correctly handles template matching of character pattern reference characters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010504_match_referenced_characters_003 { 

    modulepar {
     charstring MOD_REF:="e";
    }
    
	type charstring CharRange ("e".."t"); 

	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3,
  	 charstring  	field4, 
  	 charstring		field5,
  	 charstring		field6
	}

    type port loopbackPort message {
	  inout MessageType
	}
	
      const charstring c_Ref:="x";

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010504_match_referenced_characters_003(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="s";
    template charstring m_Ref:="s";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "te[\N{v_Ref}]t",
  field2 := pattern "[\N{c_Ref}et]+", 	//reference character mismatch
  field3 := pattern "[\N{MOD_REF}-t]+",
  field4 := pattern "te[\N{p_Ref}]t",
  field5 := pattern "te\N{m_Ref}t",
  field6 := pattern "\N{CharRange}+"
 }; 

 v_testMessage:=  {  
  field1 := "test",
  field2 := "test", 
  field3 := "test",
  field4 := "test",
  field5 := "test",
  field6 := "test"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010504_match_referenced_characters_003("s"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.4, Ensure that the IUT correctly handles template matching of character pattern reference characters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010504_match_referenced_characters_005 { 

    modulepar charstring MOD_REF:="e";
    
	type charstring CharRange ("s".."t"); 

	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3,
  	 charstring  	field4, 
  	 charstring		field5,
  	 charstring		field6
	}

    type port loopbackPort message {
	  inout MessageType
	}
	
      const charstring c_Ref:="s";

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010504_match_referenced_characters_005(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="s";
    template charstring m_Ref:="s";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "te[\N{v_Ref}]t",
  field2 := pattern "[\N{c_Ref}et]+",
  field3 := pattern "[\N{MOD_REF}-t]+", 
  field4 := pattern "te[\N{p_Ref}]t",
  field5 := pattern "te\N{m_Ref}t",
  field6 := pattern "\N{CharRange}+"	//reference character mismatch
 }; 

 v_testMessage:=  {  
  field1 := "test",
  field2 := "test", 
  field3 := "test",
  field4 := "test",
  field5 := "test",
  field6 := "test"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010504_match_referenced_characters_005("s"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.4, Ensure that the IUT correctly handles template matching of character pattern reference characters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010504_match_referenced_characters_006 { 

    modulepar charstring MOD_REF:="e";
    
	type charstring CharRange ("e".."t"); 

	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3,
  	 charstring  	field4, 
  	 charstring		field5,
  	 charstring		field6
	}

    type port loopbackPort message {
	  inout MessageType
	}
	
	const charstring c_Ref:="s";

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010504_match_referenced_characters_006(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="s";
    template charstring m_Ref:="s";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "te[\N{v_Ref}]t",
  field2 := pattern "[\N{c_Ref}et]+",
  field3 := pattern "[\N{MOD_REF}-t]+", 
  field4 := pattern "te[\N{p_Ref}]t",	//reference character mismatch
  field5 := pattern "te\N{m_Ref}t",
  field6 := pattern "\N{CharRange}+"
 }; 

 v_testMessage:=  {  
  field1 := "test",
  field2 := "test", 
  field3 := "test",
  field4 := "test",
  field5 := "test",
  field6 := "test"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010504_match_referenced_characters_006("x"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.4, Ensure that the IUT correctly handles template matching of character pattern reference characters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010504_match_referenced_characters_004 { 

    modulepar {
     charstring MOD_REF:="s";
    }
    
	type charstring CharRange ("e".."t"); 

	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3,
  	 charstring  	field4, 
  	 charstring		field5,
  	 charstring		field6
	}

    type port loopbackPort message {
	  inout MessageType
	}
	
      const charstring c_Ref:="s";

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010504_match_referenced_characters_004(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="s";
    template charstring m_Ref:="s";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "te[\N{v_Ref}]t",
  field2 := pattern "[\N{c_Ref}et]+",
  field3 := pattern "[\N{MOD_REF}-t]+", 	//reference character mismatch
  field4 := pattern "te[\N{p_Ref}]t",
  field5 := pattern "te\N{m_Ref}t",
  field6 := pattern "\N{CharRange}+"
 }; 

 v_testMessage:=  {  
  field1 := "test",
  field2 := "test", 
  field3 := "test",
  field4 := "test",
  field5 := "test",
  field6 := "test"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010504_match_referenced_characters_004("s"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.4, Ensure that the IUT correctly handles template matching of character pattern reference characters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010504_match_referenced_characters_001 { 

    modulepar {
     charstring MOD_REF:="e";
    }
    
	type charstring CharRange ("e".."t"); 

	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3,
  	 charstring  	field4, 
  	 charstring		field5,
  	 charstring		field6
	}

    type port loopbackPort message {
	  inout MessageType
	}
	
      const charstring c_Ref:="s";

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010504_match_referenced_characters_001(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="s";
    template charstring m_Ref:="s";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "te[\N{v_Ref}]t",
  field2 := pattern "[\N{c_Ref}et]+", 
  field3 := pattern "[\N{MOD_REF}-t]+",
  field4 := pattern "te[\N{p_Ref}]t",
  field5 := pattern "te\N{m_Ref}t",
  field6 := pattern "\N{CharRange}+"
 }; 

 v_testMessage:=  {  
  field1 := "test",
  field2 := "test", 
  field3 := "test",
  field4 := "test",
  field5 := "test",
  field6 := "test"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010504_match_referenced_characters_001("s"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.5.4, Ensure that the IUT correctly handles template matching of character pattern reference characters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010504_match_referenced_characters_002 { 

    modulepar {
     charstring MOD_REF:="e";
    }
    
	type charstring CharRange ("e".."t"); 

	type record MessageType {
  	 charstring  	field1, 
  	 charstring		field2,
  	 charstring		field3,
  	 charstring  	field4, 
  	 charstring		field5,
  	 charstring		field6
	}

    type port loopbackPort message {
	  inout MessageType
	}
	
      const charstring c_Ref:="s";

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010504_match_referenced_characters_002(charstring p_Ref) runs on GeneralComp {

    var MessageType v_testMessage;
    var charstring v_Ref:="x";
    template charstring m_Ref:="s";
 
 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "te[\N{v_Ref}]t",	//reference character mismatch
  field2 := pattern "[\N{c_Ref}et]+", 
  field3 := pattern "[\N{MOD_REF}-t]+",
  field4 := pattern "te[\N{p_Ref}]t",
  field5 := pattern "te\N{m_Ref}t",
  field6 := pattern "\N{CharRange}+"
 }; 

 v_testMessage:=  {  
  field1 := "test",
  field2 := "test", 
  field3 := "test",
  field4 := "test",
  field5 := "test",
  field6 := "test"
 }; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010504_match_referenced_characters_002("s"));
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.1, Ensure that the IUT correctly handles template matching of specific values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B0101_matching_specific_value_008 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B0101_matching_specific_value_008() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},	
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true},
  field7 := {a:=2,b:=1,c:=true}, //mismatching value 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B0101_matching_specific_value_008());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.1, Ensure that the IUT correctly handles template matching of specific values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B0101_matching_specific_value_002 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B0101_matching_specific_value_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 0,		//mismatching value
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B0101_matching_specific_value_002());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.1, Ensure that the IUT correctly handles template matching of specific values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B0101_matching_specific_value_004 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B0101_matching_specific_value_004() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := false, 	//mismatching value
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B0101_matching_specific_value_004());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.1, Ensure that the IUT correctly handles template matching of specific values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B0101_matching_specific_value_001 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B0101_matching_specific_value_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B0101_matching_specific_value_001());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.1, Ensure that the IUT correctly handles template matching of specific values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B0101_matching_specific_value_006 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B0101_matching_specific_value_006() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},	
  field5 := e_white,	//mismatching value
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B0101_matching_specific_value_006());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.1, Ensure that the IUT correctly handles template matching of specific values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B0101_matching_specific_value_010 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B0101_matching_specific_value_010() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},	
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true},
  field7 := {a:=1,b:=2,c:=true},
  field8 := {a:=1}, 
  field9 := {1,2}, //mismatching value
  field10 := {1,2}
 } 

 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B0101_matching_specific_value_010());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.1, Ensure that the IUT correctly handles template matching of specific values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B0101_matching_specific_value_011 { 

    type enumerated EnumeratedType {e_black, e_white};

    type record RecordType { 
     integer  a optional, 
     integer  b optional, 
     boolean  c 
    } 

    type set SetType { 
     integer  a optional, 
     integer  b optional, 
     boolean  c 
    } 

    type record length (1..2) of integer IntegerList;

    type set length (1..2) of integer IntegerUList;

    type union UnionType { 
     integer  a, 
     EnumeratedType  b, 
     boolean  c 
    } 

    type record MessageType {
     integer  		field1, 
     charstring  	field2, 
     boolean  		field3, 
     integer  		field4[4],
     EnumeratedType field5,
     RecordType		field6,
     SetType		field7,
     UnionType		field8,
     IntegerList	field9,
     IntegerUList	field10
    }

    type port loopbackPort message {
      inout MessageType
    }
	

type component GeneralComp {	    	    
      port loopbackPort messagePort
}	

testcase TC_Sem_B0111_matching_specific_value_011() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},	
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true},
  field7 := {a:=1,b:=2,c:=true},
  field8 := {a:=1}, 
  field9 := {1},
  field10 := {2,1} //different order
 } 

 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B0111_matching_specific_value_011());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.1, Ensure that the IUT correctly handles template matching of specific values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B0101_matching_specific_value_003 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B0101_matching_specific_value_003() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test strin",		//mismatching value 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B0101_matching_specific_value_003());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.1, Ensure that the IUT correctly handles template matching of specific values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B0101_matching_specific_value_009 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B0101_matching_specific_value_009() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},	
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true},
  field7 := {a:=1,b:=2,c:=true},
  field8 := {c:=true}, //mismatching value 
  field9 := {1},
  field10 := {1,2}
 } 

 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B0101_matching_specific_value_009());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.1, Ensure that the IUT correctly handles template matching of specific values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B0101_matching_specific_value_007 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B0101_matching_specific_value_007() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},	
  field5 := e_black,
  field6 := {a:=1,b:=3,c:=true}, //mismatching value
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B0101_matching_specific_value_007());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.1, Ensure that the IUT correctly handles template matching of specific values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B0101_matching_specific_value_005 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B0101_matching_specific_value_005() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,5},	//mismatching value
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B0101_matching_specific_value_005());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.1.1, Ensure that the IUT correctly handles template matching of omitted values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010101_omitting_values_001 { 

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record MessageType {
  	 RecordType		field1,
  	 SetType		field2
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010101_omitting_values_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := {a:=1,b:=omit,c:=true},
  field2 := {a:=1,b:=omit,c:=true}
 } 

 v_testMessage:=  {  
  field1 := {a:=1,b:=omit,c:=true}, 
  field2 := {a:=1,b:=omit,c:=true}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010101_omitting_values_001());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.1.1, Ensure that the IUT correctly handles template matching of omitted values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010101_omitting_values_002 { 

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record MessageType {
  	 RecordType		field1,
  	 SetType		field2
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010101_omitting_values_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := {a:=1,b:=omit,c:=true},	//value mismatch
  field2 := {a:=1,b:=omit,c:=true}
 } 

 v_testMessage:=  {  
  field1 := {a:=1,b:=2,c:=true}, 
  field2 := {a:=1,b:=omit,c:=true}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010101_omitting_values_002());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.1, Ensure that the IUT correctly handles template matching of ? symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010301_any_element_006 { 


	type record MessageType {
  	 record of integer  	field1
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010301_any_element_006() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := {8,?,10,?,12}
 } 

 v_testMessage:=  {  
  field1 := {8,9,10,11,12}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010301_any_element_006());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.1, Ensure that the IUT correctly handles template matching of ? symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010301_any_element_002 { 


	type record MessageType {
  	 charstring  	field1, 
  	 bitstring		field2,
  	 hexstring		field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010301_any_element_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "test s?ring",	//attempting to match a missing character
  field2 := '10???'B, 
  field3 := '8?A?C'H
 } 

 v_testMessage:=  {  
  field1 := "test sring",
  field2 := '10101'B, 
  field3 := '89ABC'H
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010301_any_element_002());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.1, Ensure that the IUT correctly handles template matching of ? symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010301_any_element_003 { 


	type record MessageType {
  	 charstring  	field1, 
  	 bitstring		field2,
  	 hexstring		field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010301_any_element_003() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := "test string",	
  field2 := '10???'B, 
  field3 := '8?A?C'H	//attempting to match several characters
 } 

 v_testMessage:=  {  
  field1 := "test sring",
  field2 := '10101'B, 
  field3 := '89ABBC'H
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010301_any_element_003());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.1, Ensure that the IUT correctly handles template matching of ? symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010301_any_element_007 { 


	type record MessageType {
  	 record of integer  	field1
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010301_any_element_007() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := {8,?,10,?,12}
 } 

 v_testMessage:=  {  
  field1 := {8,9,10,12}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010301_any_element_007());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.1, Ensure that the IUT correctly handles template matching of ? symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010301_any_element_001 { 


	type record MessageType {
  	 charstring  	field1, 
  	 bitstring		field2,
  	 hexstring		field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010301_any_element_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "test s?ring",
  field2 := '10???'B, 
  field3 := '8?A?C'H
 } 

 v_testMessage:=  {  
  field1 := "test string",
  field2 := '10101'B, 
  field3 := '89ABC'H
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010301_any_element_001());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.1, Ensure that the IUT correctly handles template matching of ? symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010301_any_element_004 { 


	type record MessageType {
  	 charstring  	field1, 
  	 bitstring		field2,
  	 hexstring		field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010301_any_element_004() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := "test string",	
  field2 := '10???'B, 	//mismatching string lengths
  field3 := '8?A?C'H
 } 

 v_testMessage:=  {  
  field1 := "test sring",
  field2 := '10'B, 
  field3 := '89ABC'H
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010301_any_element_004());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.1, Ensure that the IUT correctly handles template matching of ? symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010301_any_element_008 { 


	type record MessageType {
  	 record of integer  	field1
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010301_any_element_008() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := {8,?,?,12}
 } 

 v_testMessage:=  {  
  field1 := {8,9,10,11,12}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010301_any_element_008());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.1, Ensure that the IUT correctly handles template matching of ? symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010301_any_element_005 { 


	type record MessageType {
  	 charstring  	field1, 
  	 bitstring		field2,
  	 hexstring		field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010301_any_element_005() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := "test s?ring", 	//literally interpreted string without the pattern keyword
  field2 := '10???'B, 
  field3 := '8?A?C'H
 } 

 v_testMessage:=  {  
  field1 := "test string",
  field2 := '10101'B, 
  field3 := '89ABC'H
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010301_any_element_005());
}

}
 /***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.3, Ensure that all from clause operand can be a set of value
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Besides specifying all individual values, it is possible to add all elements of 
// a set of template into permutations using an all from clause.
// 

module Sem_B010303_permutation_008 { 

	type set of integer SoI;
	type record of integer RoI;
	
	template SoI t_source := { 1, 2 };
	template RoI t_perm1 := { permutation (all from t_source), 5 };
	template RoI t_perm2 := { -1, permutation (0, all from t_source, 3) };
	

	type component GeneralComp {	    	    
	}	

	testcase TC_Sem_B010303_permutation_008() runs on GeneralComp {
		if (match({ 2, 1, 5 }, t_perm1) and match({ -1, 1, 0, 2, 3 }, t_perm2)) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}

	control{
	    execute(TC_Sem_B010303_permutation_008());
	}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.3, Ensure that the IUT correctly handles template matching of ? symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010303_permutation_003 { 


	type record MessageType {
  	 record of integer  	field1, 
  	 record of integer  	field2,
  	 record of integer  	field3,
  	 record of integer  	field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010303_permutation_003() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := { permutation ( 1, 2, 3 ), 5 },	
  field2 := { permutation ( 1, 2, ? ), 5 }, 	//there is an extra element in the sequence
  field3 := { permutation ( 1, 2, 3 ), * },
  field4 := { permutation ( (1,2,3), 2, 3 ), 5 }
 } 

 v_testMessage:=  {  
  field1 := {2,1,3,5},
  field2 := {2,1,8,8,5}, 
  field3 := {3,2,1,8},
  field4 := {3,2,2,5}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010303_permutation_003());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.3, Ensure that the IUT correctly handles template matching of ? symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010303_permutation_004 { 


	type record MessageType {
  	 record of integer  	field1, 
  	 record of integer  	field2,
  	 record of integer  	field3,
  	 record of integer  	field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010303_permutation_004() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := { permutation ( 1, 2, 3 ), 5 },	
  field2 := { permutation ( 1, 2, ? ), 5 }, 
  field3 := { permutation ( 1, 2, 3 ), * }, 	//wrong order of elements
  field4 := { permutation ( (1,2,3), 2, 3 ), 5 }
 } 

 v_testMessage:=  {  
  field1 := {2,1,3,5},
  field2 := {2,1,8,5}, 
  field3 := {3,2,8,1},
  field4 := {3,2,2,5}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010303_permutation_004());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.3, Ensure that the IUT correctly handles template matching of ? symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010303_permutation_001 { 


	type record MessageType {
  	 record of integer  	field1, 
  	 record of integer  	field2,
  	 record of integer  	field3,
  	 record of integer  	field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010303_permutation_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := { permutation ( 1, 2, 3 ), 5 },
  field2 := { permutation ( 1, 2, ? ), 5 }, 
  field3 := { permutation ( 1, 2, 3 ), * },
  field4 := { permutation ( (1,2,3), 2, 3 ), 5 }
 } 

 v_testMessage:=  {  
  field1 := {2,1,3,5},
  field2 := {2,1,8,5}, 
  field3 := {3,2,1,8,8},
  field4 := {3,2,2,5}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010303_permutation_001());
}

}
 /***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.3, Ensure that the IUT correctly handles permutation within arrays
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010303_permutation_006 { 


	type record MessageType {
  	 record of integer  	field1, 
  	 record of integer  	field2,
  	 record of integer  	field3,
  	 record of integer  	field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010303_permutation_006() runs on GeneralComp {

    var MessageType v_testMessage;
    var template integer mw_field1 [4] := { permutation ( 1, 2, 3 ), 5 };
    var template integer mw_field2 [4] := { permutation ( 1, 2, ? ), 5 };
    var template integer mw_field3 [4] := { permutation ( 1, 2, 3 ), * };
    var template integer mw_field4 [4] := { permutation ( (1,2,3), 2, 3 ), 5 };

 template MessageType mw_matchingTemplate:= 
 {  	
  mw_field1,
  mw_field2, 
  mw_field3,
  mw_field4
 } 

 v_testMessage:=  {  
  field1 := {2,1,3,5},
  field2 := {2,1,8,5}, 
  field3 := {3,2,1,8},
  field4 := {3,2,2,5}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010303_permutation_006());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.3, Ensure that the IUT correctly handles template matching of ? symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010303_permutation_005 { 


	type record MessageType {
  	 record of integer  	field1, 
  	 record of integer  	field2,
  	 record of integer  	field3,
  	 record of integer  	field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010303_permutation_005() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := { permutation ( 1, 2, 3 ), 5 },	
  field2 := { permutation ( 1, 2, ? ), 5 }, 
  field3 := { permutation ( 1, 2, 3 ), * }, 
  field4 := { permutation ( (1,2,3), 2, 3 ), 5 }		//wrong set of elements
 } 

 v_testMessage:=  {  
  field1 := {2,1,3,5},
  field2 := {2,1,8,5}, 
  field3 := {3,2,8,1},
  field4 := {3,1,1,5}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010303_permutation_005());
}

}
 /***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.3, Ensure that all from clause operand can be a set of value
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
/* Restriction d) Individual members of a permutation and elements of the template in the all from clause shall only be
expressions, templates obeying to restriction c) above, and the AnyElement and AnyElementsOrNone matching
mechanisms.*/ 

module Sem_B010303_permutation_009 { 

	type set of integer SoI;
	type record of integer RoI;
    
    type record MessageType {
  	 record of integer  	field1
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	
	
	template SoI t_source := { 1, 2 ,?};
	template RoI t_perm1 := { permutation (all from t_source), 5 };    //using all from with ?
	
	testcase TC_Sem_B010303_permutation_009() runs on GeneralComp {
        
    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := t_perm1
 } 

 v_testMessage:=  {  
  field1 := {2,1,3,5}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}
	control{
	    execute(TC_Sem_B010303_permutation_009());
	}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.3, Ensure that the IUT correctly handles template matching of ? symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010303_permutation_002 { 


	type record MessageType {
  	 record of integer  	field1, 
  	 record of integer  	field2,
  	 record of integer  	field3,
  	 record of integer  	field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010303_permutation_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := { permutation ( 1, 2, 3 ), 5 },		//3 is missing from the match
  field2 := { permutation ( 1, 2, ? ), 5 }, 
  field3 := { permutation ( 1, 2, 3 ), * },
  field4 := { permutation ( (1,2,3), 2, 3 ), 5 }
 } 

 v_testMessage:=  {  
  field1 := {2,1,2,5},
  field2 := {2,1,8,5}, 
  field3 := {3,2,1,8},
  field4 := {3,2,2,5}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010303_permutation_002());
}

}
 /***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.3, Ensure that all from clause can be used inside permutation
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Besides specifying all individual values, it is possible to add all elements of 
// a record of template into permutations using an all from clause.

module Sem_B010303_permutation_007 { 

	type record of integer RoI;
	
	template RoI t_source := { 1, 2 };
	template RoI t_perm1 := { permutation (all from t_source), 5 };
	template RoI t_perm2 := { -1, permutation (0, all from t_source, 3) };
	

	type component GeneralComp {	    	    
	}	

	testcase TC_Sem_B010303_permutation_007() runs on GeneralComp {
		if (match({ 2, 1, 5 }, t_perm1) and match({ -1, 1, 0, 2, 3 }, t_perm2)) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}

	control{
	    execute(TC_Sem_B010303_permutation_007());
	}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.2, Ensure that the IUT correctly handles template matching of * symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010302_any_number_of_elements_or_none_003 { 


	type record MessageType {
  	 record of integer  	field1, 
  	 record of integer 		field2,
  	 record of integer 		field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010302_any_number_of_elements_or_none_003() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := {8,*,10,*,12},
  field2 := {8,*,10,*,12}, 
  field3 := {8,*,10,*,12}
 } 

 v_testMessage:=  {  
  field1 := {8,9,10,11,12},
  field2 := {8,9,10,12}, 
  field3 := {8,9,9,10,10,11,12}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010302_any_number_of_elements_or_none_003());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.2, Ensure that the IUT correctly handles template matching of * symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010302_any_number_of_elements_or_none_001 { 


	type record MessageType {
  	 charstring  	field1, 
  	 bitstring		field2,
  	 hexstring		field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010302_any_number_of_elements_or_none_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "test s*g",
  field2 := '10*'B, 
  field3 := '89*ABC'H
 } 

 v_testMessage:=  {  
  field1 := "test string",
  field2 := '10101'B, 
  field3 := '89ABC'H
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010302_any_number_of_elements_or_none_001());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.3.2, Ensure that the IUT correctly handles template matching of * symbols in value elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010302_any_number_of_elements_or_none_002 { 


	type record MessageType {
  	 charstring  	field1, 
  	 bitstring		field2,
  	 hexstring		field3
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010302_any_number_of_elements_or_none_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := "test s*g",		//literally interpreted string without the pattern keyword
  field2 := '10*'B, 
  field3 := '89*ABC'H
 } 

 v_testMessage:=  {  
  field1 := "test string",
  field2 := '10101'B, 
  field3 := '89ABC'H
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010302_any_number_of_elements_or_none_002());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.4.2, Ensure that the IUT correctly handles template matching of ifpresent indicators 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010402_ifPresent_indicator_001 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1 optional, 
  	 charstring  	field2 optional, 
  	 RecordType		field3,
  	 UnionType		field4 optional
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010402_ifPresent_indicator_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := (0..2) ifpresent,
  field2 := "[a-f]" ifpresent, 
  field3 := {a:=1,b:=(0..2) ifpresent,c:=true}, 
  field4 := {a:=(0..2)} ifpresent
 } 

 v_testMessage:=  {  
  field1 := omit,
  field2 := omit, 
  field3 := {a:=1,b:=omit,c:=true}, 
  field4 := omit
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010402_ifPresent_indicator_001());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.4.2, Ensure that the IUT correctly handles template matching of ifpresent indicators 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010402_ifPresent_indicator_002 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1 optional, 
  	 charstring  	field2 optional, 
  	 RecordType		field3,
  	 UnionType		field4 optional
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010402_ifPresent_indicator_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := (0..2) ifpresent,
  field2 := ("a".."f") length (3) ifpresent,
  field3 := {a:=1,b:=(0..2) ifpresent,c:=true}, 	//element b is present and out of range
  field4 := {a:=(0..2)} ifpresent
 } 

 v_testMessage:=  {  
  field1 := omit,
  field2 := omit, 
  field3 := {a:=1,b:=3,c:=true}, 
  field4 := omit
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010402_ifPresent_indicator_002());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.4.1, Ensure that the IUT correctly handles template matching of value length definitions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010401_length_restrictions_002 { 


	type record MessageType {
  	 record of integer  	field1, 
  	 record of integer 		field2,
  	 record of integer 		field3,
  	 record of integer   	field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010401_length_restrictions_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := { permutation ( 1, 2, 3 ), * } length (3 .. 4),
  field2 := { (1,2),* }  length (2 .. 5), 
  field3 := { permutation ( 1, 2, 3 ), ? } length (4),
  field4 := { (1,2),? }  length (2 .. 5)
 } 

 v_testMessage:=  {  
  field1 := {2,1,3},
  field2 := {2,1,3,5}, 
  field3 := {2,1,3,5},
  field4 := {1,1}
 } 
  
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010401_length_restrictions_002());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.4.1, Ensure that the IUT correctly handles template matching of value length definitions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010401_length_restrictions_001 { 


	type record MessageType {
  	 charstring  	field1, 
  	 bitstring		field2,
  	 hexstring		field3,
  	 charstring  	field4, 
  	 bitstring		field5,
  	 hexstring		field6
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010401_length_restrictions_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := pattern "test s*g" length (6 .. 13),
  field2 := '10*'B  length (3 .. 5), 
  field3 := '89*ABC'H  length (5),
  field4 := pattern "tes?" length (4 .. 13),
  field5 := '10?'B  length (3 .. 5), 
  field6 := '89?ABC'H  length (6)
 } 

 v_testMessage:=  {  
  field1 := "test string",
  field2 := '10101'B, 
  field3 := '89ABC'H,
  field4 := "test",
  field5 := '101'B, 
  field6 := '899ABC'H
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010401_length_restrictions_001());
}

}
 /***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.7, Ensure that the IUT correctly handles template matching of subset definition 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

//Restriction e)
/*The individual members of the SubSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms length restriction and ifpresent).*/

module Sem_B010207_subset_005 { 

  	type set of integer SoI;

    type port loopbackPort message {
	  inout SoI
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010207_subset_005() runs on GeneralComp {

    var SoI v_testMessage;

 template SoI Template:= {1,2} length(1..5);

 template SoI mw_matchingTemplate:= subset(all from Template);    //subset(1,2);

 v_testMessage:={2};
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010207_subset_005());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.7, Ensure that the IUT correctly handles template matching of superset definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010207_subset_002 { 


	type record MessageType {
  	 set of integer	field1
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010207_subset_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := subset(1,2)	//no match for subset elements
 } 

 v_testMessage:=  {  
  field1 := {3}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010207_subset_002());
}

}
 /***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.7, Ensure that the IUT correctly handles template matching of subset definition
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

//Restriction c)
 
module Sem_B010207_subset_008 { 

  	type set of integer SoI;
    type record of integer RoI;

    type port loopbackPort message {
	  inout SoI
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010207_subset_008() runs on GeneralComp {

    var SoI v_testMessage;

 template RoI Template:= {1,?};

 template SoI mw_matchingTemplate:= subset(all from Template);   //Template is a record of integers

 v_testMessage:={2};
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010207_subset_008());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.7, Ensure that the IUT correctly handles template matching of superset definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010207_subset_003 { 


	type record MessageType {
  	 set of integer	field1
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010207_subset_003() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := subset(1,2)		//more elements than subset list
 } 

 v_testMessage:=  {  
  field1 := {1,2,3}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010207_subset_003());
}

}
 /***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.7, Ensure that the IUT correctly handles template matching of subset definition
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

//Restriction c) The member type of the set of type associated with the SubSet and the member type of the template in the all from clause shall be compatible.

module Sem_B010207_subset_004 { 

  	type set of integer SoI;

    type port loopbackPort message {
	  inout SoI
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010207_subset_004() runs on GeneralComp {

    var SoI v_testMessage;

 template SoI Template:= {1,2};

 template SoI mw_matchingTemplate:= subset(all from Template);    //subset(1,2);

 v_testMessage:={2};
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010207_subset_004());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.7, Ensure that the IUT correctly handles template matching of superset definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010207_subset_001 { 


	type record MessageType {
  	 set of integer	field1
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010207_subset_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := subset(1,2)
 } 

 v_testMessage:=  {  
  field1 := {2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010207_subset_001());
}

}
 /***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.7, Ensure that the IUT correctly handles template matching of subset definition
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

//Restriction e)
/*The individual members of the SubSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms length restriction and ifpresent).*/

module Sem_B010207_subset_006 { 

  	type set of integer SoI;

    type port loopbackPort message {
	  inout SoI
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010207_subset_006() runs on GeneralComp {

    var SoI v_testMessage;

 template SoI Template:= {1,2} ifpresent;

 template SoI mw_matchingTemplate:= subset(all from Template);    //subset(1,2);

 v_testMessage:={2};
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010207_subset_006());
}

}
 /***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.7, Ensure that the IUT correctly handles template matching of subset definition
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

//Restriction e)
/*individual members shall not resolve to AnyValueOrNone and individual fields of the template in the all from clause shall not resolve to AnyElementsOrNone or permutation..*/

module Sem_B010207_subset_007 { 

  	type set of integer SoI;

    type port loopbackPort message {
	  inout SoI
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010207_subset_007() runs on GeneralComp {

    var SoI v_testMessage;

 template SoI Template:= {1,?};

 template SoI mw_matchingTemplate:= subset(all from Template);  

 v_testMessage:={2};
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010207_subset_007());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of superset definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010206_superset_003 { 


	type record MessageType {
  	 set of integer	field1
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010206_superset_003() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := superset(1,2)	//no match for element 2
 } 

 v_testMessage:=  {  
  field1 := {1,1}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010206_superset_003());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of superset definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010206_superset_001 { 


	type record MessageType {
  	 set of integer	field1
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010206_superset_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := superset(1,2)
 } 

 v_testMessage:=  {  
  field1 := {1,3,2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010206_superset_001());
}

}
 /***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of superset definition
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

 //Restriction e)
/*The individual members of the SuperSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms omit, SuperSet, SubSet and the matching attributes (length restriction
and ifpresent). In addition, the individual members shall not resolve to AnyValueOrNone and individual
elements of the template in the all from clause shall not resolve to AnyElementsOrNone or permutation.*/

module Sem_B010206_superset_006 { 

  	type set of integer SoI;

    type port loopbackPort message {
	  inout SoI
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010206_superset_006() runs on GeneralComp {

    var SoI v_testMessage;

 template SoI Template:= {1,2} ifpresent;
 template SoI mw_matchingTemplate:= superset(all from Template);
  

 v_testMessage:={1,2}; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010206_superset_006());
}

}
 /***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of superset definition
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

 //Restriction c)
/*The member type of the set of associated with the SuperSet template and the member type of the template in
the all from clause shall be compatible.*/

module Sem_B010206_superset_008 { 

  	type set of integer SoI;
    type record of integer RoI;

    type port loopbackPort message {
	  inout SoI
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010206_superset_008() runs on GeneralComp {

    var SoI v_testMessage;

 template RoI Template:= {1,2};
 template SoI mw_matchingTemplate:= superset(all from Template);    //Template is a record of integers
  

 v_testMessage:={1,2}; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010206_superset_008());
}

}
 /***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of superset definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

 //Restriction c)
/*The member type of the set of associated with the SuperSet template and the member type of the template in
the all from clause shall be compatible.*/

module Sem_B010206_superset_004 { 

  	type set of integer SoI;

    type port loopbackPort message {
	  inout SoI
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010206_superset_004() runs on GeneralComp {

    var SoI v_testMessage;

 template SoI Template:= {1,2};
 template SoI mw_matchingTemplate:= superset(all from Template);
  

 v_testMessage:={1,2}; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010206_superset_004());
}

}
 /***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of superset definition
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

 //Restriction e)
/*The individual members of the SuperSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms omit, SuperSet, SubSet and the matching attributes (length restriction
and ifpresent). In addition, the individual members shall not resolve to AnyValueOrNone and individual
elements of the template in the all from clause shall not resolve to AnyElementsOrNone or permutation.*/

module Sem_B010206_superset_005 { 

  	type set of integer SoI;

    type port loopbackPort message {
	  inout SoI
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010206_superset_005() runs on GeneralComp {

    var SoI v_testMessage;

 template SoI Template:= {1,2} length(1..10);
 template SoI mw_matchingTemplate:= superset(all from Template);
  

 v_testMessage:={1,2}; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010206_superset_005());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of superset definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010206_superset_002 { 


	type record MessageType {
  	 set of integer	field1
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010206_superset_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := superset(1,2)	//no match for element 2
 } 

 v_testMessage:=  {  
  field1 := {1,3,4}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010206_superset_002());
}

}
 /***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.6, Ensure that the IUT correctly handles template matching of superset definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

 //Restriction e)
/*The individual members of the SuperSet's argument and the elements of the template in the all from clause
shall not be the matching mechanisms omit, SuperSet, SubSet and the matching attributes (length restriction
and ifpresent). In addition, the individual members shall not resolve to AnyValueOrNone and individual
elements of the template in the all from clause shall not resolve to AnyElementsOrNone or permutation.*/

module Sem_B010206_superset_007 { 

  	type set of integer SoI;

    type port loopbackPort message {
	  inout SoI
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010206_superset_007() runs on GeneralComp {

    var SoI v_testMessage;

 template SoI Template:= {1,?};
 template SoI mw_matchingTemplate:= superset(all from Template);
  

 v_testMessage:={1,2}; 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010206_superset_007());
}

}
 /***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.4, Ensure that AnyValueOrNone can be assigned to top-level template 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// It can be assigned to templates of any type as a whole.

module Sem_B010204_any_value_or_none_002 { 

	template integer t_anyOrNone := *; // top-level static template
	

	type component GeneralComp {
	}	
	
	function f(in template integer p1) {
	}
		
	testcase TC_Sem_B010204_any_value_or_none_002() runs on GeneralComp {
	
	    var template integer vt_anyOrNone := *; // top-level template variable
		f(*); // top-level template parameter
		setverdict(pass);
	}
	
	control{
	    execute(TC_Sem_B010204_any_value_or_none_002());
	}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.4, Ensure that the IUT correctly handles template matching of * values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010204_any_value_or_none_001 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1 optional, 
  	 charstring  	field2 optional, 
  	 EnumeratedType field3 optional,
  	 RecordType		field4 optional,
  	 UnionType		field5 optional,
  	 RecordType		field6
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010204_any_value_or_none_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := *,
  field2 := *, 
  field3 := *,
  field4 := *, 
  field5 := *,
  field6 := {a:=1,b:=*,c:=true}
 } 

 v_testMessage:=  {  
  field1 := 2,
  field2 := "test string", 
  field3 := e_black,
  field4 := {a:=1,b:=omit,c:=true}, 
  field5 := {a:=1},
  field6 := {a:=1,b:=omit,c:=true}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010204_any_value_or_none_001());
}

}
 /***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.4, Ensure that AnyValueOrNone can be used for matching optional fields
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// At the time of matching, it shall be applied to optional fields of record and set 
// templates only.

module Sem_B010204_any_value_or_none_003 { 

	type set Set1 {
		integer field1,
		integer field2 optional
	}
	template integer t_anyOrNone := *; // top-level static template	

	type component GeneralComp {
	}	
	
	testcase TC_Sem_B010204_any_value_or_none_003() runs on GeneralComp {
		var Set1 v_val := { field1 := 5, field2 := 23 };
	    if (match(v_val.field2, t_anyOrNone)) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control{
	    execute(TC_Sem_B010204_any_value_or_none_003());
	}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.5, Ensure that the IUT correctly handles template matching of value range definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010205_value_range_002 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 RecordType		field3,
  	 UnionType		field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010205_value_range_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := (0..1),			//value is out of range
  field2 := ("a".."f") length (3),
  field3 := {a:=1,b:=(0..2),c:=true}, 
  field4 := {a:=(0..2)}
 } 

 v_testMessage:=  {  
  field1 := 2,
  field2 := "abc", 
  field3 := {a:=1,b:=2,c:=true}, 
  field4 := {a:=1}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010205_value_range_002());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.5, Ensure that the IUT correctly handles template matching of value range definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010205_value_range_006 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 float  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 RecordType		field3,
  	 UnionType		field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010205_value_range_006() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := (0..2),		
  field2 := ("a".."f") length (3), //character is out of range because of an empty character
  field3 := {a:=1,b:=(0..2),c:=true}, 	
  field4 := {a:=(1.0 .. 2.0)}	
 } 

 v_testMessage:=  {  
  field1 := 2,
  field2 := "ab", 
  field3 := {a:=1,b:=2,c:=true}, 
  field4 := {a:=1.0}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010205_value_range_006());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.5, Ensure that the IUT correctly handles template matching of value range definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010205_value_range_001 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 RecordType		field3,
  	 UnionType		field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010205_value_range_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := (0..2),
  field2 := ("a".."f") length (3),
  field3 := {a:=1,b:=(0..2),c:=true}, 
  field4 := {a:=(0..2)}
 } 

 v_testMessage:=  {  
  field1 := 2,
  field2 := "abc", 
  field3 := {a:=1,b:=2,c:=true}, 
  field4 := {a:=1}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010205_value_range_001());
}

}
 /***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.5, Ensure that the IUT correctly handles template matching of value range definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010205_value_range_008 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 RecordType		field3,
  	 UnionType		field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010205_value_range_008() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := (!0..2),			//value is out of range because of exclusive lower boundary
  field2 := ("a".."f") length (3),
  field3 := {a:=1,b:=(0..2),c:=true}, 
  field4 := {a:=(0..2)}
 } 

 v_testMessage:=  {  
  field1 := 0,
  field2 := "abc", 
  field3 := {a:=1,b:=2,c:=true}, 
  field4 := {a:=1}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010205_value_range_008());
}

}
 /***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.5, Ensure that the IUT correctly handles template matching of value range definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010205_value_range_007 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 RecordType		field3,
  	 UnionType		field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010205_value_range_007() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := (0..!2),			//value is out of range because of exclusive upper boundary
  field2 := ("a".."f") length (3),
  field3 := {a:=1,b:=(0..2),c:=true}, 
  field4 := {a:=(0..2)}
 } 

 v_testMessage:=  {  
  field1 := 2,
  field2 := "abc", 
  field3 := {a:=1,b:=2,c:=true}, 
  field4 := {a:=1}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010205_value_range_007());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.5, Ensure that the IUT correctly handles template matching of value range definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010205_value_range_005 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 float  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 RecordType		field3,
  	 UnionType		field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010205_value_range_005() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := (0..2),		
  field2 := ("a".."f") length (3), //character is out of range
  field3 := {a:=1,b:=(0..2),c:=true}, 	
  field4 := {a:=(1.0 .. 2.0)}	
 } 

 v_testMessage:=  {  
  field1 := 2,
  field2 := "akc", 
  field3 := {a:=1,b:=2,c:=true}, 
  field4 := {a:=1.0}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010205_value_range_005());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.5, Ensure that the IUT correctly handles template matching of value range definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010205_value_range_003 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 RecordType		field3,
  	 UnionType		field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010205_value_range_003() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := (0..2),		
  field2 := ("a".."f") length (3),
  field3 := {a:=1,b:=(0..1),c:=true}, 	//value is out of range
  field4 := {a:=(0..2)}
 } 

 v_testMessage:=  {  
  field1 := 2,
  field2 := "abc", 
  field3 := {a:=1,b:=2,c:=true}, 
  field4 := {a:=1}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010205_value_range_003());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.5, Ensure that the IUT correctly handles template matching of value range definitions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010205_value_range_004 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 float  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 RecordType		field3,
  	 UnionType		field4
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010205_value_range_004() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := (0..2),		
  field2 := ("a".."f") length (3),
  field3 := {a:=1,b:=(0..2),c:=true}, 	
  field4 := {a:=(1.000001 .. 2.0)}		//float value is out of range
 } 

 v_testMessage:=  {  
  field1 := 2,
  field2 := "abc", 
  field3 := {a:=1,b:=2,c:=true}, 
  field4 := {a:=1.0}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010205_value_range_004());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.2, Ensure that the IUT correctly handles template matching of complemented value listing 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010202_complemented_value_list_001 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 EnumeratedType field3,
  	 RecordType		field4,
  	 UnionType		field5
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010202_complemented_value_list_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := complement(1,2),
  field2 := complement("test string","something else"), 
  field3 := complement(e_green,e_black),
  field4 := complement({a:=1,b:=1,c:=false},{a:=1,b:=2,c:=true}), 
  field5 := complement({a:=1},{b:=e_white})
 } 

 v_testMessage:=  {  
  field1 := 0,
  field2 := "test", 
  field3 := e_white,
  field4 := {a:=1,b:=2,c:=false}, 
  field5 := {a:=2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010202_complemented_value_list_001());
}

}
 /***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.2, Ensure that the IUT correctly handles template matching of complemented value omit 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

//Restriction e) The complement of a template list shall not match omit.

module Sem_B010202_complemented_value_list_008 { 

type record MyRec{
     integer field1,
     float   field2 optional
    }

    type port loopbackPort message {
	  inout MyRec
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010202_complemented_value_list_008() runs on GeneralComp {

    var MyRec v_testMessage;

 template MyRec mw_matchingTemp:={field1:=1,field2:=omit};
    
 template MyRec mw_matchingTemplate:=complement(mw_matchingTemp);


 v_testMessage:= {field1:=11,field2:=omit};    // correct, field2 is omit and is not matched

 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010202_complemented_value_list_008());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.2, Ensure that the IUT correctly handles template matching of complemented value listing 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010202_complemented_value_list_002 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 EnumeratedType field3,
  	 RecordType		field4,
  	 UnionType		field5
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010202_complemented_value_list_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := complement(1,2),
  field2 := complement("test string","something else"), 
  field3 := complement(e_green,e_black),
  field4 := complement({a:=1,b:=1,c:=false},{a:=1,b:=2,c:=true}), 
  field5 := complement({a:=1},{b:=e_white})
 } 

 v_testMessage:=  {  
  field1 := 2,	//mismatching complement in the template
  field2 := "test", 
  field3 := e_white,
  field4 := {a:=1,b:=2,c:=false}, 
  field5 := {a:=2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010202_complemented_value_list_002());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.2, Ensure that the IUT correctly handles template matching of complemented value listing 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010202_complemented_value_list_006 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 EnumeratedType field3,
  	 RecordType		field4,
  	 UnionType		field5
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010202_complemented_value_list_006() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := complement(1,2),
  field2 := complement("test string","something else"), 
  field3 := complement(e_green,e_black),
  field4 := complement({a:=1,b:=1,c:=false},{a:=1,b:=2,c:=true}), 
  field5 := complement({a:=1},{b:=e_white})
 } 

 v_testMessage:=  {  
  field1 := 0,	
  field2 := "test ",
  field3 := e_white,	
  field4 := {a:=1,b:=2,c:=false}, 
  field5 := {b:=e_white} //mismatching complement in the template
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010202_complemented_value_list_006());
}

}
 /***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.2, Ensure that the IUT correctly handles template matching of complemented value listing 
 ** @verdict  pass reject
 ***************************************************/

module NegSem_B010202_complemented_value_list_007 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

    type record MessageType {
     integer  		field1, 
     charstring  	field2, 
     EnumeratedType field3,
     RecordType		field4,
     UnionType		field5
    }

    type record of integer RoI;

    type port loopbackPort message {
	  inout MessageType
	}

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010202_complemented_value_list_007() runs on GeneralComp {

    var MessageType v_testMessage;

    template RoI m_RoI1 := {1, 2, (6..9)};

    template MessageType mw_matchingTemplate:= 
    {
     field1 := complement(all from m_RoI1, 100),//The type of the complemented template list and the member type of the template in the all from clause shall be compatible
     field2 := complement("test string","something else"), 
     field3 := complement(e_green,e_black),
     field4 := complement({a:=1,b:=1,c:=false},{a:=1,b:=2,c:=true}), 
     field5 := complement({a:=1},{b:=e_white})
    } 

    v_testMessage:=  {  
     field1 := 0,	
     field2 := "test ",
     field3 := e_white,	
     field4 := {a:=1,b:=2,c:=false}, 
     field5 := {a:=2}
    } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010202_complemented_value_list_007());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.2, Ensure that the IUT correctly handles template matching of complemented value listing 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010202_complemented_value_list_005 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 EnumeratedType field3,
  	 RecordType		field4,
  	 UnionType		field5
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010202_complemented_value_list_005() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := complement(1,2),
  field2 := complement("test string","something else"), 
  field3 := complement(e_green,e_black),
  field4 := complement({a:=1,b:=1,c:=false},{a:=1,b:=2,c:=true}), 
  field5 := complement({a:=1},{b:=e_white})
 } 

 v_testMessage:=  {  
  field1 := 0,	
  field2 := "test ",
  field3 := e_white,	
  field4 := {a:=1,b:=2,c:=true}, //mismatching complement in the template 
  field5 := {a:=2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010202_complemented_value_list_005());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.2, Ensure that the IUT correctly handles template matching of complemented value listing 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010202_complemented_value_list_003 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 EnumeratedType field3,
  	 RecordType		field4,
  	 UnionType		field5
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010202_complemented_value_list_003() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := complement(1,2),
  field2 := complement("test string","something else"), 
  field3 := complement(e_green,e_black),
  field4 := complement({a:=1,b:=1,c:=false},{a:=1,b:=2,c:=true}), 
  field5 := complement({a:=1},{b:=e_white})
 } 

 v_testMessage:=  {  
  field1 := 0,	
  field2 := "test string",	//mismatching complement in the template 
  field3 := e_white,
  field4 := {a:=1,b:=2,c:=false}, 
  field5 := {a:=2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010202_complemented_value_list_003());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.2, Ensure that the IUT correctly handles template matching of complemented value listing 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010202_complemented_value_list_004 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 EnumeratedType field3,
  	 RecordType		field4,
  	 UnionType		field5
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010202_complemented_value_list_004() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := complement(1,2),
  field2 := complement("test string","something else"), 
  field3 := complement(e_green,e_black),
  field4 := complement({a:=1,b:=1,c:=false},{a:=1,b:=2,c:=true}), 
  field5 := complement({a:=1},{b:=e_white})
 } 

 v_testMessage:=  {  
  field1 := 0,	
  field2 := "test ",
  field3 := e_green,	//mismatching complement in the template 
  field4 := {a:=1,b:=2,c:=false}, 
  field5 := {a:=2}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010202_complemented_value_list_004());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.1, Ensure that the IUT correctly handles template matching of listed multiple values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010201_value_list_001 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 EnumeratedType field3,
  	 RecordType		field4,
  	 UnionType		field5
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010201_value_list_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := (1,2),
  field2 := ("test string","something else"), 
  field3 := (e_green,e_black),
  field4 := ({a:=1,b:=1,c:=false},{a:=1,b:=2,c:=true}), 
  field5 := ({a:=1},{b:=e_white})
 } 

 v_testMessage:=  {  
  field1 := 2,
  field2 := "test string", 
  field3 := e_black,
  field4 := {a:=1,b:=2,c:=true}, 
  field5 := {a:=1}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010201_value_list_001());
}

}
 /***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:B.1.2.8, Ensure that the IUT correctly handles content decoding 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

//Restriction a)
/*It can be assigned to templates and template fields of bitstring, hexstring, octetstring,
charstring and universal charstring types.*/

module Sem_B010209_decoded_content_001 { 

	type record MessageType {
	  bitstring payload
	}
	
	type record Mymessage {
	  integer field1,
	  bitstring field2 optional
    }
	

    type port loopbackPort message{inout MessageType};
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010209_decoded_content_001() runs on GeneralComp {
    var bitstring v_enc;
    var Mymessage v_testMessage;
    var MessageType Message;
    
    v_testMessage:=  {  
        field1 := 10,
        field2 := '1001'B
     } 

      Message.payload := encvalue(v_testMessage);		//encode message to payload
          
    
    

 template MessageType mw_matchingTemplate:=
  {  			
  //TODO: payload :=  decmatch Mymessage: {field1:= 10, field2 := '1001'B}
  } 


  messagePort.send(Message);	//send message

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
    
}

control{
    execute(TC_Sem_B010209_decoded_content_001());
}

}
 /***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:B.1.2.8, Ensure that the IUT correctly handles content decoding 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

//Restriction a)
/*It can be assigned to templates and template fields of bitstring, hexstring, octetstring,
charstring and universal charstring types.*/

module Sem_B010209_decoded_content_003 { 

	type record MessageType {
	  octetstring payload
	}
	
	type record Mymessage {
	  integer field1,
	  bitstring field2 optional
    }
	

    type port loopbackPort message{inout MessageType};
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010209_decoded_content_003() runs on GeneralComp {
    var bitstring v_enc;
    var Mymessage v_testMessage;
    var MessageType Message;
    
    v_testMessage:=  {  
        field1 := 10,
        field2 := '1001'B
     } 

      Message.payload := bit2oct(encvalue(v_testMessage));		//encode message to payload, octetstring
          
    
    

 template MessageType mw_matchingTemplate:=
  {  			
  //TODO: payload :=  decmatch Mymessage: {field1:= 10, field2 := '1001'B}
  } 


  messagePort.send(Message);	//send message

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
    
}

control{
    execute(TC_Sem_B010209_decoded_content_003());
}

}
 /***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:B.1.2.8, Ensure that the IUT correctly handles content decoding 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

//Restriction a)
/*It can be assigned to templates and template fields of bitstring, hexstring, octetstring,
charstring and universal charstring types.*/


module Sem_B010209_decoded_content_005 { 

	type record MessageType {
	  universal charstring payload
	}
	
	type record Mymessage {
	  integer field1,
	 universal charstring field2 optional
    }
	

    type port loopbackPort message{inout MessageType};
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010209_decoded_content_005() runs on GeneralComp {

    var Mymessage v_testMessage;
    var MessageType Message;
    
    v_testMessage:= {1,"A"} ;

      Message.payload :=any2unistr(v_testMessage);		//encode message to payload,universal charstring UTF-8
          
    
    

 template MessageType mw_matchingTemplate:=
  {  			
  //TODO: payload :=  decmatch("UTF-8") Mymessage: {1,"A"}
  } 


  messagePort.send(Message);	//send message

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail,mw_matchingTemplate.payload);
     }
    }
    
}

control{
    execute(TC_Sem_B010209_decoded_content_005());
}

}
 /***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:B.1.2.8, Ensure that the IUT correctly handles content decoding 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

//Restriction a)
/*It can be assigned to templates and template fields of bitstring, hexstring, octetstring,
charstring and universal charstring types.*/


module Sem_B010209_decoded_content_004 { 

	type record MessageType {
	  charstring payload
	}
	
	type record Mymessage {
	  integer field1,
	  bitstring field2 optional
    }
	

    type port loopbackPort message{inout MessageType};
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010209_decoded_content_004() runs on GeneralComp {
    var bitstring v_enc;
    var Mymessage v_testMessage;
    var MessageType Message;
    
    v_testMessage:=  {  
        field1 := 10,
        field2 := '1001'B
     } 

      Message.payload := bit2str(encvalue(v_testMessage));		//encode message to payload, charstring
          
    
    

 template MessageType mw_matchingTemplate:=
  {  			
  //TODO: payload :=  decmatch Mymessage: {field1:= 10, field2 := '1001'B}
  } 


  messagePort.send(Message);	//send message

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail,mw_matchingTemplate);
     }
    }
    
}

control{
    execute(TC_Sem_B010209_decoded_content_004());
}

}
 /***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:B.1.2.8, Ensure that the IUT correctly handles content decoding 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

//Restriction a)
/*It can be assigned to templates and template fields of bitstring, hexstring, octetstring,
charstring and universal charstring types.*/

module Sem_B010209_decoded_content_002 { 

	type record MessageType {
	  hexstring payload
	}
	
	type record Mymessage {
	  integer field1,
	  bitstring field2 optional
    }
	

    type port loopbackPort message{inout MessageType};
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010209_decoded_content_002() runs on GeneralComp {
    var bitstring v_enc;
    var Mymessage v_testMessage;
    var MessageType Message;
    
    v_testMessage:=  {  
        field1 := 10,
        field2 := '1001'B
     } 

      Message.payload := bit2hex(encvalue(v_testMessage));		//encode message to payload, hexstring
          
    
    

 template MessageType mw_matchingTemplate:=
  {  			
  //TODO: payload :=  decmatch Mymessage: {field1:= 10, field2 := '1001'B}
  } 


  messagePort.send(Message);	//send message

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
    
}

control{
    execute(TC_Sem_B010209_decoded_content_002());
}

}
 /***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.8, Ensure that the IUT correctly handles template matching of omit values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010208_omit_value_004 { 

	type record MessageType {
  	 integer  		field1, 
     MyRecordof		field2 optional,
  	 boolean		field3 optional
	}
	
    type record of integer MyRecordof;

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010208_omit_value_004() runs on GeneralComp {

    var MessageType v_testMessage;
    var boolean v_boolean;
    template MyRecordof mw_MyRecofTemplate := omit; 	// this assignment is allowed
    template boolean mw_MyBoolTemplate := omit; 		// this assignment is allowed
    

 template MessageType mw_matchingTemplate:= 
 {  			
  field1 := ?,
  field2 := mw_MyRecofTemplate,
  field3 := mw_MyBoolTemplate
 } 

 v_testMessage:=  {  
  field1 := 2,
  field2 := omit, 
  field3 := omit
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        v_boolean := match({2,omit,omit},mw_matchingTemplate);// matches and returns true
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010208_omit_value_004());
}

}
 /***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.8, Ensure that the IUT correctly handles template matching of omit values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010208_omit_value_002 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2 optional, 
  	 EnumeratedType field3 optional,
  	 RecordType		field4 optional,
  	 UnionType		field5 optional,
  	 RecordType		field6 optional,
  	 UnionType		field7 optional
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010208_omit_value_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  			
  field1 := ?,
  field2 := *,
  field3 := *,
  field4 := *,
  field5 := *,
  field6 := {a:=1,b:=omit,c:=true},    //omits the optional field
  field7 := *
 } 

 v_testMessage:=  {  
  field1 := 2,
  field2 := omit, 
  field3 := omit,
  field4 := omit, 
  field5 := omit,
  field6 := {a:=1,b:=omit,c:=true}, 
  field7 := omit
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010208_omit_value_002());
}

}
 /***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.8, Ensure that the IUT correctly handles template matching of omit values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010208_omit_value_001 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2 optional, 
  	 EnumeratedType field3 optional,
  	 RecordType		field4 optional,
  	 UnionType		field5 optional,
  	 RecordType		field6 optional,
  	 UnionType		field7 optional
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010208_omit_value_001() runs on GeneralComp {

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := ?,
  field2 := omit, 
  field3 := omit,
  field4 := omit, 
  field5 := omit,
  field6 := omit, 
  field7 := omit
 } 

 var MessageType v_testMessage:=  {
  field1 := 2,
  field2 := omit, 
  field3 := omit,
  field4 := omit, 
  field5 := omit,
  field6 := omit, 
  field7 := omit
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010208_omit_value_001());
}

}
 /***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.8, Ensure that the IUT correctly handles template matching of omit values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010208_omit_value_003 { 

	type record MessageType {
  	 integer  		field1, 
     MyRecordof		field2 optional,
  	 boolean		field3 optional
	}
	
    type record of integer MyRecordof;

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010208_omit_value_003() runs on GeneralComp {

    var MessageType v_testMessage;
    var boolean v_boolean;
    template MyRecordof mw_MyRecofTemplate := omit; 	// this assignment is allowed
    template boolean mw_MyBoolTemplate := omit; 		// this assignment is allowed
    

 template MessageType mw_matchingTemplate:= 
 {  			
  field1 := ?,
  field2 := mw_MyRecofTemplate,
  field3 := mw_MyBoolTemplate
 } 

 v_testMessage:=  {  
  field1 := 2,
  field2 := omit, 
  field3 := omit
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010208_omit_value_003());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.3, Ensure that the IUT correctly handles template matching of ? values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010203_any_value_002 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 EnumeratedType field3,
  	 RecordType		field4,
  	 UnionType		field5,
  	 RecordType		field6,
  	 UnionType		field7
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010203_any_value_002() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  			
  field1 := ?,
  field2 := ?, 
  field3 := ?,
  field4 := ?, 
  field5 := ?,
  field6 := {a:=1,b:=?,c:=true}, 	//omitted value does not match ?
  field7 := {a:=?}
 } 

 v_testMessage:=  {  
  field1 := 2,
  field2 := "test string", 
  field3 := e_black,
  field4 := {a:=1,b:=omit,c:=true}, 
  field5 := {a:=1},
  field6 := {a:=1,b:=omit,c:=true}, 
  field7 := {a:=1}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_B010203_any_value_002());
}

}
 /***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:B.1.2.3, Ensure that the IUT correctly handles template matching of ? values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_B010203_any_value_001 { 

	type enumerated EnumeratedType {e_black, e_white, e_green};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 EnumeratedType field3,
  	 RecordType		field4,
  	 UnionType		field5,
  	 RecordType		field6,
  	 UnionType		field7
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_B010203_any_value_001() runs on GeneralComp {

 template MessageType mw_matchingTemplate:= 
 {  	
  field1 := ?,
  field2 := ?, 
  field3 := ?,
  field4 := ?, 
  field5 := ?,
  field6 := {a:=1,b:=?,c:=true}, 
  field7 := {a:=?}
 } 

 var MessageType v_testMessage:=  {
  field1 := 2,
  field2 := "test string", 
  field3 := e_black,
  field4 := {a:=1,b:=omit,c:=true}, 
  field5 := {a:=1},
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1}
 } 
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_B010203_any_value_001());
}

}
 /*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.5, Ensure that the bitwise negation operator works as expected on hexstrings.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070105_BitwiseOperators_002 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070105_BitwiseOperators_002() runs on GeneralComp {
	var hexstring v_test := '1A5'H;
	var hexstring v_result := not4b v_test;
	
	if (v_result == 'E5A'H) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070105_BitwiseOperators_002());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.5, Ensure that the bitwise negation operator works as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070105_BitwiseOperators_001 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070105_BitwiseOperators_001() runs on GeneralComp {
	var bitstring v_test := '1'B;
	var bitstring v_result := not4b v_test;
	
	if (v_result == '0'B) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070105_BitwiseOperators_001());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the application of the modulo operator on integer variables is evaluated correctly when two consecutive modulo operators are applied.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_013 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_013() runs on GeneralComp {
	var integer v_i := 11;
	var integer v_result := (v_i mod 6) mod 3;
	
	if (v_result == 2) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_013());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the application of the remainder operator on integer variables is evaluated correctly when the operand is a negative integer.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_015 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_015() runs on GeneralComp {
	var integer v_i := -2;
	var integer v_result := (v_i rem 3);
	
	if (v_result == -2) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_015());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the division of multiple integer variables is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_009 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_009() runs on GeneralComp {
	var integer v_i := 100;
	var integer v_j := 4;
	var integer v_k := 5;
	var integer v_result := v_i / v_j / v_k;
	
	if (v_result == 5) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_009());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the multiplication of multiple integer variables is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_007 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_007() runs on GeneralComp {
	var integer v_i := 10;
	var integer v_j := 2;
	var integer v_k := 4;
	var integer v_l := 3;
	var integer v_result := v_i * v_j * v_k * v_l;
	
	if (v_result == 240) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_007());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the application of the modulo operator on integer variables is evaluated correctly when the integer value is smaller than the modulo value.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_011 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_011() runs on GeneralComp {
	var integer v_i := 8;
	var integer v_result := v_i mod 10;
	
	if (v_result == 8) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_011());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_035 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_035() runs on GeneralComp {
	var float v_i := not_a_number;
	var float v_k :=2.0E0;
	
	var float v_result := v_i + v_k;	// "+" arithmetic operator with NaN
	
	if (v_result == not_a_number) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_035());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_032 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_032() runs on GeneralComp {
	var float v_i := -infinity;
	var float v_k :=2.0E0;
	
	var float v_result := v_i - v_k;	// "-" arithmetic operator with -infinity
	
	if (v_result == -infinity) { setverdict(pass,"match") }
	else { setverdict(fail, v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_032());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the substraction of two integer variables is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_004 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_004() runs on GeneralComp {
	var integer v_i := 10;
	var integer v_j := 2;
	var integer v_result := v_i - v_j;
	
	if (v_result == 8) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_004());
}

}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the operator precedence is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_024 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_024() runs on GeneralComp {
	var integer v_i := 4;
	var integer v_j := 12;
	var integer v_k := 18;
	var integer v_l := 3;
	
	var integer v_result := v_i+v_j-v_k / v_l;
	
	if (v_result == 10) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_024());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the application of the modulo operator on integer variables is evaluated correctly when the integer value greater than the modulo value.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_012 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_012() runs on GeneralComp {
	var integer v_i := 12;
	var integer v_result := v_i mod 10;
	
	if (v_result == 2) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_012());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_070101_ArithmeticOperators_046 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_046() runs on GeneralComp {
	var float v_i := -infinity;
	var float v_k := infinity;
	
	var float v_result := v_k / v_i;	// infinity special float as nominator and -infinity special float as denominator
	
	if (v_result == not_a_number) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_046());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the application of the modulo operator on integer variables is evaluated correctly when the operand is a negative integer.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_014 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_014() runs on GeneralComp {
	var integer v_i := -2;
	var integer v_result := (v_i mod 3);
	
	if (v_result == 1) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_014());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

/* Restriction c)	With the exception of the equality and non-equality operators, the special value null shall not be used as an operand of expressions (see clause 7.1.3).*/

module Sem_070101_ArithmeticOperators_050 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_050() runs on GeneralComp {
	var float v_i := not_a_number;
	var float v_k := -infinity;
	
	var float v_result := v_i / v_k;	// -infinity special float as denominator and NaN special float as nominator
	
	if (v_result == not_a_number) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_050());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_036 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_036() runs on GeneralComp {
	var float v_i := not_a_number;
	var float v_k :=2.0E0;
	
	var float v_result := v_i - v_k;	// "-" arithmetic operator with NaN
	
	if (v_result == not_a_number) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_036());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the addition operator on float constants is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_070101_ArithmeticOperators_008 {

const float c_result := 10.2 + 0.4;

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the consecutive application of the remainder operator and the modulo operator on integer variables is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_017 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_017() runs on GeneralComp {
	var integer v_i := -2;
	var integer v_result := (v_i rem 3) mod 3;
	
	if (v_result == 1) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_017());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_037 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_037() runs on GeneralComp {
	var float v_i := not_a_number;
	var float v_k :=2.0E0;
	
	var float v_result := v_i * v_k;	// "*" arithmetic operator with NaN
	
	if (v_result == not_a_number) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_037());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_070101_ArithmeticOperators_043 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_043() runs on GeneralComp {
	var float v_i := infinity;
	var float v_k := infinity;
	
	var float v_result := v_k / v_i;	// infinity special float as nominator and denominator
	
	if (v_result == not_a_number) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_043());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the multiplication of two integer variables is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_006 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_006() runs on GeneralComp {
	var integer v_i := 10;
	var integer v_j := 2;
	var integer v_result := v_i * v_j;
	
	if (v_result == 20) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_006());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the substraction of two integers in a constant is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_070101_ArithmeticOperators_002 {

const integer c_result := 10 - 2;

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the division of two integers in a constant is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_070101_ArithmeticOperators_004 {

const integer c_result := 10 / 3;

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/



module Sem_070101_ArithmeticOperators_040 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_040() runs on GeneralComp {
	var float v_i := -infinity;
	var float v_k :=2.0E0;
	
	var float v_result := v_k / v_i;	// -Infinity special float as denominator 
	
	if (v_result == 0.0) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_040());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_034 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_034() runs on GeneralComp {
	var float v_i := -infinity;
	var float v_k :=2.0E0;
	
	var float v_result := v_i / v_k;	// "/" arithmetic operator with -infinity
	
	if (v_result == -infinity) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_034());
}

}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the operator precedence is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_026 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_026() runs on GeneralComp {
	var integer v_i0 := 40;
	var integer v_i1 := 6;
	var integer v_i2 := 3;
	
	var integer v_result := v_i0 rem v_i1 mod v_i2; // equal precendence, then left-right evalution
	
	if (v_result == 1) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_026());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the addition of two integers in a constant is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_070101_ArithmeticOperators_001 {

const integer c_result := 10 + 2;

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_070101_ArithmeticOperators_047 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_047() runs on GeneralComp {
	var float v_i := not_a_number;
	var float v_k := infinity;
	
	var float v_result := v_k / v_i;	// infinity special float as nominator and NaN special float as denominator
	
	if (v_result == not_a_number) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_047());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_030 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_030() runs on GeneralComp {
	var float v_i := infinity;
	var float v_k :=2.0E0;
	
	var float v_result := v_i / v_k;	// "/" arithmetic operator with infinity
	
	if (v_result == infinity) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_030());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the combination of different operators works on float variables.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_023 {

type component GeneralComp {	    	    
}

/**
 * @desc Equals method for floats
 * @return true if abs(f1 - f2) < 1.E-6
 */
function f_isFloatNear(in float f1, in float f2) return boolean {
  var float delta := f1-f2;
  if (delta < 0.0) {
    delta := 0.0 - delta;
  }
  return delta < 1E-6;
}

testcase TC_Sem_070101_ArithmeticOperators_023() runs on GeneralComp {
	var float v_i := 10.2;
	var float v_result := (((v_i * 2.3) / 0.4)+0.45)-0.1;
	
	if ( f_isFloatNear(v_result,59.0) ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_023());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the addition of multiple integer variables is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_002 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_002() runs on GeneralComp {
	var integer v_i := 10;
	var integer v_j := 2;
	var integer v_k := 4;
	var integer v_l := 6;
	var integer v_result := v_i + v_j + v_k + v_l;
	
	if (v_result == 22) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_002());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_029 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_029() runs on GeneralComp {
	var float v_i := infinity;
	var float v_k :=2.0E0;
	
	var float v_result := v_i * v_k;	// "*" arithmetic operator with infinity
	
	if (v_result == infinity) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_029());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the division of two integer variables is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_008 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_008() runs on GeneralComp {
	var integer v_i := 10;
	var integer v_j := 2;
	var integer v_result := v_i / v_j;
	
	if (v_result == 5) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_008());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/



module Sem_070101_ArithmeticOperators_039 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_039() runs on GeneralComp {
	var float v_i := infinity;
	var float v_k :=2.0E0;
	
	var float v_result := v_k / v_i;	// Infinity special float as denominator 
	
	if (v_result == 0.0) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_039());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the not equal to operator on address with value null is evaulated correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

/* Restriction c)	With the exception of the equality and non-equality operators, the special value null shall not be used as an operand of expressions (see clause 7.1.3).*/


module Sem_070101_ArithmeticOperators_052 {

type component GeneralComp {	    	    
}

type integer address;
    
testcase TC_Sem_070101_ArithmeticOperators_052() runs on GeneralComp {
    
    var address My_address := 1;   
    
    
	if (My_address != null) 
    {
		setverdict(pass, My_address);
	} else {
		setverdict(fail,My_address);
	}
}

control{
    execute(TC_Sem_070101_ArithmeticOperators_052());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_070101_ArithmeticOperators_045 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_045() runs on GeneralComp {
	var float v_i := infinity;
	var float v_k := -infinity;
	
	var float v_result := v_k / v_i;	// -infinity special float as nominator and infinity special float as denominator
	
	if (v_result == not_a_number) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_045());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that operator combinations on integers is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_070101_ArithmeticOperators_007 {

const integer c_result := (((((100 mod 75)/5)*2)+10)-22) rem 3;

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the division operator on float constants is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_070101_ArithmeticOperators_011 {

const float c_result := 10.2 / 0.4;

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the substraction operator on float constants is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_070101_ArithmeticOperators_009 {

const float c_result := 10.2 - 0.4;

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the addition of two integer variables is evaluated correctly when the expression contains a negative value.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_003 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_003() runs on GeneralComp {
	var integer v_i := -10;
	var integer v_j := 2;
	var integer v_result := v_i + v_j;
	
	if (v_result == -8) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_003());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that operator combinations and the modulo operator on integer variables is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_018 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_018() runs on GeneralComp {
	var integer v_i := 100;
	var integer v_result := (((((v_i mod 75)/5)*2)+10)-22) rem 3;
	
	if (v_result == -2) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_018());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the substraction of multiple integer variables is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_005 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_005() runs on GeneralComp {
	var integer v_i := 10;
	var integer v_j := 2;
	var integer v_k := 12;
	var integer v_result := v_i - v_j - v_k;
	
	if (v_result == -4) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_005());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the substraction operator works on float variables.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_020 {

type component GeneralComp {	    	    
}

/**
 * @desc Equals method for floats
 * @return true if abs(f1 - f2) < 1.E-6
 */
function f_isFloatNear(in float f1, in float f2) return boolean {
  var float delta := f1-f2;
  if (delta < 0.0) {
    delta := 0.0 - delta;
  }
  return delta < 1E-6;
}

testcase TC_Sem_070101_ArithmeticOperators_020() runs on GeneralComp {
	var float v_i := 10.2;
	var float v_j := 0.4;
	var float v_result := v_i - v_j;
	
	if ( f_isFloatNear(v_result,9.8) ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_020());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_070101_ArithmeticOperators_048 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_048() runs on GeneralComp {
	var float v_i := not_a_number;
	var float v_k := -infinity;
	
	var float v_result := v_k / v_i;	// -infinity special float as nominator and NaN special float as denominator
	
	if (v_result == not_a_number) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_048());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the addition of two integer variables is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_001 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_001() runs on GeneralComp {
	var integer v_i := 10;
	var integer v_j := 2;
	var integer v_result := v_i + v_j;
	
	if (v_result == 12) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_001());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_027 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_027() runs on GeneralComp {
	var float v_i := infinity;
	var float v_k :=2.0E0;
	
	var float v_result := v_i + v_k;	// "+" arithmetic operator with infinity
	
	if (v_result == infinity) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_027());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that a combination of operators on float constants is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_070101_ArithmeticOperators_012 {
    const float c_i := 1.5;
	const float c_result := (((c_i * 2.3) / 0.4)+0.45)-0.1;

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the multiplication operator works on float variables.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_021 {

type component GeneralComp {	    	    
}

/**
 * @desc Equals method for floats
 * @return true if abs(f1 - f2) < 1.E-6
 */
function f_isFloatNear(in float f1, in float f2) return boolean {
  var float delta := f1-f2;
  if (delta < 0.0) {
    delta := 0.0 - delta;
  }
  return delta < 1E-6;
}

testcase TC_Sem_070101_ArithmeticOperators_021() runs on GeneralComp {
	var float v_i := 10.2;
	var float v_j := 0.4;
	var float v_result := v_i * v_j;
	
	if ( f_isFloatNear(v_result,4.08) ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_021());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_033 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_033() runs on GeneralComp {
	var float v_i := -infinity;
	var float v_k :=2.0E0;
	
	var float v_result := v_i * v_k;	// "*" arithmetic operator with -infinity
	
	if (v_result == -infinity) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_033());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the addition operator works on float variables.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_019 {

type component GeneralComp {	    	    
}

/**
 * @desc Equals method for floats
 * @return true if abs(f1 - f2) < 1.E-6
 */
function f_isFloatNear(in float f1, in float f2) return boolean {
  var float delta := f1-f2;
  if (delta < 0.0) {
    delta := 0.0 - delta;
  }
  return delta < 1E-6;
}

testcase TC_Sem_070101_ArithmeticOperators_019() runs on GeneralComp {
	var float v_i := 10.2;
	var float v_j := 0.4;
	var float v_result := v_i + v_j;
	
	if ( f_isFloatNear(v_result,10.6) ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_019());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the modulo operator on two integers is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_070101_ArithmeticOperators_005 {

const integer c_result := 10 mod 3;

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the equal to operator on address with value null is evaulated correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_051 {

type component GeneralComp {	    	    
}

type integer address;
    
testcase TC_Sem_070101_ArithmeticOperators_051() runs on GeneralComp {
    
    var address My_address := null;   
    
    
	if (My_address == null) 
    {
		setverdict(pass, My_address);
	} else {
		setverdict(fail,My_address);
	}
}

control{
    execute(TC_Sem_070101_ArithmeticOperators_051());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the multiplication operator on float constants is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_070101_ArithmeticOperators_010 {

const float c_result := 10.2 * 0.4;

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_031 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_031() runs on GeneralComp {
	var float v_i := -infinity;
	var float v_k :=2.0E0;
	
	var float v_result := v_i + v_k;	// "+" arithmetic operator with -infinity
	
	if (v_result == -infinity) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_031());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the application of the remainder operator on integer variables is evaluated correctly when the operand is a negative integer.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_016 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_016() runs on GeneralComp {
	var integer v_i := 2;
	var integer v_result := (v_i rem 3);
	
	if (v_result == 2) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_016());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the application of the modulo operator on integer variables is evaluated correctly when the remainder is zero.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_010 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_010() runs on GeneralComp {
	var integer v_i := 4;
	var integer v_result := v_i mod 2;
	
	if (v_result == 0) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_010());
}

}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the operator precedence is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_025 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_025() runs on GeneralComp {
	var integer v_i0 := 20;
	var integer v_i1 := 16;
	var integer v_i2 := 2;
	var integer v_j := 4;
	var integer v_k := 8;
	
	var integer v_result := v_i0 rem 3-v_j+v_i1/v_i2 mod 3*v_k;
	
	if (v_result == 14) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_025());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the remainder operator on two integers is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_070101_ArithmeticOperators_006 {

const integer c_result := -2 rem 3;

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the multiplication of two integers in a constant is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_070101_ArithmeticOperators_003 {

const integer c_result := 10 * 2;

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_070101_ArithmeticOperators_042 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_042() runs on GeneralComp {
	var float v_i := not_a_number;
	var float v_k :=not_a_number;
	
	var float v_result := v_k / v_i;	// NaN special float as nominator and denominator
	
	if (v_result == not_a_number) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_042());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_070101_ArithmeticOperators_049 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_049() runs on GeneralComp {
	var float v_i := not_a_number;
	var float v_k := infinity;
	
	var float v_result := v_i / v_k;	// infinity special float as denominator and NaN special float as nominator
	
	if (v_result == not_a_number) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_049());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_070101_ArithmeticOperators_041 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_041() runs on GeneralComp {
	var float v_i := not_a_number;
	var float v_k :=2.0E0;
	
	var float v_result := v_k / v_i;	// NaN special float as denominator 
	
	if (v_result == not_a_number) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_041());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that the division operator works on float variables.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_022 {

type component GeneralComp {	    	    
}

/**
 * @desc Equals method for floats
 * @return true if abs(f1 - f2) < 1.E-6
 */
function f_isFloatNear(in float f1, in float f2) return boolean {
  var float delta := f1-f2;
  if (delta < 0.0) {
    delta := 0.0 - delta;
  }
  return delta < 1E-6;
}

testcase TC_Sem_070101_ArithmeticOperators_022() runs on GeneralComp {
	var float v_i := 10.2;
	var float v_j := 0.4;
	var float v_result := v_i / v_j;
	
	if ( f_isFloatNear(v_result,25.5) ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070101_ArithmeticOperators_022());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_028 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_028() runs on GeneralComp {
	var float v_i := infinity;
	var float v_k :=2.0E0;
	
	var float v_result := v_i - v_k;	// "-" arithmetic operator with infinity
	
	if (v_result == infinity) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_028());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070101_ArithmeticOperators_038 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_038() runs on GeneralComp {
	var float v_i := not_a_number;
	var float v_k :=2.0E0;
	
	var float v_result := v_i / v_k;	// "/" arithmetic operator with NaN
	
	if (v_result == not_a_number) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_038());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.1, Ensure that arithmetic operators can handle special float values
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/


module Sem_070101_ArithmeticOperators_044 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070101_ArithmeticOperators_044() runs on GeneralComp {
	var float v_i := -infinity;
	var float v_k := -infinity;
	
	var float v_result := v_k / v_i;	// -infinity special float as nominator and denominator
	
	if (v_result == not_a_number) { setverdict(pass,"match") }
	else { setverdict(fail,v_result) }
    

}	
control{
    execute(TC_Sem_070101_ArithmeticOperators_044());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.4, Ensure that the the and operator with true and false as operands work on boolean variables.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070104_LogicalOperators_002 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070104_LogicalOperators_002() runs on GeneralComp {
	var boolean v_first := true;
	var boolean v_second := false;
	
	var boolean v_result := v_first and v_second;
	
	if (v_result == false) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070104_LogicalOperators_002());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.4, Ensure that the boolean operator supports negation.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070104_LogicalOperators_001 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070104_LogicalOperators_001() runs on GeneralComp {
	var boolean v_test := true;
	v_test := not v_test;
	
	if (v_test == false) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070104_LogicalOperators_001());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.7, Ensure that the rotate left operator works as expected on hexstrings.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070107_RotateOperators_002 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070107_RotateOperators_002() runs on GeneralComp {
	var hexstring v_test := '12345'H;
	var hexstring v_result := v_test <@ 2;
	
	if (v_result == '34512'H) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070107_RotateOperators_002());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.7, Ensure that the rotate left operator works as expected on bitstrings.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070107_RotateOperators_001 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070107_RotateOperators_001() runs on GeneralComp {
	var bitstring v_test := '101001'B;
	var bitstring v_result := v_test <@ 2;
	
	if (v_result == '100110'B) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070107_RotateOperators_001());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.7, Ensure that the rotate right operator works as expected on hexstrings.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070107_RotateOperators_004 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070107_RotateOperators_004() runs on GeneralComp {
	var hexstring v_test := '12345'H;
	var hexstring v_result := v_test @> 2;
	
	if (v_result == '45123'H) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070107_RotateOperators_004());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.7, Ensure that the rotate right operator works as expected on bitstrings.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070107_RotateOperators_003 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070107_RotateOperators_003() runs on GeneralComp {
	var bitstring v_test := '100001'B;
	var bitstring v_result := v_test @> 2;
	
	if (v_result == '011000'B) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070107_RotateOperators_003());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.6, Ensure that the shift right operator works as expected on hexstrings.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070106_ShiftOperators_004 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070106_ShiftOperators_004() runs on GeneralComp {
	var hexstring v_test := '12345'H;
	var hexstring v_result := v_test >> 2;
	
	if (v_result == '00123'H) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070106_ShiftOperators_004());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.6, Ensure that the shift left operator works as expected on hexstrings.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070106_ShiftOperators_002 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070106_ShiftOperators_002() runs on GeneralComp {
	var hexstring v_test := '12345'H;
	var hexstring v_result := v_test << 2;
	
	if (v_result == '34500'H) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070106_ShiftOperators_002());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.6, Ensure that the shift right operator works as expected on bitstrings.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070106_ShiftOperators_003 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070106_ShiftOperators_003() runs on GeneralComp {
	var bitstring v_test := '111001'B;
	var bitstring v_result := v_test >> 2;
	
	if (v_result == '001110'B) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070106_ShiftOperators_003());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.6, Ensure that the shift left operator works as expected on bitstrings.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070106_ShiftOperators_001 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070106_ShiftOperators_001() runs on GeneralComp {
	var bitstring v_test := '111001'B;
	var bitstring v_result := v_test << 2;
	
	if (v_result == '100100'B) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070106_ShiftOperators_001());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.2, Ensure that the list operator on charstrings is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070102_ListOperator_002 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070102_ListOperator_002() runs on GeneralComp {
	var charstring v_result := "Hello"  & " " & "World!";	
	if (v_result == "Hello World!") {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070102_ListOperator_002());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.2, Ensure that the list operator on bitstrings is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070102_ListOperator_001 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070102_ListOperator_001() runs on GeneralComp {
	var bitstring v_result := '1111'B & '0000'B & '1111'B;	
	if (v_result == '111100001111'B) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070102_ListOperator_001());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.2, Ensure that the list operator on set of is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_070102_ListOperator_004 {

type component GeneralComp {	    	    
}

type set of integer IntegerSet;

testcase TC_Sem_070102_ListOperator_004() runs on GeneralComp {
	var IntegerSet v_i := {0, 1, 6};
	var IntegerSet v_j := {2, 4, 7};

	var IntegerSet v_result := v_i & v_j;	
	var IntegerSet v_reference := {0, 1, 6, 2, 4, 7};
	if (v_result == v_reference) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070102_ListOperator_004());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.2, Ensure that the list operator on arrays is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070102_ListOperator_005 {

type component GeneralComp {	    	    
}

type integer MyArrayType[3];
type integer MyArrayTypeSix[6];

testcase TC_Sem_070102_ListOperator_005() runs on GeneralComp {
	var MyArrayType v_i := {0, 1, 6};
	var MyArrayType v_j := {2, 4, 7};

	var MyArrayTypeSix v_result := v_i & v_j;	
	var MyArrayTypeSix v_reference := {0, 1, 6, 2, 4, 7}; 	//order of elements is concatenated order
	if (v_result == v_reference) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070102_ListOperator_005());
}

}
/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:7.1.2, Ensure that the list operator on record of is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_070102_ListOperator_006 {

type component GeneralComp {	    	    
}

type record of integer IntegerArray;

testcase TC_Sem_070102_ListOperator_006() runs on GeneralComp {
	var IntegerArray v_i := {0, 1, 2} & {3, 4, 5} & {6};

	var IntegerArray v_reference := {0, 1, 2, 3, 4, 5, 6};

	if (v_i == v_reference) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070102_ListOperator_006());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.2, Ensure that the list operator on record of is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_070102_ListOperator_003 {

type component GeneralComp {	    	    
}

type record of integer IntegerArray;

testcase TC_Sem_070102_ListOperator_003() runs on GeneralComp {
	var IntegerArray v_i := {0, 1, 2};
	var IntegerArray v_j := {3, 4, 5};

	var IntegerArray v_result := v_i & v_j;	
	var IntegerArray v_reference := {0, 1, 2, 3, 4, 5};
	if (v_result == v_reference) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}			

control{
    execute(TC_Sem_070102_ListOperator_003());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that greather than or equal to operator evaulates correctly -infinity special float
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_041 {

type component GeneralComp {	    	    
}
    

    
testcase TC_Sem_070103_RelationalOperators_041() runs on GeneralComp {
    
    var float My_val:= 1.0;
    
    
	if (-infinity <= My_val) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_041());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the less than operator on enumerations is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_015 {

type component GeneralComp {	    	    
}

type enumerated MyEnumType { 
	e_monday, e_tuesday, e_wednesday, e_thursday, e_friday
};

testcase TC_Sem_070103_RelationalOperators_015() runs on GeneralComp {
	var MyEnumType v_first := e_monday;
	var MyEnumType v_second := e_tuesday;

	if (v_second > v_first) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_015());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the equals operator on enumerations is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_003 {

type component GeneralComp {	    	    
}

type enumerated MyEnumType { 
	e_monday, e_tuesday, e_wednesday, e_thursday, e_friday
};

testcase TC_Sem_070103_RelationalOperators_003() runs on GeneralComp {
	var MyEnumType v_first := e_monday;
	var MyEnumType v_reference := e_monday;

	if (v_first == v_reference) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_003());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the greater than or equal to operator on floats is evaluated correctly with equal values.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_019 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_019() runs on GeneralComp {
	if (2.3 >= 2.3) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_019());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the less than or equal to operator on integers is evaluated correctly with equal values.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_008 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_008() runs on GeneralComp {
	if (2 <= 2) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_008());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that less than operator evaulates correctly infinity special float
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_038 {

type component GeneralComp {	    	    
}
    

    
testcase TC_Sem_070103_RelationalOperators_038() runs on GeneralComp {
    
    var float My_val:= 100.0;
    
    
	if (My_val < infinity) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_038());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the less than or equal to operator on enumerations is evaluated correctly with differing values.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_011 {

type component GeneralComp {	    	    
}

type enumerated MyEnumType { 
	e_monday, e_tuesday, e_wednesday, e_thursday, e_friday
};

testcase TC_Sem_070103_RelationalOperators_011() runs on GeneralComp {
	var MyEnumType v_first := e_monday;
	var MyEnumType v_second := e_tuesday;

	if (v_first <= v_second) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_011());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the greater than or equal to operator on integers is evaluated correctly with equal values.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_017 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_017() runs on GeneralComp {
	if (2 >= 2) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_017());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the less than or equal to operator on enumerations is evaluated correctly with differing values.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_020 {

type component GeneralComp {	    	    
}

type enumerated MyEnumType { 
	e_monday, e_tuesday, e_wednesday, e_thursday, e_friday
};

testcase TC_Sem_070103_RelationalOperators_020() runs on GeneralComp {
	var MyEnumType v_first := e_monday;
	var MyEnumType v_second := e_tuesday;

	if (v_second >= v_first) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_020());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the less than operator on floats is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_005 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_005() runs on GeneralComp {
	if (2.3 < 2.452) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_005());
}

}
/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the equals operator on records is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_026 {

type component GeneralComp {	    	    
}

 type set IntegerSet {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional
 };

testcase TC_Sem_070103_RelationalOperators_026() runs on GeneralComp {
	var IntegerSet v_set := {a1:=0,a2:=omit,a3:=2};

	if ( v_set == { a1:=0, a2:=omit, a3:=2 } ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_026());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that less than or equal to operator evaulates correctly infinity special float
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_039 {

type component GeneralComp {	    	    
}
    

    
testcase TC_Sem_070103_RelationalOperators_039() runs on GeneralComp {
    
    var float My_val:= 100.0;
    
    
	if (My_val <= infinity) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_039());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that NaN special float is evaulated correctly in a relation.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_045 {

type component GeneralComp {	    	    
}
    

    
testcase TC_Sem_070103_RelationalOperators_045() runs on GeneralComp {
    
    var float My_val := 1.0;    
    
	if (My_val < not_a_number) {
		setverdict(pass, My_val);
	} else {
		setverdict(fail, My_val);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_045());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the greater than or equal to operator on floats is evaluated correctly with differing values.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_018 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_018() runs on GeneralComp {
	if (3.2 >= 2.3) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_018());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the eqaul to operator on address is evaluated correctly with equal values.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
/*The address type is allowed for the equality (==) and non-equality (!=) operators,
independent of its actual type, but when its actual type differs from the types specified above, it can be compared to the literal special value null only.
*/

module Sem_070103_RelationalOperators_035 {

type component GeneralComp {	    	    
}

type integer address;
    
testcase TC_Sem_070103_RelationalOperators_035() runs on GeneralComp {
    
    var address My_address:=null;
    
    
	if (My_address == null) {
		setverdict(pass,My_address);
	} else {
		setverdict(fail,My_address);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_035());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the equals operator on floats is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_002 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_002() runs on GeneralComp {
	if (2.0 == 2.0) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_002());
}

}
/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the equals operator on records is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_033 {

type component GeneralComp {	    	    
}

 type set IntegerSet {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional
 };

testcase TC_Sem_070103_RelationalOperators_033() runs on GeneralComp {
	const IntegerSet c_set := {a1:=omit,a2:=2,a3:=omit};

	if ( c_set.a2 != c_set.a3 ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_033());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the less than operator on enumerations is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_006 {

type component GeneralComp {	    	    
}

type enumerated MyEnumType { 
	e_monday, e_tuesday, e_wednesday, e_thursday, e_friday
};

testcase TC_Sem_070103_RelationalOperators_006() runs on GeneralComp {
	var MyEnumType v_first := e_monday;
	var MyEnumType v_second := e_tuesday;

	if (v_first < v_second) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_006());
}

}
/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the equals operator on records is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_034 {

type component GeneralComp {	    	    
}

 type set IntegerSet {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional
 };

testcase TC_Sem_070103_RelationalOperators_034() runs on GeneralComp {
	const IntegerSet c_set := {a1:=omit,a2:=2,a3:=omit};

	if ( c_set.a2 == 1 ) {
		setverdict(fail);
	} else {
		setverdict(pass);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_034());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the greater than or equal to operator on integers is evaluated correctly with differing values.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_016 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_016() runs on GeneralComp {
	if (3 >= 2) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_016());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the equals operator on integers is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_001 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_001() runs on GeneralComp {
	if (2 == 2) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_001());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that not equal to operator evaulates correctly infinity special float
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_044 {

type component GeneralComp {	    	    
}
    

    
testcase TC_Sem_070103_RelationalOperators_044() runs on GeneralComp {
    
    var float My_val := 1.0 * -infinity;    // My_val= -infinity
    
	if (infinity != My_val) {
		setverdict(pass, My_val);
	} else {
		setverdict(fail, My_val);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_044());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the not equals operator on integers is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_022 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_022() runs on GeneralComp {
	if (2 != 3) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_022());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the not equals operator on floats is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_023 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_023() runs on GeneralComp {
	if (2.12 != 2.3) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_023());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that infinity special float is evaulated correctly in a relation.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_047 {

type component GeneralComp {	    	    
}
    
testcase TC_Sem_070103_RelationalOperators_047() runs on GeneralComp {
    
    
	if (-infinity < infinity) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_047());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the less than operator on integers is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_004 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_004() runs on GeneralComp {
	if (2 < 3) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_004());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the eqaul to operator on address is evaluated correctly with equal values.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

/*The address type is allowed for the equality (==) and non-equality (!=) operators, independent of its actual type, but when its actual type differs from the types specified above, it can be compared to the literal special value null only.*/

module Sem_070103_RelationalOperators_036 {

type component GeneralComp {	    	    
}

type integer address;
    
testcase TC_Sem_070103_RelationalOperators_036() runs on GeneralComp {
    
    var address My_address:=2;
    
    
	if (My_address == 2) {
		setverdict(pass,My_address);
	} else {
		setverdict(fail,My_address);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_036());
}

}
/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the equals operator on records is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_030 {

type component GeneralComp {	    	    
}

 type set IntegerSet {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional
 };

testcase TC_Sem_070103_RelationalOperators_030() runs on GeneralComp {
	const IntegerSet c_set := {a1:=1,a2:=omit,a3:=1};

	if ( c_set.a1 == c_set.a3 ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_030());
}

}
/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the equals operator on records is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_031 {

type component GeneralComp {	    	    
}

 type set IntegerSet {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional
 };

testcase TC_Sem_070103_RelationalOperators_031() runs on GeneralComp {
	const IntegerSet c_set := {a1:=omit,a2:=2,a3:=omit};

	if ( c_set.a1 == c_set.a3 ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_031());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the greater than operator on integers is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_013 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_013() runs on GeneralComp {
	if (3 > 2) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_013());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the greater than or equal to operator on enumerations is evaluated correctly with equal values.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_021 {

type component GeneralComp {	    	    
}

type enumerated MyEnumType { 
	e_monday, e_tuesday, e_wednesday, e_thursday, e_friday
};

testcase TC_Sem_070103_RelationalOperators_021() runs on GeneralComp {
	var MyEnumType v_first := e_monday;
	var MyEnumType v_second := e_monday;

	if (v_first >= v_second) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_021());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the less than or equal to operator on integers is evaluated correctly with differing values.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_007 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_007() runs on GeneralComp {
	if (2 <= 3) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_007());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the not equals operator on enumerations is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_024 {

type component GeneralComp {	    	    
}

type enumerated MyEnumType { 
	e_monday, e_tuesday, e_wednesday, e_thursday, e_friday
};

testcase TC_Sem_070103_RelationalOperators_024() runs on GeneralComp {
	var MyEnumType v_first := e_monday;
	var MyEnumType v_reference := e_tuesday;

	if (v_first != v_reference) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_024());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that equal to operator evaulates correctly infinity special float
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_043 {

type component GeneralComp {	    	    
}
    

    
testcase TC_Sem_070103_RelationalOperators_043() runs on GeneralComp {
    
    var float My_val := -1.0 * -infinity;    // My_val= infinity
    
	if (infinity == My_val) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_043());
}

}
/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the equals operator on sets is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_025 {

type component GeneralComp {	    	    
}

 type set IntegerSet {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional
 };

testcase TC_Sem_070103_RelationalOperators_025() runs on GeneralComp {
	const IntegerSet c_set := {a1:=0,a2:=omit,a3:=2};

	if ( { a3:=2, a2:=omit, a1:=0 } == c_set ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_025());
}

}
/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the equals operator on records is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_032 {

type component GeneralComp {	    	    
}

 type set IntegerSet {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional
 };

testcase TC_Sem_070103_RelationalOperators_032() runs on GeneralComp {
	const IntegerSet c_set := {a1:=omit,a2:=2,a3:=omit};

	if ( c_set.a2 == 2 ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_032());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that greather than operator evaulates correctly -infinity special float
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_040 {

type component GeneralComp {	    	    
}
    

    
testcase TC_Sem_070103_RelationalOperators_040() runs on GeneralComp {
    
    var float My_val:= 1.0;
    
    
	if (-infinity < My_val) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_040());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the less than or equal to operator on floats is evaluated correctly with differing values.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_009 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_009() runs on GeneralComp {
	if (2.3 <= 3.2) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_009());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the less than or equal to operator on floats is evaluated correctly with equal values.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_010 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_010() runs on GeneralComp {
	if (2.3 <= 2.3) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_010());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the less than or equal to operator on enumerations is evaluated correctly with equal values.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_012 {

type component GeneralComp {	    	    
}

type enumerated MyEnumType { 
	e_monday, e_tuesday, e_wednesday, e_thursday, e_friday
};

testcase TC_Sem_070103_RelationalOperators_012() runs on GeneralComp {
	var MyEnumType v_first := e_monday;
	var MyEnumType v_second := e_monday;

	if (v_first <= v_second) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_012());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the less than operator on floats is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_014 {

type component GeneralComp {	    	    
}

testcase TC_Sem_070103_RelationalOperators_014() runs on GeneralComp {
	if (2.452 > 2.3) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_014());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that equal to operator evaulates correctly -infinity special float
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_042 {

type component GeneralComp {	    	    
}
    

    
testcase TC_Sem_070103_RelationalOperators_042() runs on GeneralComp {
    
    var float My_val := -1.0 * infinity;    // My_val= -infinity
    
	if (-infinity == My_val) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_042());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that NaN special float is evaulated correctly in a relation.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_070103_RelationalOperators_046 {

type component GeneralComp {	    	    
}
    

    
testcase TC_Sem_070103_RelationalOperators_046() runs on GeneralComp {
    
    
	if (infinity < not_a_number) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_046());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7.1.3, Ensure that the not eqaul to operator on record type address is evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

/*The address type is allowed for the equality (==) and non-equality (!=) operators, independent of its actual type, but when its actual type differs from the types specified above, it can be compared to the literal special value null only.*/

module Sem_070103_RelationalOperators_037 {

type component GeneralComp {	    	    
}
    
type record Myaddress_type {
    integer field1,
    float   field2
}

type Myaddress_type address;
    
testcase TC_Sem_070103_RelationalOperators_037() runs on GeneralComp {
    
    var address My_address:=null;
    
    
	if (My_address == null) {
		setverdict(pass, My_address);
	} else {
		setverdict(fail,My_address);
	}
}

control{
    execute(TC_Sem_070103_RelationalOperators_037());
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7, expression composed of several expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Expressions may be built from other (simple) expressions. 

module Sem_07_toplevel_001
{
    type component GeneralComp {
	}
    
    function f() return integer
    {
        return 5;
    }
    
    testcase TC_Sem_07_toplevel_001() runs on GeneralComp {        
        var integer v_num := 3;
        var integer v_res := -v_num + f() * 2 - 3;
        if (v_res == 4) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {        
		execute(TC_Sem_07_toplevel_001());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7, compound expression as an operand of array type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Compound expressions are used for expressions of array, record, record of and 
// set of types.

module Sem_07_toplevel_002
{
    type component GeneralComp {
	}
    
    testcase TC_Sem_07_toplevel_002() runs on GeneralComp {        
        var integer v_arr[2];
        v_arr[0] := 1;
        v_arr[1] := 2;
        if (v_arr == { 1, 2 }) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {        
		execute(TC_Sem_07_toplevel_002());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7, compound expression as an operand of set-of type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Compound expressions are used for expressions of array, record, record of and 
// set of types.

module Sem_07_toplevel_005
{
    type component GeneralComp {
	}
    
    type set of integer SI;
    
    testcase TC_Sem_07_toplevel_005() runs on GeneralComp {        
        var SI v_set;
        v_set[0] := 1;
        v_set[1] := 2;
        if (v_set == { [0] := 1, [1] := 2 }) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {        
		execute(TC_Sem_07_toplevel_005());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7, compound expression as an operand of record-of type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Compound expressions are used for expressions of array, record, record of and 
// set of types.

module Sem_07_toplevel_004
{
    type component GeneralComp {
	}
    
    type record of integer RI;
    
    testcase TC_Sem_07_toplevel_004() runs on GeneralComp {        
        var RI v_rec;
        v_rec[0] := 1;
        v_rec[1] := 2;
        if (v_rec == { 1, 2 }) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {        
		execute(TC_Sem_07_toplevel_004());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7, compound expression as an operand of record type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Compound expressions are used for expressions of array, record, record of and 
// set of types.

module Sem_07_toplevel_003
{
    type component GeneralComp {
	}
    
    type record R {
        integer field1,
        charstring field2 optional
    }
    
    testcase TC_Sem_07_toplevel_003() runs on GeneralComp {        
        var R v_rec;
        v_rec.field1 := 1;
        v_rec.field2 := omit;
        if (v_rec == { field1 := 1, field2 := omit }) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {        
		execute(TC_Sem_07_toplevel_003());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:7, element of partially initialized structured value
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// This means also that all fields and elements of structured types referenced 
// in an expression shall contain completely initialized values, while other 
// fields and elements, not used in the expression, may be uninitialized or 
// contain omit.

module Sem_07_toplevel_006
{
    type component GeneralComp {
	}
    
    type record R {
        integer field1,
        integer field2 optional
    }
    
    testcase TC_Sem_07_toplevel_006() runs on GeneralComp {        
        var R v_rec;
        v_rec.field1 := 1;
        if (10 + v_rec.field1 == 11) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {        
		execute(TC_Sem_07_toplevel_006());
	}
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.2, Ensure that the IUT correctly handles field referencing
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_0702_FieldReferencesAndListElements_002 {

type component GeneralComp {	    	    
}

type record of integer IntegerArray;

testcase TC_Sem_0702_FieldReferencesAndListElements_002() runs on GeneralComp {
	var IntegerArray v_test := {20, 41, 12};

	if ( match(v_test, {20, 41, 12}) ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_0702_FieldReferencesAndListElements_002());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:7.2, Ensure that the IUT correctly handles field referencing
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_0702_FieldReferencesAndListElements_001 {

type component GeneralComp {	    	    
}

type record MyRecord1 {
	integer      field1, 
	charstring   field2 
}

testcase TC_Sem_0702_FieldReferencesAndListElements_001() runs on GeneralComp {
	var MyRecord1 v_test := {1, "Hello World!"};
	
	if ( match(v_test, {1, "Hello World!"})) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_0702_FieldReferencesAndListElements_001());
}

}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getcall) in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_035 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	altstep a() runs on GeneralComp {
		[] p.getcall { 
			setverdict(pass, "As expected, the check operation didn't match"); 
			stop;
		}
	}
	
	function f() runs on GeneralComp {
		activate(a());
        p.check(getcall(S:{ p_par1 := (0, 2, 4, 6)}));
		setverdict(fail, "Incorrect match");
	}
	
	testcase TC_Sem_2204_the_check_operation_035() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_035(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check with assignment in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_108 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
		var GeneralComp v_src;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	altstep a() runs on GeneralComp {
		[] p.catch { 
			if (not isbound(v_src)) {
				setverdict(pass, "As expected, the check operation didn't match"); 
			}
			else { setverdict(fail, "The v_src variable should still be undefined at this point"); }
			stop;
		}
	}
	
	testcase TC_Sem_2204_the_check_operation_108() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		activate(a());
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        p.check(from self -> sender v_src);
		setverdict(fail, "Incorrect match"); 
    }

    control {
        execute(TC_Sem_2204_the_check_operation_108(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getreply) with assignment in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_064 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
		var integer v_val;
		var GeneralComp v_src;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{ p_par1 := 1} value 5);
	}
	
	altstep a() runs on GeneralComp {
		[] any port.getreply { 
			if (not isbound(v_val) and not isbound(v_src)) {
				setverdict(pass, "As expected, the check operation didn't match"); 
			}
			else { setverdict(fail, "The v_val and v_src variables should still be undefined at this point"); }
			stop;
		}
	}
	
	testcase TC_Sem_2204_the_check_operation_064() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		activate(a());
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := - }, nowait);
		v_ptc.start(f());
        any port.check(getreply(S:{p_par1 := ?} value (100..200)) -> value v_val sender v_src);
		setverdict(fail, "Incorrect match"); 
    }

    control {
        execute(TC_Sem_2204_the_check_operation_064(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(receive) with assignment works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_002 {

	type port P message {
		inout integer;
		address integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_002() runs on GeneralComp {
		var integer v_addr;
		p.send(integer:1) to 80;
        alt
		{
        	[] p.check(receive -> sender v_addr) { 
				if (v_addr == 80) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect address value"); }
			}	
		}
		p.receive;
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_002(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(receive) with assignment in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_016 {

	type integer address;
	
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p1, p2;
		var address v_addr;
	}

	altstep a() runs on GeneralComp {
		[] any port.receive { 
			if (not isbound(v_addr)) { setverdict(pass, "As expected, the check operation didn't match"); }
			else { setverdict(fail, "The address value should still be undefined at this point"); }
			stop;
		}
	}
	testcase TC_Sem_2204_the_check_operation_016() runs on GeneralComp {
		activate(a());
		p2.send(integer:1) to 80;
        any port.check(receive(integer:(100..200)) from address:(20..100) -> sender v_addr);
		setverdict(fail, "Incorrect match");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_016(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(catch) in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_089 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_089() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(catch(S, integer:(0..10))) { 
				setverdict(pass, "Check operation successful"); 
			}
		}
		p.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_089(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(receive) in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_009 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_009() runs on GeneralComp {
		p.send(integer:1);
        alt
		{
        	[] p.check(receive(integer:(100..200))) { setverdict(fail, "Incorrect match"); }
			[] p.receive { setverdict(pass, "As expected, the check operation didn't match"); }
		}
    }

    control {
        execute(TC_Sem_2204_the_check_operation_009(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(getcall) with assignment works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_030 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;		
	}
	
	function f() runs on GeneralComp {
        var GeneralComp v_src;
		alt
		{
        	[] any port.check(getcall -> sender v_src) {
				if (v_src == mtc) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Unexpected sender value"); }
			}
		}
		any port.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_030() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_030(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(catch) in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_095 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_095() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        any port.check(catch(S, integer:?) from v_ptc);
		setverdict(pass, "Check operation successful"); 
		any port.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_095(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(catch) with assignment in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_088 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
		var integer v_val;
		var GeneralComp v_src;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	altstep a() runs on GeneralComp {
		[] any port.catch { 
			if (not isbound(v_val) and not isbound(v_src)) {
				setverdict(pass, "As expected, the check operation didn't match"); 
			}
			else { setverdict(fail, "The v_val and v_src variables should still be undefined at this point"); }
			stop;
		}
	}
	
	testcase TC_Sem_2204_the_check_operation_088() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		activate(a());
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        any port.check(catch(S, integer:(100..200)) -> value v_val sender v_src);
		setverdict(fail, "Incorrect match"); 
    }

    control {
        execute(TC_Sem_2204_the_check_operation_088(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getcall) in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_047 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
        any port.check(getcall(S:{ p_par1 := (0..10)}) from mtc);
		setverdict(pass, "Check operation successful");
		any port.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_047() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_047(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getcall) with assignment in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_036 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
		var integer v_val;
	}
	
	altstep a() runs on GeneralComp {
		[] p.getcall { 
			if (not isbound(v_val)) { setverdict(pass, "As expected, the check operation didn't match"); }
			else { setverdict(fail, "The value should still be undefined at this point"); }
			stop;
		}
	}
	
	function f() runs on GeneralComp {
		activate(a());
        p.check(getcall(S:{ p_par1 := (0..10)}) from self -> param(v_val := p_par1));
		setverdict(fail, "Incorrect match"); 
	}
	
	testcase TC_Sem_2204_the_check_operation_036() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_036(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(receive) with assignment works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_004 {

	type port P message {
		inout integer;
		address integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_004() runs on GeneralComp {
		var integer v_addr;
		p.send(integer:1) to 80;
        p.check(receive -> sender v_addr);
		if (v_addr == 80) { setverdict(pass, "Check operation successful"); }
		else { setverdict(fail, "Incorrect address value"); }
		p.receive;
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_004(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(getcall) with assignment works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_028 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;		
	}
	
	function f() runs on GeneralComp {
        var GeneralComp v_src;
		p.check(getcall -> sender v_src);
		if (v_src == mtc) { setverdict(pass, "Check operation successful"); }
		else { setverdict(fail, "Unexpected sender value"); }
		p.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_028() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_028(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behation of any port.check(receive) with assignment in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_022 {

	type integer address;

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	testcase TC_Sem_2204_the_check_operation_022() runs on GeneralComp {
		var integer v_val, v_addr;
		p2.send(integer:1) to 80;
        alt
		{
        	[] any port.check(receive(integer:(0..10)) from address:(10..100) -> value v_val sender v_addr) { 
				if (match(v_val, 1) and match(v_addr, 80)) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect message value or address"); }
			}	
		}
		any port.receive(integer:?);
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_022(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_105 {

	type port P message {
		inout integer;
		address integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_105() runs on GeneralComp {
		p.send(integer:1) to 80;
        alt
		{
        	[] p.check(from 8080) { setverdict(fail, "Incorrect match"); }
			[] p.receive { setverdict(pass, "As expected, the check operation didn't match"); }
		}
    }

    control {
        execute(TC_Sem_2204_the_check_operation_105(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(receive) in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_021 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	testcase TC_Sem_2204_the_check_operation_021() runs on GeneralComp {
		p2.send(integer:1);
        alt
		{
        	[] any port.check(receive(integer:?)) { setverdict(pass, "Check operation successful"); }
		}
		any port.receive(integer:?);
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_021(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(receive) in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_019 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_019() runs on GeneralComp {
		p.send(integer:1);
        p.check(receive(integer:?));
		setverdict(pass, "Check operation successful");
		p.receive(integer:?);
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_019(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(getcall) with assignment works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_032 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;		
	}
	
	function f() runs on GeneralComp {
        var GeneralComp v_src;
		any port.check(getcall -> sender v_src);
		if (v_src == mtc) { setverdict(pass, "Check operation successful"); }
		else { setverdict(fail, "Unexpected sender value"); }
		any port.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_032() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_032(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(getreply) with assignment works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_050 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{});
	}
	
	testcase TC_Sem_2204_the_check_operation_050() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(getreply -> sender v_src) { 
				if (v_src == v_ptc) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Counterpart mismatch"); }
			}
		}
		p.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_050(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(catch) with assignment in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_086 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_086() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_par, v_val;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(catch(S, integer:(100..200)) -> value v_val) { 
				setverdict(fail, "Incorrect match"); 
			}
			[] any port.catch { 
				if (not isbound(v_val)) {
					setverdict(pass, "As expected, the check operation didn't match"); 
				}
				else { setverdict(fail, "The v_val variable should still be undefined at this point"); }
			}
		}
    }

    control {
        execute(TC_Sem_2204_the_check_operation_086(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check with assignment in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_114 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		var GeneralComp v_src;
        alt
		{
        	[] p.check(from GeneralComp:? -> sender v_src) { 
				if (v_src == mtc) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect sender"); }
			}
		}
		p.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_114() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_114(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_117 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	testcase TC_Sem_2204_the_check_operation_117() runs on GeneralComp {
		p2.send(integer:1);
        alt
		{
        	[] any port.check { setverdict(pass, "Check operation successful"); }
		}
		any port.receive(integer:?);
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_117(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check with assignment in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_110 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		var GeneralComp v_src;
        alt
		{
        	[] any port.check(from self -> sender v_src) { 
				setverdict(fail, "Incorrect match"); 
			}
			[] any port.getcall { 
				if (not isbound(v_src)) { setverdict(pass, "As expected, the check operation didn't match"); }
				else { setverdict(fail, "The v_src variable should still be undefined at this point"); }
			}
		}		
	}
	
	testcase TC_Sem_2204_the_check_operation_110() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_110(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(getreply) works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_051 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{});
	}
	
	testcase TC_Sem_2204_the_check_operation_051() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        p.check(getreply);
		setverdict(pass, "Check operation successful");
		p.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_051(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(catch) in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_085 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_085() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(catch(S, integer:(100..200))) { setverdict(fail, "Incorrect match"); }
			[] any port.catch { setverdict(pass, "As expected, the check operation didn't match"); }
		}
    }

    control {
        execute(TC_Sem_2204_the_check_operation_085(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getcall) in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_039 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	altstep a() runs on GeneralComp {
		[] any port.getcall { 
			setverdict(pass, "As expected, the check operation didn't match"); 
			stop;
		}
	}
	
	function f() runs on GeneralComp {
		activate(a());
        any port.check(getcall(S:{ p_par1 := (0, 2, 4, 6)}));
		setverdict(fail, "Incorrect match");
	}
	
	testcase TC_Sem_2204_the_check_operation_039() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_039(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(catch) with assignment works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_076 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_076() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        p.check(catch -> sender v_src);
		if (v_src == v_ptc) { setverdict(pass, "Check operation successful"); }
		else { setverdict(fail, "Counterpart mismatch"); }
		p.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_076(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify any port.check(receive) behaviour in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_013 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	testcase TC_Sem_2204_the_check_operation_013() runs on GeneralComp {
		p2.send(integer:1);
        alt
		{
        	[] any port.check(receive(integer:(100..200))) { setverdict(fail, "Incorrect match"); }
			[] any port.receive { setverdict(pass, "As expected, the check operation didn't match"); }
		}
    }

    control {
        execute(TC_Sem_2204_the_check_operation_013(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getreply) in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_063 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{ p_par1 := 1} value 5);
	}
	
	altstep a() runs on GeneralComp {
		[] any port.getreply { 
			setverdict(pass, "As expected, the check operation didn't match"); 
			stop;
		}
	}
	
	testcase TC_Sem_2204_the_check_operation_063() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		activate(a());
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := - }, nowait);
		v_ptc.start(f());
        any port.check(getreply(S:? value ?) from self);
		setverdict(fail, "Incorrect match");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_063(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(catch) works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_073 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_073() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(catch) { setverdict(pass, "Check operation successful"); }
		}
		p.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_073(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify port.check(receive) behaviour in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_011 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}

	altstep a() runs on GeneralComp {
		[] p.receive { 
			setverdict(pass, "As expected, the check operation didn't match"); 
			stop;
		}
	}
	testcase TC_Sem_2204_the_check_operation_011() runs on GeneralComp {
		activate(a());
		p.send(integer:1);
        p.check(receive(integer:(100..200))); 
		setverdict(fail, "Incorrect match");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_011(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getcall) with assignment in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_034 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		var integer v_val;
        alt
		{
        	[] p.check(getcall(S:{ p_par1 := (0, 2, 4, 6)}) -> param(v_val := p_par1)) { 
				setverdict(fail, "Incorrect match"); 
			}
			[] p.getcall { 
				if (not isbound(v_val)) { setverdict(pass, "As expected, the check operation didn't match"); }
				else { setverdict(fail, "The value should still be undefined at this point"); }
			}
		}		
	}
	
	testcase TC_Sem_2204_the_check_operation_034() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_034(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getreply) with assignment in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_072 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{ p_par1 := 1 } value 5);
	}
	
	testcase TC_Sem_2204_the_check_operation_072() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		var integer v_val;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := - }, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(getreply(S:{ p_par1 := complement(4, 5, 6) } value integer:?) -> value v_val sender v_src) { 
				if (match(v_val, 5) and match(v_src, v_ptc)) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect return value or sender"); }
			}
		}
		any port.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_072(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getcall) with assignment in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_048 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		var integer v_val;
        any port.check(getcall(S:{ p_par1 := (0..10)}) -> param (v_val));
		if (v_val == 1) { setverdict(pass, "Check operation successful"); }
		else { setverdict(fail, "Incorrect parameter value"); }
		any port.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_048() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_048(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(receive) with assignment in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_012 {

	type port P message {
		inout integer;
		address integer;
	}
	
    type component GeneralComp {
		port P p;
		var integer v_addr;
	}

	altstep a() runs on GeneralComp {
		[] p.receive { 
			if (not isbound(v_addr)) { setverdict(pass, "As expected, the check operation didn't match"); }
			else { setverdict(fail, "The address value should still be undefined at this point"); }
			stop;
		}
	}
	testcase TC_Sem_2204_the_check_operation_012() runs on GeneralComp {
		activate(a());
		p.send(integer:1) to 80;
        p.check(receive(integer:(100..200)) from P.address:(20..100) -> sender v_addr);
		setverdict(fail, "Incorrect match");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_012(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify any port.check behaviour in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_109 {

	type integer address;
	
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	testcase TC_Sem_2204_the_check_operation_109() runs on GeneralComp {
		p2.send(integer:1) to 80;
        alt
		{
        	[] any port.check(from 8080) { setverdict(fail, "Incorrect match"); }
			[] any port.receive { setverdict(pass, "As expected, the check operation didn't match"); }
		}
    }

    control {
        execute(TC_Sem_2204_the_check_operation_109(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(catch) works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_075 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_075() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        p.check(catch);
		setverdict(pass, "Check operation successful");
		p.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_075(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getreply) in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_057 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{ p_par1 := 1} value 5);
	}
	
	testcase TC_Sem_2204_the_check_operation_057() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := - }, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(getreply(S:{p_par1 := (100..200)} value ?)) { setverdict(fail, "Incorrect match"); }
			[] p.getreply { setverdict(pass, "As expected, the check operation didn't match"); }
		}
    }

    control {
        execute(TC_Sem_2204_the_check_operation_057(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(getcall) works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_029 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
        alt
		{
        	[] any port.check(getcall) { setverdict(pass, "Check operation successful"); }
		}
		any port.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_029() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_029(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_115 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{ p_par1 := 1} value 5);
	}
	
	testcase TC_Sem_2204_the_check_operation_115() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := -}, nowait);
		v_ptc.start(f());
        p.check(from v_ptc);
		setverdict(pass, "Check operation successful"); 
		p.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_115(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getreply) in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_065 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{ p_par1 := 1} value 5);
	}
	
	testcase TC_Sem_2204_the_check_operation_065() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := -}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(getreply(S:{ p_par1 := ?} value integer:(0..10))) { 
				setverdict(pass, "Check operation successful"); 
			}
		}
		p.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_065(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getreply) in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_071 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{ p_par1 := 1} value 5);
	}
	
	testcase TC_Sem_2204_the_check_operation_071() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := -}, nowait);
		v_ptc.start(f());
        any port.check(getreply(S:{ p_par1 := ?} value integer:(0..10)) from v_ptc);
		setverdict(pass, "Check operation successful"); 
		any port.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_071(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getcall) in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_033 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
        alt
		{
        	[] p.check(getcall(S:{ p_par1 := (0, 2, 4, 6)})) { setverdict(fail, "Incorrect match"); }
			[] p.getcall { setverdict(pass, "As expected, the check operation didn't match"); }
		}		
	}
	
	testcase TC_Sem_2204_the_check_operation_033() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_033(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(getreply) with assignment works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_054 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{});
	}
	
	testcase TC_Sem_2204_the_check_operation_054() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(getreply -> sender v_src) { 
				if (v_src == v_ptc) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Counterpart mismatch"); }
			}
		}
		any port.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_054(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check with assignment works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_100 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_100() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        p.check(-> sender v_src);
		if (v_src == v_ptc) { setverdict(pass, "Check operation successful"); }
		else { setverdict(fail, "Counterpart mismatch"); }
		p.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_100(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(getreply) works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_049 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{});
	}
	
	testcase TC_Sem_2204_the_check_operation_049() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(getreply) { setverdict(pass, "Check operation successful"); }
		}
		p.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_049(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(receive) in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_017 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_017() runs on GeneralComp {
		p.send(integer:1);
        alt
		{
        	[] p.check(receive(integer:?)) { setverdict(pass, "Check operation successful"); }
		}
		p.receive(integer:?);
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_017(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(getcall) with assignment works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_026 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;		
	}
	
	function f() runs on GeneralComp {
        var GeneralComp v_src;
		alt
		{
        	[] p.check(getcall -> sender v_src) {
				if (v_src == mtc) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Unexpected sender value"); }
			}
		}
		p.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_026() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_026(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check with assignment works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_102 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;		
	}
	
	function f() runs on GeneralComp {
        var GeneralComp v_src;
		alt
		{
        	[] any port.check(-> sender v_src) {
				if (v_src == mtc) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Unexpected sender value"); }
			}
		}
		any port.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_102() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_102(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getcall) with assignment in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_042 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		var integer v_val;
		var GeneralComp v_src;
        alt
		{
        	[] p.check(getcall(S:{ p_par1 := (0..10)}) from GeneralComp:? -> param (v_val) sender v_src) { 
				if (match(v_val, 1) and match(v_src, mtc)) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect parameter value or sender"); }
			}
		}
		p.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_042() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_042(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check with assignment in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_120 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_120() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(from GeneralComp:? -> sender v_src) { 
				if (v_src == v_ptc) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect exception value or sender"); }
			}
		}
		any port.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_120(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(catch) with assignment in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_092 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_092() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		var integer v_val;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(catch(S, integer: complement(4, 5, 6)) -> value v_val sender v_src) { 
				if (match(v_val, 1) and match(v_src, v_ptc)) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect exception value or sender"); }
			}
		}
		p.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_092(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_101 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	testcase TC_Sem_2204_the_check_operation_101() runs on GeneralComp {
		p2.send(integer:1);
        alt
		{
        	[] any port.check { setverdict(pass, "Check operation successful"); }
		}
		any port.receive;
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_101(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_113 {

	type port P message {
		inout integer;
		address integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_113() runs on GeneralComp {
		p.send(integer:1) to 80;
        alt
		{
        	[] p.check(from P.address:(80, 8080)) { setverdict(pass, "Check operation successful"); }
		}
		p.receive(integer:?);
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_113(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(catch) with assignment in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_084 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
		var integer v_val;
		var GeneralComp v_src;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	altstep a() runs on GeneralComp {
		[] p.catch { 
			if (not isbound(v_val) and not isbound(v_src)) {
				setverdict(pass, "As expected, the check operation didn't match"); 
			}
			else { setverdict(fail, "The v_val and v_src variables should still be undefined at this point"); }
			stop;
		}
	}
	
	testcase TC_Sem_2204_the_check_operation_084() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		activate(a());
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        p.check(catch(S, integer:(100..200)) -> value v_val sender v_src);
		setverdict(fail, "Incorrect match"); 
    }

    control {
        execute(TC_Sem_2204_the_check_operation_084(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(catch) works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_077 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_077() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(catch) { setverdict(pass, "Check operation successful"); }
		}
		any port.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_077(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check with assignment in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_116 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_116() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(from GeneralComp:? -> sender v_src) { 
				if (v_src == v_ptc) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect sender"); }
			}
		}
		p.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_116(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getcall) in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_043 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
        p.check(getcall(S:{ p_par1 := (0..10)}) from mtc);
		setverdict(pass, "Check operation successful");
		p.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_043() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_043(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getreply) with assignment in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_068 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{ p_par1 := 1 } value 5);
	}
	
	testcase TC_Sem_2204_the_check_operation_068() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		var integer v_val;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := - }, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(getreply(S:{ p_par1 := complement(4, 5, 6) } value integer:?) -> value v_val sender v_src) { 
				if ( match(v_val, 5) and match(v_src, v_ptc)) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect return value or sender"); }
			}
		}
		p.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_068(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getreply) in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_059 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{ p_par1 := 1} value 5);
	}
	
	altstep a() runs on GeneralComp {
		[] p.getreply { 
			setverdict(pass, "As expected, the check operation didn't match"); 
			stop;
		}
	}
	
	testcase TC_Sem_2204_the_check_operation_059() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		activate(a());
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := - }, nowait);
		v_ptc.start(f());
        p.check(getreply(S:? value ?) from self);
		setverdict(fail, "Incorrect match");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_059(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(getreply) with assignment works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_052 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{});
	}
	
	testcase TC_Sem_2204_the_check_operation_052() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        p.check(getreply -> sender v_src);
		if (v_src == v_ptc) { setverdict(pass, "Check operation successful"); }
		else { setverdict(fail, "Counterpart mismatch"); }
		p.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_052(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(receive) works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_007 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_007() runs on GeneralComp {
		p.send(integer:1);
        any port.check(receive);
		setverdict(pass, "Check operation successful");
		any port.receive;
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_007(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(getcall) works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_027 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
        p.check(getcall);
		setverdict(pass, "Check operation successful");
		p.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_027() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_027(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(receive) works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_003 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_003() runs on GeneralComp {
		p.send(integer:1);
        p.check(receive);
		setverdict(pass, "Check operation successful");
		p.receive;
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_003(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getcall) in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_045 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
        alt
		{
        	[] any port.check(getcall(S:{ p_par1 := (0..10)})) { setverdict(pass, "Check operation successful"); }
		}
		any port.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_045() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_045(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getcall) with assignment in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_038 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		var integer v_val;
        alt
		{
        	[] any port.check(getcall(S:{ p_par1 := (0, 2, 4, 6)}) -> param(v_val := p_par1)) { 
				setverdict(fail, "Incorrect match"); 
			}
			[] any port.getcall { 
				if (not isbound(v_val)) { setverdict(pass, "As expected, the check operation didn't match"); }
				else { setverdict(fail, "The value should still be undefined at this point"); }
			}
		}		
	}
	
	testcase TC_Sem_2204_the_check_operation_038() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_038(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(catch) with assignment works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_104 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_104() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        any port.check(-> sender v_src);
		if (v_src == v_ptc) { setverdict(pass, "Check operation successful"); }
		else { setverdict(fail, "Counterpart mismatch"); }
		any port.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_104(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify any port.check(receive) behaviour in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_015 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}

	altstep a() runs on GeneralComp {
		[] any port.receive { 
			setverdict(pass, "As expected, the check operation didn't match"); 
			stop;
		}
	}
	testcase TC_Sem_2204_the_check_operation_015() runs on GeneralComp {
		activate(a());
		p2.send(integer:1);
        any port.check(receive(integer:(100..200))); 
		setverdict(fail, "Incorrect match");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_015(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getcall) in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_037 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
        alt
		{
        	[] any port.check(getcall(S:{ p_par1 := (0, 2, 4, 6)})) { setverdict(fail, "Incorrect match"); }
			[] any port.getcall { setverdict(pass, "As expected, the check operation didn't match"); }
		}		
	}
	
	testcase TC_Sem_2204_the_check_operation_037() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_037(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getreply) in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_061 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{ p_par1 := 1} value 5);
	}
	
	testcase TC_Sem_2204_the_check_operation_061() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := - }, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(getreply(S:{p_par1 := (100..200)} value ?)) { setverdict(fail, "Incorrect match"); }
			[] any port.getreply { setverdict(pass, "As expected, the check operation didn't match"); }
		}
    }

    control {
        execute(TC_Sem_2204_the_check_operation_061(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getcall) in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_041 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
        alt
		{
        	[] p.check(getcall(S:{ p_par1 := (0..10)})) { setverdict(pass, "Check operation successful"); }
		}
		p.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_041() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_041(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_119 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{ p_par1 := 1} value 5);
	}
	
	testcase TC_Sem_2204_the_check_operation_119() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := -}, nowait);
		v_ptc.start(f());
        any port.check(from v_ptc);
		setverdict(pass, "Check operation successful"); 
		any port.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_119(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(catch) with assignment works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_078 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_078() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(catch -> sender v_src) { 
				if (v_src == v_ptc) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Counterpart mismatch"); }
			}
		}
		any port.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_078(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(catch) in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_087 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	altstep a() runs on GeneralComp {
		[] any port.catch { 
			setverdict(pass, "As expected, the check operation didn't match"); 
			stop;
		}
	}
	
	testcase TC_Sem_2204_the_check_operation_087() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		activate(a());
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        any port.check(catch(S, integer:?) from self);
		setverdict(fail, "Incorrect match");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_087(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(catch) with assignment in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_082 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_082() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_val;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(catch(S, integer:(100..200)) -> value v_val) { 
				setverdict(fail, "Incorrect match"); 
			}
			[] p.catch { 
				if (not isbound(v_val)) {
					setverdict(pass, "As expected, the check operation didn't match"); 
				}
				else { setverdict(fail, "The v_val variable should still be undefined at this point"); }
			}
		}
    }

    control {
        execute(TC_Sem_2204_the_check_operation_082(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getreply) with assignment in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_066 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{ p_par1 := 1} value 5);
	}
	
	testcase TC_Sem_2204_the_check_operation_066() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_par, v_val;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := -}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(getreply(S:{ p_par1 := ?} value integer:(0..10)) -> value v_val param (v_par := p_par1)) { 
				if ( match(v_par, 1) and match(v_val, 5)) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect parameter or return value"); }
			}
		}
		p.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_066(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(receive) with assignment in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_010 {

	type port P message {
		inout integer;
		address integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_010() runs on GeneralComp {
		var integer v_val;
		p.send(integer:1) to 80;
        alt
		{
        	[] p.check(receive(integer:?) from P.address:(20..40) -> value v_val) { 
				setverdict(fail, "Incorrect match");
			}
			[] p.receive { 
				if (not isbound(v_val)) { setverdict(pass, "As expected, the check operation didn't match"); }
				else { setverdict(fail, "The value should still be undefined at this point"); }
			}
		}
    }

    control {
        execute(TC_Sem_2204_the_check_operation_010(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(catch) in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_093 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_093() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(catch(S, integer:(0..10))) { 
				setverdict(pass, "Check operation successful"); 
			}
		}
		any port.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_093(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(getreply) works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_053 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{});
	}
	
	testcase TC_Sem_2204_the_check_operation_053() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(getreply) { setverdict(pass, "Check operation successful"); }
		}
		any port.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_053(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check with assignment in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_106 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		var GeneralComp v_src;
        alt
		{
        	[] p.check(from self -> sender v_src) { 
				setverdict(fail, "Incorrect match"); 
			}
			[] p.getcall { 
				if (not isbound(v_src)) { setverdict(pass, "As expected, the check operation didn't match"); }
				else { setverdict(fail, "The v_src variable should still be undefined at this point"); }
			}
		}		
	}
	
	testcase TC_Sem_2204_the_check_operation_106() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_106(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(catch) works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_079 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_079() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        any port.check(catch);
		setverdict(pass, "Check operation successful");
		any port.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_079(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(catch) in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_081 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_081() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(catch(S, integer:(100..200))) { setverdict(fail, "Incorrect match"); }
			[] p.catch { setverdict(pass, "As expected, the check operation didn't match"); }
		}
    }

    control {
        execute(TC_Sem_2204_the_check_operation_081(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(receive) with assignment works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_008 {

	type integer address;
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_008() runs on GeneralComp {
		var address v_addr;
		p.send(integer:1) to 80;
        any port.check(receive -> sender v_addr);
		if (v_addr == 80) { setverdict(pass, "Check operation successful"); }
		else { setverdict(fail, "Incorrect address value"); }
		any port.receive;
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_008(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(getreply) with assignment works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_056 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{});
	}
	
	testcase TC_Sem_2204_the_check_operation_056() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        any port.check(getreply -> sender v_src);
		if (v_src == v_ptc) { setverdict(pass, "Check operation successful"); }
		else { setverdict(fail, "Counterpart mismatch"); }
		any port.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_056(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_107 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{ p_par1 := 1} value 5);
	}
	
	altstep a() runs on GeneralComp {
		[] p.getreply { 
			setverdict(pass, "As expected, the check operation didn't match"); 
			stop;
		}
	}
	
	testcase TC_Sem_2204_the_check_operation_107() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		activate(a());
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := - }, nowait);
		v_ptc.start(f());
        p.check(from self);
		setverdict(fail, "Incorrect match");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_107(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getreply) with assignment in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_058 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{ p_par1 := 1} value 5);
	}
	
	testcase TC_Sem_2204_the_check_operation_058() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_par, v_val;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := - }, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(getreply(S:{p_par1 := ?} value (100..200)) -> value v_val param (v_par := p_par1)) { 
				setverdict(fail, "Incorrect match"); 
			}
			[] p.getreply { 
				if (not isbound(v_par) and not isbound(v_val)) {
					setverdict(pass, "As expected, the check operation didn't match"); 
				}
				else { setverdict(fail, "The v_par and v_val variables should still be undefined at this point"); }
			}
		}
    }

    control {
        execute(TC_Sem_2204_the_check_operation_058(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(getcall) works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_025 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
        alt
		{
        	[] p.check(getcall) { setverdict(pass, "Check operation successful"); }
		}
		p.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_025() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_025(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(receive) in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_023 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	testcase TC_Sem_2204_the_check_operation_023() runs on GeneralComp {
		p2.send(integer:1);
        any port.check(receive(integer:?));
		setverdict(pass, "Check operation successful");
		any port.receive(integer:?);
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_023(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_111 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{ p_par1 := 1} value 5);
	}
	
	altstep a() runs on GeneralComp {
		[] any port.getreply { 
			setverdict(pass, "As expected, the check operation didn't match"); 
			stop;
		}
	}
	
	testcase TC_Sem_2204_the_check_operation_111() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		activate(a());
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := - }, nowait);
		v_ptc.start(f());
        any port.check(from self);
		setverdict(fail, "Incorrect match");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_111(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check with assignment works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_098 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;		
	}
	
	function f() runs on GeneralComp {
        var GeneralComp v_src;
		alt
		{
        	[] p.check(-> sender v_src) {
				if (v_src == mtc) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Unexpected sender value"); }
			}
		}
		p.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_098() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_098(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getreply) with assignment in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_070 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{ p_par1 := 1} value 5);
	}
	
	testcase TC_Sem_2204_the_check_operation_070() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_par, v_val;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := -}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(getreply(S:{ p_par1 := ?} value integer:(0..10)) -> value v_val param (v_par := p_par1)) { 
				if (match(v_par, 1) and match(v_val, 5)) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect parameter or return value"); }
			}
		}
		any port.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_070(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getcall) with assignment in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_044 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		var integer v_val;
        p.check(getcall(S:{ p_par1 := (0..10)}) -> param (v_val));
		if (v_val == 1) { setverdict(pass, "Check operation successful"); }
		else { setverdict(fail, "Incorrect parameter value"); }
		p.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_044() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_044(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getreply) with assignment in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_062 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{ p_par1 := 1} value 5);
	}
	
	testcase TC_Sem_2204_the_check_operation_062() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_par, v_val;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := - }, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(getreply(S:{p_par1 := ?} value (100..200)) -> value v_val param (v_par := p_par1)) { 
				setverdict(fail, "Incorrect match"); 
			}
			[] any port.getreply { 
				if (not isbound(v_par) and not isbound(v_val)) {
					setverdict(pass, "As expected, the check operation didn't match"); 
				}
				else { setverdict(fail, "The v_par and v_val variables should still be undefined at this point"); }
			}
		}
    }

    control {
        execute(TC_Sem_2204_the_check_operation_062(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(receive) works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_001 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_001() runs on GeneralComp {
		p.send(integer:1);
        alt
		{
        	[] p.check(receive) { setverdict(pass, "Check operation successful"); }
		}
		p.receive;
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_001(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(receive) with assignment in case of successful match works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_024 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	testcase TC_Sem_2204_the_check_operation_024() runs on GeneralComp {
		var integer v_val;
		p2.send(integer:1);
        any port.check(receive(integer:(0..10)) -> value v_val);
		if (v_val == 1) { setverdict(pass, "Check operation successful"); }
		else { setverdict(fail, "Incorrect address value"); }
		any port.receive(integer:?);
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_024(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(receive) works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_005 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	testcase TC_Sem_2204_the_check_operation_005() runs on GeneralComp {
		p2.send(integer:1);
        alt
		{
        	[] any port.check(receive) { setverdict(pass, "Check operation successful"); }
		}
		any port.receive;
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_005(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(catch) in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_083 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	altstep a() runs on GeneralComp {
		[] p.catch { 
			setverdict(pass, "As expected, the check operation didn't match"); 
			stop;
		}
	}
	
	testcase TC_Sem_2204_the_check_operation_083() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		activate(a());
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        p.check(catch(S, integer:?) from self);
		setverdict(fail, "Incorrect match");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_083(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(catch) with assignment in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_090 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_090() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_par, v_val;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(catch(S, integer:(0..10)) -> value v_val) { 
				if (v_val == 1) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect exception value"); }
			}
		}
		p.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_090(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(catch) in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_091 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_091() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        p.check(catch(S, integer:?) from v_ptc);
		setverdict(pass, "Check operation successful"); 
		p.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_091(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(catch) with assignment works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_080 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_080() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        any port.check(catch -> sender v_src);
		if (v_src == v_ptc) { setverdict(pass, "Check operation successful"); }
		else { setverdict(fail, "Counterpart mismatch"); }
		any port.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_080(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getreply) with assignment in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_060 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
		var integer v_val;
		var GeneralComp v_src;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{ p_par1 := 1} value 5);
	}
	
	altstep a() runs on GeneralComp {
		[] p.getreply { 
			if (not isbound(v_val) and not isbound(v_src)) {
				setverdict(pass, "As expected, the check operation didn't match"); 
			}
			else { setverdict(fail, "The v_val and v_src variables should still be undefined at this point"); }
			stop;
		}
	}
	
	testcase TC_Sem_2204_the_check_operation_060() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		activate(a());
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := - }, nowait);
		v_ptc.start(f());
        p.check(getreply(S:{p_par1 := ?} value (100..200)) -> value v_val sender v_src);
		setverdict(fail, "Incorrect match"); 
    }

    control {
        execute(TC_Sem_2204_the_check_operation_060(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(receive) with assignment in case of successful match works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_020 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_020() runs on GeneralComp {
		var integer v_val;
		p.send(integer:1);
        p.check(receive(integer:(0..10)) -> value v_val);
		if (v_val == 1) { setverdict(pass, "Check operation successful"); }
		else { setverdict(fail, "Incorrect address value"); }
		p.receive(integer:?);
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_020(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(receive) with assignment in case of unsuccessful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_014 {

	type integer address;
	
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	testcase TC_Sem_2204_the_check_operation_014() runs on GeneralComp {
		var integer v_val;
		p2.send(integer:1) to 80;
        alt
		{
        	[] any port.check(receive(integer:?) from address:(20..40) -> value v_val) { 
				setverdict(fail, "Incorrect match");
			}
			[] any port.receive { 
				if (not isbound(v_val)) { setverdict(pass, "As expected, the check operation didn't match"); }
				else { setverdict(fail, "The value should still be undefined at this point"); }
			}
		}
    }

    control {
        execute(TC_Sem_2204_the_check_operation_014(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(catch) with assignment in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_094 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_094() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_val;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(catch(S, integer:(0..10)) -> value v_val) { 
				if (v_val == 1) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect exception value"); }
			}
		}
		any port.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_094(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_103 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{});
	}
	
	testcase TC_Sem_2204_the_check_operation_103() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        any port.check;
		setverdict(pass, "Check operation successful");
		any port.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_103(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getreply) in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_069 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{ p_par1 := 1} value 5);
	}
	
	testcase TC_Sem_2204_the_check_operation_069() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := -}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(getreply(S:{ p_par1 := ?} value integer:(0..10))) { 
				setverdict(pass, "Check operation successful"); 
			}
		}
		any port.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_069(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behation of port.check(receive) with assignment in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_018 {

	type port P message {
		inout integer;
		address integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_018() runs on GeneralComp {
		var integer v_val, v_addr;
		p.send(integer:1) to 80;
        alt
		{
        	[] p.check(receive(integer:(0..10)) from P.address:(10..100) -> value v_val sender v_addr) { 
				if (match(v_val, 1) and match(v_addr, 80)) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect message value or address"); }
			}	
		}
		p.receive(integer:?);
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_018(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of port.check(getreply) in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_067 {

	signature S(out integer p_par1) return integer;
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{ p_par1 := 1} value 5);
	}
	
	testcase TC_Sem_2204_the_check_operation_067() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{ p_par1 := -}, nowait);
		v_ptc.start(f());
        p.check(getreply(S:{ p_par1 := ?} value integer:(0..10)) from v_ptc);
		setverdict(pass, "Check operation successful"); 
		p.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_067(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(getcall) works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_031 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
        any port.check(getcall);
		setverdict(pass, "Check operation successful");
		any port.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_031() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_031(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_099 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.reply(S:{});
	}
	
	testcase TC_Sem_2204_the_check_operation_099() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        p.check;
		setverdict(pass, "Check operation successful");
		p.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_099(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(receive) with assignment works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_006 {

	type integer address;
	
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	testcase TC_Sem_2204_the_check_operation_006() runs on GeneralComp {
		var address v_addr;
		p2.send(integer:1) to 80;
        alt
		{
        	[] any port.check(receive -> sender v_addr) { 
				if (v_addr == 80) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect address value"); }
			}	
		}
		any port.receive;
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_006(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getcall) with assignment in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_046 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		var integer v_val;
		var GeneralComp v_src;
        alt
		{
        	[] any port.check(getcall(S:{ p_par1 := (0..10)}) from GeneralComp:? -> param (v_val) sender v_src) { 
				if (match(v_val, 1) and match(v_src, mtc)) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect parameter value or sender"); }
			}
		}
		any port.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_046() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_046(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(catch) with assignment in case of successful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_096 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_096() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		var integer v_val;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] any port.check(catch(S, integer:complement(4, 5, 6)) -> value v_val sender v_src) { 
				if (match(v_val, 1) and match(v_src, v_ptc)) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect exception value or sender"); }
			}
		}
		any port.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_096(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check with assignment in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_112 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
		var GeneralComp v_src;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.raise(S, integer:1);
	}
	
	altstep a() runs on GeneralComp {
		[] any port.catch { 
			if (not isbound(v_src)) {
				setverdict(pass, "As expected, the check operation didn't match"); 
			}
			else { setverdict(fail, "The v_src variable should still be undefined at this point"); }
			stop;
		}
	}
	
	testcase TC_Sem_2204_the_check_operation_112() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		activate(a());
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        any port.check(from self -> sender v_src);
		setverdict(fail, "Incorrect match"); 
    }

    control {
        execute(TC_Sem_2204_the_check_operation_112(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that any port.check(getreply) works correctly as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_055 {

	signature S();
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		p2.getcall;
		setverdict(pass, "Call received");
		p2.reply(S:{});
	}
	
	testcase TC_Sem_2204_the_check_operation_055() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{}, nowait);
		v_ptc.start(f());
        any port.check(getreply);
		setverdict(pass, "Check operation successful");
		any port.getreply;
		setverdict(pass, "Reply still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_055(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_097 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	testcase TC_Sem_2204_the_check_operation_097() runs on GeneralComp {
		p.send(integer:1);
        alt
		{
        	[] p.check { setverdict(pass, "Check operation successful"); }
		}
		p.receive;
		setverdict(pass, "Message still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_097(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check(getcall) with assignment in case of unsuccessful match in standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_040 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
		var integer v_val;
	}
	
	altstep a() runs on GeneralComp {
		[] any port.getcall { 
			if (not isbound(v_val)) { setverdict(pass, "As expected, the check operation didn't match"); }
			else { setverdict(fail, "The value should still be undefined at this point"); }
			stop;
		}
	}
	
	function f() runs on GeneralComp {
		activate(a());
        any port.check(getcall(S:{ p_par1 := (0..10)}) from self -> param(v_val := p_par1));
		setverdict(fail, "Incorrect match"); 
	}
	
	testcase TC_Sem_2204_the_check_operation_040() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_040(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify that port.check(catch) with assignment works correctly inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_074 {

	signature S() exception(integer);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
	
	function f() runs on GeneralComp {
		p.getcall;
		setverdict(pass, "Call received");
		p.raise(S, integer:1);
	}
	
	testcase TC_Sem_2204_the_check_operation_074() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		connect(self:p, v_ptc:p);
		p.call(S:{}, nowait);
		v_ptc.start(f());
        alt
		{
        	[] p.check(catch -> sender v_src) { 
				if (v_src == v_ptc) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Counterpart mismatch"); }
			}
		}
		p.catch;
		setverdict(pass, "Exception still on the top of the queue");
    }

    control {
        execute(TC_Sem_2204_the_check_operation_074(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.4, Verify behaviour of any port.check with assignment in case of successful match inside alt
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_2204_the_check_operation_118 {

	signature S(integer p_par1);
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p1, p2;
	}
	
	function f() runs on GeneralComp {
		var GeneralComp v_src;
        alt
		{
        	[] any port.check(from GeneralComp:? -> sender v_src) { 
				if (v_src == mtc) { setverdict(pass, "Check operation successful"); }
				else { setverdict(fail, "Incorrect sender"); }
			}
		}
		any port.getcall;
		setverdict(pass, "Call still on the top of the queue");		
	}
	
	testcase TC_Sem_2204_the_check_operation_118() runs on GeneralComp system GeneralComp{
		var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p1, v_ptc:p1);
		connect(self:p2, v_ptc:p2);
		p2.call(S:{ p_par1 := 1 }, nowait);
		v_ptc.start(f());
		v_ptc.done;
    }

    control {
        execute(TC_Sem_2204_the_check_operation_118(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.5, unicast raise operation
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Exceptions to one or more call operations may be sent to one, several or all peer entities
// connected to the addressed port. This can be specified in the same manner as described in 
// clause 22.2.1. This means, the argument of the to clause of a raise operation is for 
// unicast exceptions the address of one receiving entity, for multicast exceptions a list of 
// addresses of a set of receivers and for broadcast exceptions the all component keywords.


module Sem_220305_raise_operation_002 {
	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f(integer p_expected) runs on GeneralComp
	{
        p.call(S:{}) {
            [] p.catch(S, p_expected) { setverdict(pass); }
            [] p.catch { setverdict(fail); }
        }
	}
	
    testcase TC_Sem_220305_raise_operation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc1 := GeneralComp.create, v_ptc2 := GeneralComp.create;
		connect(self:p, v_ptc1:p);
        connect(self:p, v_ptc2:p);
        v_ptc1.start(f(1));
        v_ptc2.start(f(2));
        p.getcall(S:?);
        p.getcall(S:?); // call from both components expected
		p.raise(S, 1) to v_ptc1;
        p.raise(S, 2) to v_ptc2;
        all component.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220305_raise_operation_002(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.5, simple raise operation
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The value part of the raise operation consists of the signature reference followed by the 
// exception value.

module Sem_220305_raise_operation_001 {
	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
		p.getcall(S:?);
		p.raise(S, 1);
        setverdict(pass);
	}
	
    testcase TC_Sem_220305_raise_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		connect(self:p, v_ptc:p);
        v_ptc.start(f());
	    p.call(S:{}, nowait); // no processing of the exception to avoid possible errors in the catch operation
        v_ptc.done;
    }

    control {
        execute(TC_Sem_220305_raise_operation_001(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.5, multicast raise operation
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Exceptions to one or more call operations may be sent to one, several or all peer entities
// connected to the addressed port. This can be specified in the same manner as described in 
// clause 22.2.1. This means, the argument of the to clause of a raise operation is for 
// unicast exceptions the address of one receiving entity, for multicast exceptions a list of 
// addresses of a set of receivers and for broadcast exceptions the all component keywords.


module Sem_220305_raise_operation_004 {
	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f(integer p_expected) runs on GeneralComp
	{
        p.call(S:{}) {
            [] p.catch(S, p_expected) { setverdict(pass); }
            [] p.catch { setverdict(fail); }
        }
	}
    
    const integer c_ptcCount := 4;
	
    testcase TC_Sem_220305_raise_operation_004() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptcs[4];
        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            v_ptcs[i] := GeneralComp.create;
            connect(self:p, v_ptcs[i]:p);
            if (i mod 2 == 0) { v_ptcs[i].start(f(1)); } 
            else { v_ptcs[i].start(f(2)); }
            p.getcall(S:?);
        }
		p.raise(S, 1) to (v_ptcs[0], v_ptcs[2] );
        p.raise(S, 2) to (v_ptcs[1], v_ptcs[3] );
        all component.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220305_raise_operation_004(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.5, broadcast raise operation
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Exceptions to one or more call operations may be sent to one, several or all peer entities
// connected to the addressed port. This can be specified in the same manner as described in 
// clause 22.2.1. This means, the argument of the to clause of a raise operation is for 
// unicast exceptions the address of one receiving entity, for multicast exceptions a list of 
// addresses of a set of receivers and for broadcast exceptions the all component keywords.

module Sem_220305_raise_operation_003 {
	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
        p.call(S:{}) {
            []p.catch { setverdict(pass); }
        }
	}
	
    testcase TC_Sem_220305_raise_operation_003() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc1 := GeneralComp.create, v_ptc2 := GeneralComp.create;
		connect(self:p, v_ptc1:p);
        connect(self:p, v_ptc2:p);
        v_ptc1.start(f());
        v_ptc2.start(f());
        p.getcall(S:?);
        p.getcall(S:?); // call from both components expected
		p.raise(S, 1) to all component;
        all component.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220305_raise_operation_003(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:22.3.1, Ensure that the IUT correctly handles multiple client calls to the same server 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220301_CallOperation_004 {

    type charstring address;
    const address c_client1Addr := "client1Addr";
    const address c_client2Addr := "client2Addr";

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220301_CallOperation_004(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;


    template p_Sem_220301_CallOperation_004 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220301_CallOperation_004 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220301_CallOperation_004 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220301_CallOperation_004;
    }

    type component GeneralComp {
        port remotePort PCO;
        var address v_myAddress;
    }

    function f_ClientQuery(address p_myAddress) runs on GeneralComp {
        var integer v_zero:=0;
        var integer v_one:=1;
        var boolean first:=true;
        v_myAddress := p_myAddress;
	
        PCO.call(p_Sem_220301_CallOperation_004:s_callTemplate, 5.0) {
	
            [first] PCO.getreply(p_Sem_220301_CallOperation_004:s_returnTemplate value 1) {
                first:=false;
                setverdict(pass);
            }
            [] PCO.catch (timeout) {
                setverdict(fail, v_myAddress&" did not receive a response");
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
        var address v_clientAddress;
        var integer v_par1;
        var integer v_par3;
        timer t_timeout:=30.0;
		
        template p_Sem_220301_CallOperation_004 s_acceptTemplate := {
            p_par1 := ?,
            p_par2 := ?,
            p_par3 := ?
        };

		
        t_timeout.start;
	
        alt {
            [] PCO.getcall(p_Sem_220301_CallOperation_004:s_acceptTemplate) -> param(v_par1, - , v_par3) sender v_clientAddress {
                PCO.reply(p_Sem_220301_CallOperation_004:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1) to v_clientAddress;  	//procedure return values are sent
                repeat;
            }
            [] t_timeout.timeout {
                setverdict(fail);
            }
        }
	 
    }
	
    function f_setAddress(address p_myAddress) runs on GeneralComp {
        v_myAddress := p_myAddress;
    }
	
    testcase TC_Sem_220301_CallOperation_004() runs on GeneralComp system GeneralComp {
        var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
        var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
        var GeneralComp client2 := GeneralComp.create("RemoteProcedure Client");
        // map the PTCs to the system port
        connect(server:PCO, client:PCO);
        connect(server:PCO, client2:PCO);

        server.start(f_ServerResponses());
       
        client.start(f_ClientQuery(c_client1Addr));
        client2.start(f_ClientQuery(c_client2Addr));

        interleave {
            [] client.done {}
            [] client2.done {}
        }
        server.stop;

        alt {
            [] all component.done {}
        }

        disconnect(server:PCO);
    }

    control{
        execute(TC_Sem_220301_CallOperation_004(), 30.0);
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:22.3.1, Ensure that the IUT correctly handles procedure call operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220301_CallOperation_001 {

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220301_CallOperation_001(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Sem_220301_CallOperation_001 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220301_CallOperation_001 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220301_CallOperation_001 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220301_CallOperation_001;
    }

    type component GeneralComp {
        port remotePort PCO;
    }

    function f_ClientQuery() runs on GeneralComp {
        var integer v_zero:=0;
        var integer v_one:=1;
	
        PCO.call(p_Sem_220301_CallOperation_001:s_callTemplate, 5.0) {
	
            [] PCO.getreply(p_Sem_220301_CallOperation_001:s_wrongTemplate value 1) {
                setverdict(fail);
            }
            [] PCO.getreply(p_Sem_220301_CallOperation_001:s_returnTemplate value 2) {
                setverdict(fail);
            }
            [v_one>v_zero] PCO.getreply(p_Sem_220301_CallOperation_001:s_returnTemplate value 1) {		//check that boolean guard is correctly evaluated
                setverdict(pass);
            }
            [] PCO.catch (timeout) {
                setverdict(fail);
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
	
        var integer v_par1;
        var integer v_par3;
        timer t_timeout:=30.0;
		
        template p_Sem_220301_CallOperation_001 s_acceptTemplate := {
            p_par1 := ?,
            p_par2 := ?,
            p_par3 := ?
        };

		
        t_timeout.start;
	
        alt {
            [] PCO.getcall(p_Sem_220301_CallOperation_001:s_acceptTemplate) -> param(v_par1, - , v_par3) {
                PCO.reply(p_Sem_220301_CallOperation_001:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1);  	//procedure return values are sent
                repeat;
            }
            [] t_timeout.timeout {
                setverdict(fail);
            }
        }
	 
    }

	
    testcase TC_Sem_220301_CallOperation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
        var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
        // map the PTCs to the system port
        connect(server:PCO, client:PCO);

        server.start(f_ServerResponses());
        client.start(f_ClientQuery());

        alt {
            [] client.done {
                server.stop;
            }
        }

        alt {
            [] all component.done {}
        }

        disconnect(server:PCO);
    }

    control{
        execute(TC_Sem_220301_CallOperation_001());
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:22.3.1, Ensure that the IUT correctly handles broadcast/multicast procedure call 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220301_CallOperation_005 {

    type charstring address;
    const address c_server1Addr := "server1Addr";
    const address c_server2Addr := "server2Addr";
    const address c_clientAddr := "clientAddr";

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220301_CallOperation_005(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Sem_220301_CallOperation_005 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220301_CallOperation_005 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220301_CallOperation_005 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220301_CallOperation_005;
    }

    type component GeneralComp {
        port remotePort PCO;
        var address v_myAddress;
    }

    function f_ClientQuery(address p_myAddress) runs on GeneralComp {
        var integer v_zero:=0;
        var integer v_one:=1;
        timer t_timer:=5.0;

        v_myAddress := p_myAddress;
 
        //  validate broadcast calling
        PCO.call(p_Sem_220301_CallOperation_005:s_callTemplate, nowait) to all component;
        t_timer.start;
        
        alt {
            //check that we get a reply from first server
            [] PCO.getreply(p_Sem_220301_CallOperation_005:s_returnTemplate value 1) from c_server1Addr {
                alt {
                    //check that we get a reply from second server
                    [] PCO.getreply(p_Sem_220301_CallOperation_005:s_returnTemplate value 1) from c_server2Addr {
                        setverdict(pass);
                    }
                    [] t_timer.timeout {
                        setverdict(fail);
                    }
                }
            }
            [] t_timer.timeout {
                setverdict(fail);
            }
        }
    }
    
    template p_Sem_220301_CallOperation_005 s_acceptTemplate := {
        p_par1 := ?,
        p_par2 := ?,
        p_par3 := ?
    };

    function f_ServerResponses(address p_myAddress) runs on GeneralComp {
        var address v_clientAddress;
        var integer v_par1;
        var integer v_par3;
        timer t_timeout:=30.0;
        v_myAddress := p_myAddress;
  

  
        t_timeout.start;
 
        alt {
            [] PCO.getcall(p_Sem_220301_CallOperation_005:s_acceptTemplate) -> param(v_par1, - , v_par3) sender v_clientAddress {
                PCO.reply(p_Sem_220301_CallOperation_005:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1) to v_clientAddress;
                repeat;
            }
            [] t_timeout.timeout {
                setverdict(fail);
            }
        }
  
    }

 
    function f_setAddress(address p_myAddress) runs on GeneralComp {
        v_myAddress := p_myAddress;
    }
 
    testcase TC_Sem_220301_CallOperation_005() runs on GeneralComp system GeneralComp {
        var GeneralComp server := GeneralComp.create("RemoteProcedure Service") alive;
        var GeneralComp server2 := GeneralComp.create("RemoteProcedure Service2") alive;
        var GeneralComp client := GeneralComp.create("RemoteProcedure Client") alive;
        // map the PTCs to the system port
        connect(server:PCO, client:PCO);
        connect(server2:PCO, client:PCO);

        // set server address and start operation
        server.start(f_ServerResponses(c_server1Addr));
        server2.start(f_ServerResponses(c_server2Addr));
       
        client.start(f_ClientQuery(c_clientAddr));

        alt {
            [] client.done {
                server.stop;
                server2.stop;
            }
        }

        alt {
            [] all component.done {}
        }

        disconnect(server:PCO);
        disconnect(server2:PCO);
    }

    control{
        execute(TC_Sem_220301_CallOperation_005());
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:22.3.1, Ensure that the IUT correctly handles non-blocking procedure call 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220301_CallOperation_003 {

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220301_CallOperation_003(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Sem_220301_CallOperation_003 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220301_CallOperation_003 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220301_CallOperation_003 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220301_CallOperation_003;
    }

    type component GeneralComp {
        port remotePort PCO;
    }

    function f_ClientQuery() runs on GeneralComp {
        var integer v_zero:=0;
        var integer v_one:=1;
        timer t_timer:=5.0;
	
        PCO.call(p_Sem_220301_CallOperation_003:s_callTemplate, nowait);  //check non-blocking call
        t_timer.start;
        
        alt {
	
            [] PCO.getreply(p_Sem_220301_CallOperation_003:s_wrongTemplate value 1) {
                setverdict(fail);
            }
            [] PCO.getreply(p_Sem_220301_CallOperation_003:s_returnTemplate value 2) {
                setverdict(fail);
            }
            [] PCO.getreply(p_Sem_220301_CallOperation_003:s_returnTemplate value 1) {
                setverdict(pass);
            }
            [] t_timer.timeout {
                setverdict(fail);
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
	
        var integer v_par1;
        var integer v_par3;
        timer t_timeout:=30.0;
		
        template p_Sem_220301_CallOperation_003 s_acceptTemplate := {
            p_par1 := ?,
            p_par2 := ?,
            p_par3 := ?
        };

		
        t_timeout.start;
	
        alt {
            [] PCO.getcall(p_Sem_220301_CallOperation_003:s_acceptTemplate) -> param(v_par1, - , v_par3) {
                PCO.reply(p_Sem_220301_CallOperation_003:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1);  	//procedure return values are sent
                repeat;
            }
            [] t_timeout.timeout {
                setverdict(fail);
            }
        }
	 
    }

	
    testcase TC_Sem_220301_CallOperation_003() runs on GeneralComp system GeneralComp {
        var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
        var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
        // map the PTCs to the system port
        connect(server:PCO, client:PCO);

        server.start(f_ServerResponses());
        client.start(f_ClientQuery());

        alt {
            [] client.done {
                server.stop;
            }
        }

        alt {
            [] all component.done {}
        }

        disconnect(server:PCO);
    }

    control{
        execute(TC_Sem_220301_CallOperation_003());
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:22.3.1, Ensure that the IUT correctly handles blocking procedure call 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220301_CallOperation_007 {

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220301_CallOperation_007(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Sem_220301_CallOperation_007 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220301_CallOperation_007 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220301_CallOperation_007 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220301_CallOperation_007;
    }

    type component GeneralComp {
        port remotePort PCO;
    }

    function f_ClientQuery() runs on GeneralComp {
        var integer v_zero:=0;
        var integer v_one:=1;
	
        PCO.call(p_Sem_220301_CallOperation_007:s_callTemplate,5.0) {   //blocking version of procedure call
        	
            [] PCO.getreply(p_Sem_220301_CallOperation_007:s_wrongTemplate value 1) {
                setverdict(fail);
            }
            [] PCO.getreply(p_Sem_220301_CallOperation_007:s_returnTemplate value 2) {
                setverdict(fail);
            }
            [] PCO.getreply(p_Sem_220301_CallOperation_007:s_returnTemplate value 1) {
                setverdict(pass);
            }
            [] PCO.catch(timeout) {
                setverdict(fail);
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
	
        var integer v_par1;
        var integer v_par3;
        timer t_timeout:=30.0;
		
        template p_Sem_220301_CallOperation_007 s_acceptTemplate := {
            p_par1 := ?,
            p_par2 := ?,
            p_par3 := ?
        };

		
        t_timeout.start;
	
        alt {
            [] PCO.getcall(p_Sem_220301_CallOperation_007:s_acceptTemplate) -> param(v_par1, - , v_par3) {
                PCO.reply(p_Sem_220301_CallOperation_007:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1);  	//procedure return values are sent
                repeat;
            }
            [] t_timeout.timeout {
                setverdict(fail);
            }
        }
	 
    }

	
    testcase TC_Sem_220301_CallOperation_007() runs on GeneralComp system GeneralComp {
        var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
        var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
        // map the PTCs to the system port
        connect(server:PCO, client:PCO);

        server.start(f_ServerResponses());
        client.start(f_ClientQuery());

        alt {
            [] client.done {
                server.stop;
            }
        }

        alt {
            [] all component.done {}
        }

        disconnect(server:PCO);
    }

    control{
        execute(TC_Sem_220301_CallOperation_007());
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:22.3.1, Ensure that the IUT correctly handles broadcast/multicast procedure call 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220301_CallOperation_006 {

    type charstring address;
    const address c_server1Addr := "server1Addr";
    const address c_server2Addr := "server2Addr";
    const address c_clientAddr := "clientAddr";

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220301_CallOperation_006(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Sem_220301_CallOperation_006 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220301_CallOperation_006 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220301_CallOperation_006 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220301_CallOperation_006;
    }

    type component GeneralComp {
        port remotePort PCO;
        var address v_myAddress;
    }

    function f_ClientQuery(address p_myAddress) runs on GeneralComp {
        var integer v_zero:=0;
        var integer v_one:=1;
        timer t_timer:=5.0;

        v_myAddress := p_myAddress;
	
        //  validate multicast calling
        PCO.call(p_Sem_220301_CallOperation_006:s_callTemplate, nowait) to (c_server1Addr,c_server2Addr);
        t_timer.start;
        
        alt {
            //check that we get a reply from first server
            [] PCO.getreply(p_Sem_220301_CallOperation_006:s_returnTemplate value 1) from c_server1Addr {
                alt {
                    //check that we get a reply from second server
                    [] PCO.getreply(p_Sem_220301_CallOperation_006:s_returnTemplate value 1) from c_server2Addr {
                        setverdict(pass);
                    }
                    [] t_timer.timeout {
                        setverdict(fail);
                    }
                }
            }
            [] t_timer.timeout {
                setverdict(fail);
            }
        }
    }

    template p_Sem_220301_CallOperation_006 s_acceptTemplate := {
        p_par1 := ?,
        p_par2 := ?,
        p_par3 := ?
    };

    function f_ServerResponses(address p_myAddress) runs on GeneralComp {
        var address v_clientAddress;
        var integer v_par1;
        var integer v_par3;
        timer t_timeout:=30.0;
        v_myAddress := p_myAddress;
		
		
        t_timeout.start;
	
        alt {
            [] PCO.getcall(p_Sem_220301_CallOperation_006:s_acceptTemplate) -> param(v_par1, - , v_par3) sender v_clientAddress {
                PCO.reply(p_Sem_220301_CallOperation_006:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1) to v_clientAddress;
                repeat;
            }
            [] t_timeout.timeout {
                setverdict(fail);
            }
        }
	 
    }

	
    function f_setAddress(address p_myAddress) runs on GeneralComp {
        v_myAddress := p_myAddress;
    }
	
    testcase TC_Sem_220301_CallOperation_006() runs on GeneralComp system GeneralComp {
        var GeneralComp server := GeneralComp.create("RemoteProcedure Service") alive;
        var GeneralComp server2 := GeneralComp.create("RemoteProcedure Service2") alive;
        var GeneralComp client := GeneralComp.create("RemoteProcedure Client") alive;
        // map the PTCs to the system port
        connect(server:PCO, client:PCO);
        connect(server2:PCO, client:PCO);

        // set server address and start operation
        server.start(f_ServerResponses(c_server1Addr));
        server2.start(f_ServerResponses(c_server2Addr));
       
        client.start(f_ClientQuery(c_clientAddr));

        alt {
            [] client.done {
                server.stop;
                server2.stop;
            }
        }

        alt {
            [] all component.done {}
        }

        disconnect(server:PCO);
        disconnect(server2:PCO);
    }

    control{
        execute(TC_Sem_220301_CallOperation_006());
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:22.3.1, Ensure that the IUT correctly handles procedure call operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220301_CallOperation_002 {

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220301_CallOperation_002(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Sem_220301_CallOperation_002 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220301_CallOperation_002 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220301_CallOperation_002 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220301_CallOperation_002;
    }

    type component GeneralComp {
        port remotePort PCO;
    }

    function f_ClientQuery() runs on GeneralComp {
        var integer v_zero:=0;
        var integer v_one:=1;
	
        PCO.call(p_Sem_220301_CallOperation_002:s_callTemplate, 5.0) {
	
            [] PCO.getreply(p_Sem_220301_CallOperation_002:s_wrongTemplate value 1) {
                setverdict(fail);
            }
            [] PCO.getreply(p_Sem_220301_CallOperation_002:s_returnTemplate value 2) {
                setverdict(fail);
            }
            [v_one<v_zero] PCO.getreply(p_Sem_220301_CallOperation_002:s_returnTemplate value 1) {		//check that boolean guard is correctly evaluated
                setverdict(fail);
            }
            [] PCO.catch (timeout) {  //also timeout exception is validated
                setverdict(pass);
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
	
        var integer v_par1;
        var integer v_par3;
        timer t_timeout:=30.0;
		
        template p_Sem_220301_CallOperation_002 s_acceptTemplate := {
            p_par1 := ?,
            p_par2 := ?,
            p_par3 := ?
        };

		
        t_timeout.start;
	
        alt {
            [] PCO.getcall(p_Sem_220301_CallOperation_002:s_acceptTemplate) -> param(v_par1, - , v_par3) {
                PCO.reply(p_Sem_220301_CallOperation_002:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1);  	//procedure return values are sent
                repeat;
            }
            [] t_timeout.timeout {
                setverdict(fail);
            }
        }
	 
    }

	
    testcase TC_Sem_220301_CallOperation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
        var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
        // map the PTCs to the system port
        connect(server:PCO, client:PCO);

        server.start(f_ServerResponses());
        client.start(f_ClientQuery());

        alt {
            [] client.done {
                server.stop;
            }
        }

        alt {
            [] all component.done {}
        }

        disconnect(server:PCO);
    }

    control{
        execute(TC_Sem_220301_CallOperation_002());
    }

}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.4, @decoded redirect parameter assignment with encoding parameter
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// In case the referenced field is of the universal charstring type, the @decoded 
// clause can contain an optional parameter defining the encoding format. The 
// parameter shall be of the charstring type and it shall contain one of the 
// strings allowed for the decvalue_unichar function (specified in clause C.5.4).

module Sem_220304_getreply_operation_019 {
	signature S(out universal charstring p_par);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var integer v_src := 1953719668 with { encode "32bit" };
        var universal charstring v_str := encvalue_unichar(v_src, "UTF-16LE");      
        p.getcall(S:?);
        p.reply(S:{ p_par := v_str });
    }
	
    testcase TC_Sem_220304_getreply_operation_019() runs on GeneralComp system GeneralComp {
        var integer v_res with { encode "32bit" };        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ p_par := - }) {
            [] p.getreply(S:?) -> param (v_res := p_par) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getreply { setverdict(fail); }
        };
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220304_getreply_operation_019(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.4, @decoded redirect value assignment of a hexstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a reply, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220304_getreply_operation_016 {
   	type record R {
        integer id,
        hexstring payload
    }

	signature S() return R;
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var charstring v_src := "abc";
        var R v_rec := { id := 2, payload := bit2hex(encvalue(v_src)) };
        p.getcall(S:?);
        p.reply(S:{ } value v_rec);
    }
	
    testcase TC_Sem_220304_getreply_operation_016() runs on GeneralComp system GeneralComp {
        var charstring v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ }) {
            [] p.getreply(S:?) -> value (v_res := payload) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getreply { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220304_getreply_operation_016(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.4, @decoded redirect value assignment of an octetstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a reply, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220304_getreply_operation_017 {
	type record R {
        integer id,
        octetstring payload
    }
    
    signature S() return R;
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var charstring v_src := "abc";        
        var R v_rec := { id := 3, payload := bit2oct(encvalue(v_src)) };
        p.getcall(S:?);
        p.reply(S:{} value v_rec);
    }
	
    testcase TC_Sem_220304_getreply_operation_017() runs on GeneralComp system GeneralComp {
        var charstring v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{}) {
            [] p.getreply(S:?) -> value (v_res := payload) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getreply { setverdict(fail); }

        }
    }

    control {
        execute(TC_Sem_220304_getreply_operation_017(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.4, Verify that any from getreply index redirection works for multidimensional arrays
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction h:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module Sem_220304_getreply_operation_006 {

	signature S(out integer p_par);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 3;
    type component GeneralComp 
	{
		port P p[c_portCount][c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				p[i][j].getcall;
				if (i == 1 and j == 2 or i == 2 and j == 1) { p[i][j].reply(S:{ p_par := i + 1 }); }
			}
		}
	}
	
    testcase TC_Sem_220304_getreply_operation_006() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		var integer v_index[2], v_parValue;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				connect(self:p[i][j], v_ptc:p[i][j]);
				p[i][j].call(S:{ p_par := i + 1 }, nowait);
			}
		}
		v_ptc.start(f());
		v_ptc.done;	
        alt
		{
        	[] any from p.getreply(S:{p_par := (0..c_portCount)}) -> param (v_parValue := p_par) sender v_src @index v_index { 
				if(v_index[0] == 1 and v_index[1] == 2 and v_parValue == v_index[0] + 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Indices or parameter value incorrectly assigned");
		        }				
			}
			[else] { setverdict(fail, "The any from getreply operation didn't match for some reason");  } 
		}
	}

    control {
        execute(TC_Sem_220304_getreply_operation_006(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.4, @decoded redirect value assignment of a universal charstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a reply, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220304_getreply_operation_019 {
	type record R {
        integer id,
        universal charstring payload
    }
    
    signature S() return R;
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var integer v_src := 1953719668 with { encode "32bit" };
        var R v_rec := { id := 5, payload := encvalue_unichar(v_src) };
        p.getcall(S:?);
        p.reply(S:{} value v_rec);
    }
	
    testcase TC_Sem_220304_getreply_operation_019() runs on GeneralComp system GeneralComp {
        var integer v_res with { encode "32bit" };        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{}) {
            [] p.getreply(S:?) -> value (v_res := payload) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getreply { setverdict(fail); }
        }
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220304_getreply_operation_019(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.4, Verify that any from getreply doesn't assign index when there's no suitable match
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// It is also possible to store the index of a port in a single-dimensional port array at which 
// the operation was successful to a variable of type integer or, in case of multi-dimensional 
// port arrays the index of the successful port to an integer array or record of integer variable.
module Sem_220304_getreply_operation_003 {

    signature S(out integer p_par);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].reply(S:{ p_par := i + 100 }) };
		}
	}
	
    testcase TC_Sem_220304_getreply_operation_003() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_index;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{ p_par := - }, nowait);
		}
		v_ptc.start(f());
		v_ptc.done;	
        alt
		{
        	[] any from p.getreply(S:{p_par := (1..10)}) -> @index v_index { 
				setverdict(fail, "The any from getreply operation produced incorrect match"); 
			}
			[else] { setverdict(pass); } 
		}
		if(not isbound(v_index)){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
	}

    control {
        execute(TC_Sem_220304_getreply_operation_003(), 5000.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.4, @decoded redirect value assignment with encoding parameter
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// In case the referenced field is of the universal charstring type, the @decoded 
// clause can contain an optional parameter defining the encoding format. The 
// parameter shall be of the charstring type and it shall contain one of the 
// strings allowed for the decvalue_unichar function (specified in clause C.5.4).

module Sem_220304_getreply_operation_019 {
	type record R {
        integer id,
        universal charstring payload
    }
    
    signature S() return R;
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var integer v_src := 1953719668 with { encode "32bit" };
        var R v_rec := { id := 5, payload := encvalue_unichar(v_src, "UTF-16LE") };
        p.getcall(S:?);
        p.reply(S:{} value v_rec);
    }
	
    testcase TC_Sem_220304_getreply_operation_019() runs on GeneralComp system GeneralComp {
        var integer v_res with { encode "32bit" };        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{}) {
            [] p.getreply(S:?) -> value (v_res := payload) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getreply { setverdict(fail); }
        };
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220304_getreply_operation_019(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.4, @decoded redirect parameter assignment of a hexstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a reply, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220304_getreply_operation_010 {
	signature S(out hexstring p_par);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var charstring v_src := "abc";
        var hexstring v_hs := bit2hex(encvalue(v_src));
        p.getcall(S:?);
        p.reply(S:{ p_par := v_hs });
    }
	
    testcase TC_Sem_220304_getreply_operation_010() runs on GeneralComp system GeneralComp {
        var charstring v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ p_par := - }) {
            [] p.getreply(S:?) -> param (v_res := p_par) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getreply { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220304_getreply_operation_010(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.4, Verify that any from getreply is not triggered if there hasn't been any reply
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// To getreply on any port from a specific port array, use the any from PortArrayRef syntax where 
// PortArrayRef shall be a reference to a  port array identifier.
// The first port which matches all the criteria will cause the operation to be successful even if 
// other ports in the array would also meet the criteria.
module Sem_220304_getreply_operation_001 {
	signature S();
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}

	testcase TC_Sem_220304_getreply_operation_001() runs on GeneralComp system GeneralComp {		
        var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);			
		}
		alt
		{
        	[] any from p.getreply { setverdict(fail, "The any from getreply operation produced incorrect match"); }
			[else] { setverdict(pass); } 
		}
    }

    control {
        execute(TC_Sem_220304_getreply_operation_001(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.4, Verify that any from getreply matches if at least one port contains enqueued reply
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// To getreply on any port from a specific port array,  use the any from PortArrayRef syntax where 
// PortArrayRef shall be a reference to a  port array identifier.
// The first port which matches all the criteria will cause the operation to be successful even if 
// other ports in the array would also meet the criteria.
module Sem_220304_getreply_operation_002 {
	signature S();
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].reply(S:{}) };
		}
	}
	
    testcase TC_Sem_220304_getreply_operation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{}, nowait);
		}		
		v_ptc.start(f());
		v_ptc.done;	
		alt
		{
        	[] any from p.getreply { setverdict(pass); }
			[else] { setverdict(fail, "The any from getreply operation didn't match for some reason"); } 
		}	
    }

    control {
        execute(TC_Sem_220304_getreply_operation_002(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.4, @decoded redirect parameter assignment of a universal charstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a reply, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220304_getreply_operation_013 {
	signature S(out universal charstring p_par);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var integer v_src := 1953719668 with { encode "32bit" };
        var universal charstring v_str := encvalue_unichar(v_src);
        p.getcall(S:?);
        p.reply(S:{ p_par := v_str });
    }
	
    testcase TC_Sem_220304_getreply_operation_013() runs on GeneralComp system GeneralComp {
        var integer v_res with { encode "32bit" };        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ p_par := - }) {
            [] p.getreply(S:?) -> param (v_res := p_par) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getreply { setverdict(fail); }
        }
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220304_getreply_operation_013(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.4, Verify that any from getreply doesn't change index variable when no there's no suitable match
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// It is also possible to store the index of a port in a single-dimensional port array at which 
// the operation was successful to a variable of type integer or, in case of multi-dimensional 
// port arrays the index of the successful port to an integer array or record of integer variable.
module Sem_220304_getreply_operation_004 {

    signature S(out integer p_par);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].reply(S:{ p_par := i + 100 }) };
		}
	}
	
    testcase TC_Sem_220304_getreply_operation_004() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_index := 99;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{ p_par := - }, nowait);
		}
		v_ptc.start(f());
		v_ptc.done;	
        alt
		{
        	[] any from p.getreply(S:{p_par := (1..10)}) -> @index v_index { 
				setverdict(fail, "The any from getreply operation produced incorrect match"); 
			}
			[else] { setverdict(pass); } 
		}	
        if(v_index == 99){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
	}

    control {
        execute(TC_Sem_220304_getreply_operation_004(), 5000.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.4, @decoded redirect value assignment of a bitstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a reply, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220304_getreply_operation_015 {
	type record R {
        integer id,
        bitstring payload
    }
    
    signature S() return R;
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var charstring v_src := "abc";
        var R v_rec := { id := 1, payload := encvalue(v_src) };
        p.getcall(S:?);
        p.reply(S:{} value v_rec);
        log("dada");
    }
	
    testcase TC_Sem_220304_getreply_operation_015() runs on GeneralComp system GeneralComp {
        var charstring v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{}) {
            [] p.getreply(S:?) -> value (v_res := payload) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getreply { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220304_getreply_operation_015(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.4, @decoded redirect parameter assignment of a charstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a reply, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220304_getreply_operation_012 {
	signature S(out charstring p_par);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var integer v_src := 1953719668 with { encode "32bit" };
        var charstring v_str := encvalue_unichar(v_src);
        p.getcall(S:?);
        p.reply(S:{ p_par := v_str })
    }
	
    testcase TC_Sem_220304_getreply_operation_012() runs on GeneralComp system GeneralComp {
        var integer v_res with { encode "32bit" };        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ p_par := - }) {
            [] p.getreply(S:?) -> param (v_res := p_par) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getreply { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220304_getreply_operation_012(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.4, @decoded redirect parameter assignment of an octetstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a reply, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220304_getreply_operation_011 {
	signature S(out octetstring p_par);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var charstring v_src := "abc";        
        var octetstring v_os := bit2oct(encvalue(v_src));
        p.getcall(S:?);
        p.reply(S:{ p_par := v_os });
    }
	
    testcase TC_Sem_220304_getreply_operation_011() runs on GeneralComp system GeneralComp {
        var charstring v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ p_par := - }) {
            [] p.getreply(S:?) -> param (v_res := p_par) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getreply { setverdict(fail); }

        }
    }

    control {
        execute(TC_Sem_220304_getreply_operation_011(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.4, Verify any from getreply index redirection to fuzzy variable
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction i
// If a variable referenced in the @index clause is a lazy or fuzzy variable, the expression 
// assigned to this variable is equal to the result produced by the getreply operation. Later 
// evaluation of the lazy or fuzzy variable does not lead to repeated invocation of the
// getreply operation.
module Sem_220304_getreply_operation_008 {

    signature S();
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].reply(S:{}) };
		}
	}
    testcase TC_Sem_220304_getreply_operation_008() runs on GeneralComp system GeneralComp {
		var @fuzzy integer v_index;
		var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{}, nowait);
		}
		v_ptc.start(f());
		v_ptc.done;	
        alt
		{
        	[] any from p.getreply(S:?) -> @index v_index { 
				if(v_index == 1){  // no getreply call during evaluation, v_index remains equal to 1
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index or parameter value incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from getreply operation didn't match for some reason");  } 
		}	
    }

    control {
        execute(TC_Sem_220304_getreply_operation_008(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.4, Verify any from getreply index redirection to lazy variable
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction i
// If a variable referenced in the @index clause is a lazy or fuzzy variable, the expression 
// assigned to this variable is equal to the result produced by the getreply operation. Later 
// evaluation of the lazy or fuzzy variable does not lead to repeated invocation of the
// getreply operation.
module Sem_220304_getreply_operation_007 {

    signature S();
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].reply(S:{}) };
		}
	}
    testcase TC_Sem_220304_getreply_operation_007() runs on GeneralComp system GeneralComp {
		var @lazy integer v_index;
		var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{}, nowait);
		}
		v_ptc.start(f());
		v_ptc.done;	
        alt
		{
        	[] any from p.getreply(S:?) -> @index v_index { 
				if(v_index == 1){  // no getreply call during evaluation, v_index remains equal to 1
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index or parameter value incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from getreply operation didn't match for some reason");  } 
		}
    }

    control {
        execute(TC_Sem_220304_getreply_operation_007(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.4, @decoded redirect parameter assignment of a bitstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a reply, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220304_getreply_operation_009 {
	signature S(out bitstring p_par);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var charstring v_src := "abc";
        var bitstring v_bs := encvalue(v_src);
        p.getcall(S:?);
        p.reply(S:{ p_par := v_bs });     
    }
	
    testcase TC_Sem_220304_getreply_operation_009() runs on GeneralComp system GeneralComp {
        var charstring v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ p_par := - }) {
            [] p.getreply(S:?) -> param (v_res := p_par) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getreply { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220304_getreply_operation_009(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.4, @decoded redirect value assignment of a charstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a reply, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220304_getreply_operation_018 {
	type record R {
        integer id,
        charstring payload
    }
    
    signature S() return R;
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var integer v_src := 1953719668 with { encode "32bit" };
        var R v_rec := { id := 4, payload := encvalue_unichar(v_src) };
        p.getcall(S:?);
        p.reply(S:{} value v_rec)
    }
	
    testcase TC_Sem_220304_getreply_operation_018() runs on GeneralComp system GeneralComp {
        var integer v_res with { encode "32bit" };        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{}) {
            [] p.getreply(S:?) -> value (v_res := payload) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getreply { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220304_getreply_operation_018(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.4, Verify that any from done assigns index
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// It is also possible to store the index of a port in a single-dimensional port array at which 
// the operation was successful to a variable of type integer or, in case of multi-dimensional 
// port arrays the index of the successful port to an integer array or record of integer variable.
// When checking the port array for matching replies, the port indices to be checked are iterated 
// from lowest to highest.
module Sem_220304_getreply_operation_005 {

    signature S() return integer;
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].reply(S:{} value i + 1) };
		}
	}
	
    testcase TC_Sem_220304_getreply_operation_005() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_index, v_res;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{}, nowait);
		}
		v_ptc.start(f());
		v_ptc.done;	
        alt
		{
        	[] any from p.getreply(S:? value (0..c_portCount)) -> value v_res @index v_index { 
				if(v_index == 1 and v_res == v_index + 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index or parameter value incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from getreply operation didn't match for some reason");  } 
		}
	}

    control {
        execute(TC_Sem_220304_getreply_operation_005(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Ensure that the getcall operation can be correctly restricted to a certain client 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220302_GetcallOperation_004 {

    type charstring address;
    const address c_client1Addr := "client1Addr";
    const address c_client2Addr := "client2Addr";

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220302_GetcallOperation_004(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;


    template p_Sem_220302_GetcallOperation_004 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220302_GetcallOperation_004 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220302_GetcallOperation_004 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220302_GetcallOperation_004;
    }

    type component GeneralComp {
        port remotePort PCO;
        var GeneralComp v_myAddress;
    }

    function f_ClientQuery(GeneralComp p_myAddress) runs on GeneralComp {
        var integer v_zero:=0;
        var integer v_one:=1;
        var boolean first:=true;
		v_myAddress := p_myAddress;
	
        PCO.call(p_Sem_220302_GetcallOperation_004:s_callTemplate, 3.0) {
	
            [first] PCO.getreply(p_Sem_220302_GetcallOperation_004:s_returnTemplate value 1) {
                first:=false;
                setverdict(fail);  //receiving a reply is not expected for client2 query
            }
            [] PCO.catch (timeout) {
                setverdict(pass);
            }
        }
    }

    function f_ServerResponses(GeneralComp p_clientAddress) runs on GeneralComp {
        var GeneralComp v_clientAddress;	
        var integer v_par1;
        var integer v_par3;
        timer t_timeout:=30.0;
		
        template p_Sem_220302_GetcallOperation_004 s_acceptTemplate := {
            p_par1 := ?,
            p_par2 := ?,
            p_par3 := ?
        };

		
        t_timeout.start;
	
     alt {
      [] PCO.getcall(p_Sem_220302_GetcallOperation_004:s_acceptTemplate) from p_clientAddress -> param(v_par1, - , v_par3) sender v_clientAddress {
          PCO.reply(p_Sem_220302_GetcallOperation_004:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1) to v_clientAddress;  	//procedure return values are sent
		  repeat;
	  }
      [] t_timeout.timeout {
        setverdict(fail);
      }
     }
        
    }

	
    function f_setAddress(GeneralComp p_myAddress) runs on GeneralComp {
        v_myAddress := p_myAddress;
    }
	
    testcase TC_Sem_220302_GetcallOperation_004() runs on GeneralComp system GeneralComp {
        var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
        var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
        var GeneralComp client2 := GeneralComp.create("RemoteProcedure Client");
        // map the PTCs to the system port
        connect(server:PCO, client:PCO);
        connect(server:PCO, client2:PCO);

       server.start(f_ServerResponses(client));
       client.start(f_setAddress(client));
       client2.start(f_ClientQuery(client));

        interleave {
            [] client.done {}
            [] client2.done {}
        }
        server.stop;

        all component.done;

        disconnect(server:PCO);
    }

    control{
        execute(TC_Sem_220302_GetcallOperation_004());
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Ensure that getcall operations remove the matching procedure from the queue  
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220302_GetcallOperation_002 {

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220302_GetcallOperation_002(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Sem_220302_GetcallOperation_002 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220302_GetcallOperation_002 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220302_GetcallOperation_002 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220302_GetcallOperation_002;
    }

    type component GeneralComp {
        port remotePort PCO;
    }

    function f_ClientQuery() runs on GeneralComp {
        var integer v_zero:=0;
        var integer v_one:=1;
	
        PCO.call(p_Sem_220302_GetcallOperation_002:s_callTemplate, 5.0) {
	
            [] PCO.getreply(p_Sem_220302_GetcallOperation_002:s_wrongTemplate value 1) {
                setverdict(fail);
            }
            [] PCO.getreply(p_Sem_220302_GetcallOperation_002:s_returnTemplate value 2) {
                setverdict(fail);
            }
            [v_one>v_zero] PCO.getreply(p_Sem_220302_GetcallOperation_002:s_returnTemplate value 1) {		//check that boolean guard is correctly evaluated
                setverdict(pass);
            }
            [] PCO.catch (timeout) {
                setverdict(fail);
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
	
        var integer v_par1;
        var integer v_par3;
        timer t_timeout:=30.0;

        template p_Sem_220302_GetcallOperation_002 s_noacceptTemplate := {
            p_par1 := 8,
            p_par2 := 8,
            p_par3 := 8
        };
		
        template p_Sem_220302_GetcallOperation_002 s_acceptTemplate := {
            p_par1 := ?,
            p_par2 := ?,
            p_par3 := ?
        };

			
        t_timeout.start;
	
        alt {
            [] PCO.getcall(p_Sem_220302_GetcallOperation_002:s_acceptTemplate) -> param(v_par1, - , v_par3) {
                PCO.reply(p_Sem_220302_GetcallOperation_002:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1);  	//procedure return values are sent
                repeat;
            }
            [] PCO.getcall {   //this part is not matched if procedure is removed from queue
                setverdict(fail);
            }
            [] t_timeout.timeout {
            }
        }
	 
    }

	
    testcase TC_Sem_220302_GetcallOperation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
        var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
        timer t_wait:=1.0;
       
        // map the PTCs to the system port
        connect(server:PCO, client:PCO);

        server.start(f_ServerResponses());
        client.start(f_ClientQuery());

        alt {
            [] client.done {
                t_wait.start;
                t_wait.timeout;	//this gives a chance for server to still test for second getcall match
                server.stop;
            }
        }

        alt {
            [] all component.done {}
        }

        disconnect(server:PCO);
    }

    control{
        execute(TC_Sem_220302_GetcallOperation_002());
    }

}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Verify that any from getcall is not triggered if there hasn't been any call
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// To getcall on any port from a specific port array,  use the any from PortArrayRef syntax where 
// PortArrayRef shall be a reference to a  port array identifier.
// The first port which matches all the criteria will cause the operation to be successful even if 
// other ports in the array would also meet the criteria.
module Sem_220302_getcall_operation_006 {
	signature S();
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
        alt
		{
        	[] any from p.getcall { setverdict(fail, "The any from getcall operation produced incorrect match"); }
			[else] { setverdict(pass); } 
		}		
	}
	
	testcase TC_Sem_220302_getcall_operation_006() runs on GeneralComp system GeneralComp {		
        var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
		}
		v_ptc.start(f());
		v_ptc.done;		
    }

    control {
        execute(TC_Sem_220302_getcall_operation_006(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Verify that any from getcall matches if at least one port contains enqueued call
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// To getcall on any port from a specific port array,  use the any from PortArrayRef syntax where 
// PortArrayRef shall be a reference to a  port array identifier.
// The first port which matches all the criteria will cause the operation to be successful even if 
// other ports in the array would also meet the criteria.
module Sem_220302_getcall_operation_007 {
	signature S();
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
        alt
		{
        	[] any from p.getcall { setverdict(pass); }
			[else] { setverdict(fail, "The any from getcall operation didn't match for some reason"); } 
		}		
	}
	
    testcase TC_Sem_220302_getcall_operation_007() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
		}
		p[1].call(S:{}, nowait);
		v_ptc.start(f());
		v_ptc.done;	
    }

    control {
        execute(TC_Sem_220302_getcall_operation_007(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Verify that any from getcall index redirection works for multidimensional arrays
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction j:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module Sem_220302_getcall_operation_011 {

	signature S(integer p_par);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 3;
    type component GeneralComp 
	{
		port P p[c_portCount][c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		var integer v_index[2], v_parValue;
		var GeneralComp v_src;
        alt
		{
        	[] any from p.getcall(S:{p_par := (0..c_portCount)}) -> param (v_parValue := p_par) sender v_src @index v_index { 
				if(v_index[0] == 1 and v_index[1] == 2 and v_parValue == v_index[0] + 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Indices or parameter value incorrectly assigned");
		        }				
			}
			[else] { setverdict(fail, "The any from getcall operation didn't match for some reason");  } 
		}
	}
	
    testcase TC_Sem_220302_getcall_operation_011() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				connect(self:p[i][j], v_ptc:p[i][j]);
				if (i == 1 and j == 2 or i == 2 and j == 1) { p[i][j].call(S:{ p_par := i + 1 }, nowait); }
			}
		}
		v_ptc.start(f());
		v_ptc.done;	
    }

    control {
        execute(TC_Sem_220302_getcall_operation_011(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Ensure that getcall operations remove only matching procedure from the queue  
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220302_GetcallOperation_001 {

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220302_GetcallOperation_001(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Sem_220302_GetcallOperation_001 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220302_GetcallOperation_001 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220302_GetcallOperation_001 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220302_GetcallOperation_001;
    }

    type component GeneralComp {
        port remotePort PCO;
    }

    function f_ClientQuery() runs on GeneralComp {
	
        PCO.call(p_Sem_220302_GetcallOperation_001:s_callTemplate, 5.0) {
	
            [] PCO.getreply(p_Sem_220302_GetcallOperation_001:s_wrongTemplate value 1) {
                setverdict(fail);
            }
            [] PCO.getreply(p_Sem_220302_GetcallOperation_001:s_returnTemplate value 2) {
                setverdict(fail);
            }
            [] PCO.getreply(p_Sem_220302_GetcallOperation_001:s_returnTemplate value 1) {		//check that boolean guard is correctly evaluated
                setverdict(pass);
            }
            [] PCO.catch (timeout) {
                setverdict(fail);
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
	
	var integer v_par1;
	var integer v_par3;
	timer t_timeout:=30.0;

	template p_Sem_220302_GetcallOperation_001 s_noacceptTemplate := {
        p_par1 := 8,
        p_par2 := 8,
        p_par3 := 8
    };
		
	template p_Sem_220302_GetcallOperation_001 s_acceptTemplate := {
        p_par1 := ?,
        p_par2 := ?,
        p_par3 := ?
    };

		
	t_timeout.start;
	
	 alt {
      [] PCO.getcall(p_Sem_220302_GetcallOperation_001:s_noacceptTemplate) { //should not remove incoming procedure
        repeat;
      }
      [] PCO.getcall(p_Sem_220302_GetcallOperation_001:s_acceptTemplate) -> param(v_par1, - , v_par3) {
        PCO.reply(p_Sem_220302_GetcallOperation_001:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1);  	//procedure return values are sent
      }
      [] t_timeout.timeout {
       setverdict(fail);
      }
	 }
	 
    }

	
	testcase TC_Sem_220302_GetcallOperation_001() runs on GeneralComp system GeneralComp {
       var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
       var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
       // map the PTCs to the system port
       connect(server:PCO, client:PCO);

       server.start(f_ServerResponses());
       client.start(f_ClientQuery());

       alt {
           [] client.done {
               server.stop;
           }
       }

       alt {
           [] all component.done {}
       }

       disconnect(server:PCO);
   }

    control{
        execute(TC_Sem_220302_GetcallOperation_001());
    }

}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Verify that any from getcall doesn't change index variable when no there's no suitable match
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// It is also possible to store the index of a port in a single-dimensional port array at which 
// the operation was successful to a variable of type integer or, in case of multi-dimensional 
// port arrays the index of the successful port to an integer array or record of integer variable.
module Sem_220302_getcall_operation_009 {

    signature S(integer p_par);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		var integer v_index := 99;
		var GeneralComp v_src;
        alt
		{
        	[] any from p.getcall(S:{p_par := (1..10)}) -> sender v_src @index v_index { 
				setverdict(fail, "The any from getcall operation produced incorrect match"); 
			}
			[else] { setverdict(pass); } 
		}
        if(v_index == 99){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
	}
	
    testcase TC_Sem_220302_getcall_operation_009() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			if (i mod 2 > 0) { p[i].call(S:{ p_par := i + 100 }, nowait); }
		}
		v_ptc.start(f());
		v_ptc.done;	
    }

    control {
        execute(TC_Sem_220302_getcall_operation_009(), 5000.0);
    }
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Ensure that getcall operations work with any port attribute  
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220302_GetcallOperation_005 {

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220302_GetcallOperation_005(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Sem_220302_GetcallOperation_005 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220302_GetcallOperation_005 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220302_GetcallOperation_005 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220302_GetcallOperation_005;
    }

    type component GeneralComp {
        port remotePort PCO;
    }

    function f_ClientQuery() runs on GeneralComp {
	
        PCO.call(p_Sem_220302_GetcallOperation_005:s_callTemplate, 5.0) {
	
            [] PCO.getreply(p_Sem_220302_GetcallOperation_005:s_wrongTemplate value 1) {
                setverdict(fail);
            }
            [] PCO.getreply(p_Sem_220302_GetcallOperation_005:s_returnTemplate value 2) {
                setverdict(fail);
            }
            [] PCO.getreply(p_Sem_220302_GetcallOperation_005:s_returnTemplate value 1) {		//check that boolean guard is correctly evaluated
                setverdict(pass);
            }
            [] PCO.catch (timeout) {
                setverdict(fail);
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
	
	var integer v_par1;
	var integer v_par3;
	timer t_timeout:=30.0;

	template p_Sem_220302_GetcallOperation_005 s_acceptTemplate := {
        p_par1 := ?,
        p_par2 := ?,
        p_par3 := ?
    };

		
	t_timeout.start;
	
	 alt {
      [] any port.getcall(p_Sem_220302_GetcallOperation_005:s_acceptTemplate) -> param(v_par1, - , v_par3) {	//validates getcall on any port
        PCO.reply(p_Sem_220302_GetcallOperation_005:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1);  	
      }
      [] t_timeout.timeout {
       setverdict(fail);
      }
	 }
	 
    }

	
	testcase TC_Sem_220302_GetcallOperation_005() runs on GeneralComp system GeneralComp {
       var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
       var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
       // map the PTCs to the system port
       connect(server:PCO, client:PCO);

       server.start(f_ServerResponses());
       client.start(f_ClientQuery());

       alt {
           [] client.done {
               server.stop;
           }
       }

       alt {
           [] all component.done {}
       }

       disconnect(server:PCO);
   }

    control{
        execute(TC_Sem_220302_GetcallOperation_005());
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Ensure that the getcall operation can be correctly restricted to a certain client 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220302_GetcallOperation_003 {

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220302_GetcallOperation_003(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;


    template p_Sem_220302_GetcallOperation_003 s_returnTemplate1 := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220302_GetcallOperation_003 s_returnTemplate2 := {
        p_par1 := -,
        p_par2 := 5,
        p_par3 := 6
    }

    template p_Sem_220302_GetcallOperation_003 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220302_GetcallOperation_003 s_callTemplate(in integer i) := {
        p_par1 := i,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220302_GetcallOperation_003;
    }

    type component GeneralComp {
        var GeneralComp v_clientAddress;
        port remotePort PCO;
    }

    function f_ClientQuery(in integer p_i) runs on GeneralComp {
        var boolean first:=true;
	
        PCO.call(p_Sem_220302_GetcallOperation_003:s_callTemplate(p_i), 5.0) {
	
            [first] PCO.getreply(s_returnTemplate1) {
                first:=false;
            }
            [first] PCO.getreply(s_returnTemplate2) {
                first:=false;
            }
            [] PCO.catch (timeout) {
                // done
            }
        }
    }

    function f_ServerResponses(in GeneralComp p_client) runs on GeneralComp {
        var integer v_par1;
        var integer v_par3;
        timer t_timeout:=30.0;
        var boolean client1_received := false;
        var boolean client2_received := false;
		
        template p_Sem_220302_GetcallOperation_003 s_acceptTemplate := {
            p_par1 := ?,
            p_par2 := ?,
            p_par3 := ?
        };

		
        t_timeout.start;
        
	
        alt {
            [not client1_received] PCO.getcall(p_Sem_220302_GetcallOperation_003:s_acceptTemplate) from p_client -> param(v_par1, - , v_par3) sender v_clientAddress {
                PCO.reply(p_Sem_220302_GetcallOperation_003:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1) to v_clientAddress;  	//procedure return values are sent
                setverdict(pass, "p_client got a message");
                client1_received := true;
                if (not client2_received) {
	                repeat;
                }
            }
            [not client2_received] PCO.getcall(p_Sem_220302_GetcallOperation_003:s_acceptTemplate) -> param(v_par1, - , v_par3) sender v_clientAddress {
                PCO.reply(p_Sem_220302_GetcallOperation_003:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1) to v_clientAddress;  	//procedure return values are sent
                // response for other clients
                client2_received := true;
                if (not client1_received) {
	                repeat;
                }
            }
            [] t_timeout.timeout {
                setverdict(fail, "server received not enough messages: client 1 message received ",client1_received, " client 2 message received ",client2_received);
            }
        }
        
    }

    testcase TC_Sem_220302_GetcallOperation_003() runs on GeneralComp system GeneralComp {
        var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
        var GeneralComp client := GeneralComp.create("RemoteProcedure Client 1");
        var GeneralComp client2 := GeneralComp.create("RemoteProcedure Client 2");
        // map the PTCs to the system port
        connect(server:PCO, client:PCO);
        connect(server:PCO, client2:PCO);

        server.start(f_ServerResponses(client));
        client.start(f_ClientQuery(1));
        client2.start(f_ClientQuery(2));

        client.done;
        client2.done;
        server.stop;

        disconnect(server:PCO);
    }

    control{
        execute(TC_Sem_220302_GetcallOperation_003(), 5.0);
    }

}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.2, @decoded redirect assignment with encoding parameter
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// In case the referenced field is of the universal charstring type, the @decoded 
// clause can contain an optional parameter defining the encoding format. The 
// parameter shall be of the charstring type and it shall contain one of the 
// strings allowed for the decvalue_unichar function (specified in clause C.5.4).

module Sem_220302_getcall_operation_019 {
	signature S(universal charstring p_par);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var integer v_res with { encode "32bit" };        
        alt {
            [] p.getcall(S:?) -> param (v_res := p_par) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getcall { setverdict(fail); }
        }        
    }
	
    testcase TC_Sem_220302_getcall_operation_019() runs on GeneralComp system GeneralComp {
        var integer v_src := 1953719668 with { encode "32bit" };
        var universal charstring v_str := encvalue_unichar(v_src, "UTF-16LE");
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ p_par := v_str }, nowait);
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220302_getcall_operation_019(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Verify any from getcall index redirection to lazy variable
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction k
// If a variable referenced in the @index clause is a lazy or fuzzy variable, the expression 
// assigned to this variable is equal to the result produced by the getcall operation. Later 
// evaluation of the lazy or fuzzy variable does not lead to repeated invocation of the
// getcall operation.
module Sem_220302_getcall_operation_012 {

    signature S(integer p_par);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	function f() runs on GeneralComp
	{
		var @lazy integer v_index;
        alt
		{
        	[] any from p.getcall -> @index v_index { 
				if(v_index == 1){ // no getcall call during evaluation, v_index remains equal to 1
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from getcall didn't match for some reason"); } 
		}
	}
    testcase TC_Sem_220302_getcall_operation_012() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			if (i mod 2 > 0) { p[i].call(S:{ p_par := i + 100 }, nowait); }
		}
		v_ptc.start(f());
		v_ptc.done;	
    }

    control {
        execute(TC_Sem_220302_getcall_operation_012(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.2, @decoded redirect assignment of a bitstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a call, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220302_getcall_operation_014 {
	signature S(bitstring p_par);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var charstring v_res;        
        alt {
            [] p.getcall(S:?) -> param (v_res := p_par) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getcall { setverdict(fail); }
        }        
    }
	
    testcase TC_Sem_220302_getcall_operation_014() runs on GeneralComp system GeneralComp {
        var charstring v_src := "abc";
        var bitstring v_bs := encvalue(v_src);
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ p_par := v_bs }, nowait);
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220302_getcall_operation_014(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Verify that any from getcall doesn't assign index when there's no suitable match
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// It is also possible to store the index of a port in a single-dimensional port array at which 
// the operation was successful to a variable of type integer or, in case of multi-dimensional 
// port arrays the index of the successful port to an integer array or record of integer variable.
module Sem_220302_getcall_operation_008 {

    signature S(integer p_par);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		var integer v_index;
        alt
		{
        	[] any from p.getcall(S:{p_par := (1..10)}) -> @index v_index { 
				setverdict(fail, "The any from getcall operation produced incorrect match"); 
			}
			[else] { setverdict(pass); } 
		}
		if(not isbound(v_index)){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
	}
    testcase TC_Sem_220302_getcall_operation_008() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			if (i mod 2 > 0) { p[i].call(S:{ p_par := i + 100 }, nowait); }
		}
		v_ptc.start(f());
		v_ptc.done;	
	}

    control {
        execute(TC_Sem_220302_getcall_operation_008(), 5000.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.2, @decoded redirect assignment of a hexstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a call, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220302_getcall_operation_015 {
	signature S(hexstring p_par);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var charstring v_res;        
        alt {
            [] p.getcall(S:?) -> param (v_res := p_par) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getcall { setverdict(fail); }
        }        
    }
	
    testcase TC_Sem_220302_getcall_operation_015() runs on GeneralComp system GeneralComp {
        var charstring v_src := "abc";
        var hexstring v_hs := bit2hex(encvalue(v_src));
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ p_par := v_hs }, nowait);
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220302_getcall_operation_015(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.2, @decoded redirect assignment of a charstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a call, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220302_getcall_operation_017 {
	signature S(charstring p_par);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var integer v_res with { encode "32bit" };        
        alt {
            [] p.getcall(S:?) -> param (v_res := p_par) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getcall { setverdict(fail); }
        }        
    }
	
    testcase TC_Sem_220302_getcall_operation_017() runs on GeneralComp system GeneralComp {
        var integer v_src := 1953719668 with { encode "32bit" };
        var charstring v_str := encvalue_unichar(v_src);
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ p_par := v_str }, nowait);
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220302_getcall_operation_017(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.2, @decoded redirect assignment of an octetstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a call, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220302_getcall_operation_016 {
	signature S(octetstring p_par);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var charstring v_res;        
        alt {
            [] p.getcall(S:?) -> param (v_res := p_par) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getcall { setverdict(fail); }
        }        
    }
	
    testcase TC_Sem_220302_getcall_operation_016() runs on GeneralComp system GeneralComp {
        var charstring v_src := "abc";        
        var octetstring v_os := bit2oct(encvalue(v_src));
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ p_par := v_os }, nowait);
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220302_getcall_operation_016(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.2, @decoded redirect assignment of a universal charstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a call, encoded parameters can be decoded 
// prior to assignment using the @decoded modifier. In this case, the referenced 
// parameter on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220302_getcall_operation_018 {
	signature S(universal charstring p_par);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var integer v_res with { encode "32bit" };        
        alt {
            [] p.getcall(S:?) -> param (v_res := p_par) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.getcall { setverdict(fail); }
        }        
    }
	
    testcase TC_Sem_220302_getcall_operation_018() runs on GeneralComp system GeneralComp {
        var integer v_src := 1953719668 with { encode "32bit" };
        var universal charstring v_str := encvalue_unichar(v_src);
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ p_par := v_str }, nowait);
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220302_getcall_operation_018(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Verify any from getcall index redirection to fuzzy variable
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction k
// If a variable referenced in the @index clause is a lazy or fuzzy variable, the expression 
// assigned to this variable is equal to the result produced by the getcall operation. Later 
// evaluation of the lazy or fuzzy variable does not lead to repeated invocation of the
// getcall operation.
module Sem_220302_getcall_operation_013 {

    signature S(integer p_par);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	function f() runs on GeneralComp
	{
		var @fuzzy integer v_index;
        alt
		{
        	[] any from p.getcall -> @index v_index { 
				if(v_index == 1){ // no getcall call during evaluation, v_index remains equal to 1
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from getcall didn't match for some reason"); } 
		}
	}
    testcase TC_Sem_220302_getcall_operation_013() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			if (i mod 2 > 0) { p[i].call(S:{ p_par := i + 100 }, nowait); }
		}
		v_ptc.start(f());
		v_ptc.done;	
    }

    control {
        execute(TC_Sem_220302_getcall_operation_013(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.2, Verify that any from done assigns index
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// It is also possible to store the index of a port in a single-dimensional port array at which 
// the operation was successful to a variable of type integer or, in case of multi-dimensional 
// port arrays the index of the successful port to an integer array or record of integer variable.
// When checking the port array for matching calls, the port indices to be checked are iterated 
// from lowest to highest.
module Sem_220302_getcall_operation_010 {

    signature S(integer p_par);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		var integer v_index, v_parValue;
        alt
		{
        	[] any from p.getcall(S:{p_par := (0..c_portCount)}) -> param (v_parValue := p_par) @index v_index { 
				if(v_index == 1 and v_parValue == v_index + 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index or parameter value incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from getcall operation didn't match for some reason");  } 
		}
	}
	
    testcase TC_Sem_220302_getcall_operation_010() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			if (i mod 2 > 0) { p[i].call(S:{ p_par := i + 1 }, nowait); }
		}
		v_ptc.start(f());
		v_ptc.done;	
    }

    control {
        execute(TC_Sem_220302_getcall_operation_010(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:22.3.3, Ensure that the IUT correctly handles reply to multiple clients on the same server 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220303_ReplyOperation_001 {

	type charstring address;
	const address c_client1Addr := "client1Addr";
	const address c_client2Addr := "client2Addr";

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220303_ReplyOperation_001(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;


    template p_Sem_220303_ReplyOperation_001 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220303_ReplyOperation_001 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220303_ReplyOperation_001 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220303_ReplyOperation_001;
    }

    type component GeneralComp {
        port remotePort PCO;
        var address v_myAddress;
    }

    function f_ClientQuery(address p_myAddress) runs on GeneralComp {
		v_myAddress := p_myAddress;
	
        PCO.call(p_Sem_220303_ReplyOperation_001:s_callTemplate, 5.0) {
	
            [] PCO.getreply(p_Sem_220303_ReplyOperation_001:s_returnTemplate value 1) {	
                setverdict(pass);
            }
            [] PCO.catch (timeout) {
                setverdict(fail, v_myAddress&" did not receive a response");
            }
        }
    }

    function f_Client2Query(address p_myAddress) runs on GeneralComp {
		timer t_timeout:=5.0;
		v_myAddress := p_myAddress;
		t_timeout.start;
	
        alt {
	
            [] PCO.getreply(p_Sem_220303_ReplyOperation_001:s_returnTemplate value 1) {	
                setverdict(pass);
            }
            [] t_timeout.timeout {
                setverdict(fail, v_myAddress&" did not receive a response");
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
	    var address v_clientAddress;	
		var integer v_par1;
		var integer v_par3;
		timer t_timeout:=30.0;
		
	template p_Sem_220303_ReplyOperation_001 s_acceptTemplate := {
        p_par1 := ?,
        p_par2 := ?,
        p_par3 := ?
    };

		
	t_timeout.start;
	
	 alt {
      [] PCO.getcall(p_Sem_220303_ReplyOperation_001:s_acceptTemplate) -> param(v_par1, - , v_par3) sender v_clientAddress {
        PCO.reply(p_Sem_220303_ReplyOperation_001:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1) to all component;  	//sent to all connected clients
		repeat;
	  }
      [] t_timeout.timeout {
        setverdict(fail);
      }
	 }
	 
    }

		
	testcase TC_Sem_220303_ReplyOperation_001() runs on GeneralComp system GeneralComp {
       var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
       var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
       var GeneralComp client2 := GeneralComp.create("RemoteProcedure Client");
       // map the PTCs to the system port
       connect(server:PCO, client:PCO);
       connect(server:PCO, client2:PCO);

       server.start(f_ServerResponses());
       
       client2.start(f_Client2Query(c_client2Addr));		//query only waiting for reply
       client.start(f_ClientQuery(c_client1Addr));

        interleave {
            [] client.done {}
            [] client2.done {}
        }
        server.stop;


       alt {
           [] all component.done {}
       }

       disconnect(server:PCO);
   }

    control{
        execute(TC_Sem_220303_ReplyOperation_001());
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:22.3.3, Ensure that the IUT correctly handles reply to multiple clients on the same server 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_220303_ReplyOperation_002 {

    type charstring address;
    const address c_client1Addr := "client1Addr";
    const address c_client2Addr := "client2Addr";

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_220303_ReplyOperation_002(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;


    template p_Sem_220303_ReplyOperation_002 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_220303_ReplyOperation_002 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_220303_ReplyOperation_002 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_220303_ReplyOperation_002;
    }

    type component GeneralComp {
        port remotePort PCO;
        var address v_myAddress;
    }

    function f_ClientQuery(address p_myAddress) runs on GeneralComp {
        v_myAddress := p_myAddress;
	
        PCO.call(p_Sem_220303_ReplyOperation_002:s_callTemplate, 5.0) {
	
            [] PCO.getreply(p_Sem_220303_ReplyOperation_002:s_returnTemplate value 1) {
                setverdict(pass);
            }
            [] PCO.catch (timeout) {
                setverdict(fail, v_myAddress&" did not receive a response");
            }
        }
    }

    function f_Client2Query(address p_myAddress) runs on GeneralComp {
        timer t_timeout:=5.0;
        v_myAddress := p_myAddress;
        t_timeout.start;
	
        alt {
	
            [] PCO.getreply(p_Sem_220303_ReplyOperation_002:s_returnTemplate value 1) {
                setverdict(pass);
            }
            [] t_timeout.timeout {
                setverdict(fail, v_myAddress&" did not receive a response");
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
        var address v_clientAddress;
        var integer v_par1;
        var integer v_par3;
        timer t_timeout:=30.0;
		
        template p_Sem_220303_ReplyOperation_002 s_acceptTemplate := {
            p_par1 := ?,
            p_par2 := ?,
            p_par3 := ?
        };

		
        t_timeout.start;
	
        alt {
            [] PCO.getcall(p_Sem_220303_ReplyOperation_002:s_acceptTemplate) -> param(v_par1, - , v_par3) sender v_clientAddress {
                PCO.reply(p_Sem_220303_ReplyOperation_002:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1) to (c_client1Addr,c_client2Addr);  	//sent to both connected clients
                repeat;
            }
            [] t_timeout.timeout {
                setverdict(fail);
            }
        }
	 
    }

		
    testcase TC_Sem_220303_ReplyOperation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
        var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
        var GeneralComp client2 := GeneralComp.create("RemoteProcedure Client");
        // map the PTCs to the system port
        connect(server:PCO, client:PCO);
        connect(server:PCO, client2:PCO);

        server.start(f_ServerResponses());
       
        client2.start(f_Client2Query(c_client2Addr));		//query only waiting for reply
        client.start(f_ClientQuery(c_client1Addr));

        interleave {
            [] client.done {}
            [] client2.done {}
        }
        server.stop;

        alt {
            [] all component.done {}
        }

        disconnect(server:PCO);
    }

    control{
        execute(TC_Sem_220303_ReplyOperation_002());
    }

}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.6, Verify that any from catch matches if at least one port contains enqueued reply
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// To catch an exception on any port from a specific port array, use the any from PortArrayRef syntax 
// where PortArrayRef shall be a reference to a  port array identifier.
// The first port which matches all the criteria will cause the operation to be successful even if 
// other ports in the array would also meet the criteria.
module Sem_220306_catch_operation_002 {
	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].raise(S, 1) };
		}
	}
	
    testcase TC_Sem_220306_catch_operation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{}, nowait);
		}		
		v_ptc.start(f());
		v_ptc.done;	
		alt
		{
        	[] any from p.catch { setverdict(pass); }
			[else] { setverdict(fail, "The any from catch operation didn't match for some reason"); } 
		}	
    }

    control {
        execute(TC_Sem_220306_catch_operation_002(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.6, @decoded redirect value assignment of a charstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of an exception, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220306_catch_operation_012 {
	type record R {
        integer id,
        charstring payload
    }
    
    signature S() exception (R);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var integer v_src := 1953719668 with { encode "32bit" };
        var R v_rec := { id := 4, payload := encvalue_unichar(v_src) };
        p.getcall(S:?);
        p.raise(S, v_rec)
    }
	
    testcase TC_Sem_220306_catch_operation_012() runs on GeneralComp system GeneralComp {
        var integer v_res with { encode "32bit" };        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{}) {
            [] p.catch(S, R:?) -> value (v_res := payload) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.catch { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220306_catch_operation_012(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.6, @decoded redirect value assignment with encoding parameter
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// In case the referenced field is of the universal charstring type, the @decoded 
// clause can contain an optional parameter defining the encoding format. The 
// parameter shall be of the charstring type and it shall contain one of the 
// strings allowed for the decvalue_unichar function (specified in clause C.5.4).

module Sem_220306_catch_operation_014 {
	type record R {
        integer id,
        universal charstring payload
    }
    
    signature S() exception (R);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var integer v_src := 1953719668 with { encode "32bit" };
        var R v_rec := { id := 5, payload := encvalue_unichar(v_src, "UTF-16LE") };
        p.getcall(S:?);
        p.raise(S, v_rec);
    }
	
    testcase TC_Sem_220306_catch_operation_014() runs on GeneralComp system GeneralComp {
        var integer v_res with { encode "32bit" };        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{}) {
            [] p.catch(S, R:?) -> value (v_res := payload) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.catch { setverdict(fail); }
        };
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220306_catch_operation_014(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.6, @decoded redirect value assignment of an octetstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of an exception, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220306_catch_operation_011 {
	type record R {
        integer id,
        octetstring payload
    }
    
    signature S() exception (R);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var charstring v_src := "abc";        
        var R v_rec := { id := 3, payload := bit2oct(encvalue(v_src)) };
        p.getcall(S:?);
        p.raise(S, v_rec);
    }
	
    testcase TC_Sem_220306_catch_operation_011() runs on GeneralComp system GeneralComp {
        var charstring v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{}) {
            [] p.catch(S, R:?) -> value (v_res := payload) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.catch { setverdict(fail); }

        }
    }

    control {
        execute(TC_Sem_220306_catch_operation_011(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.6, Verify that any from catch doesn't assign index when there's no suitable match
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// It is also possible to store the index of a port in a single-dimensional port array at which 
// the operation was successful to a variable of type integer or, in case of multi-dimensional 
// port arrays the index of the successful port to an integer array or record of integer variable.
module Sem_220306_catch_operation_003 {

    signature S() exception(integer);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].raise(S, i + 100) };
		}
	}
	
    testcase TC_Sem_220306_catch_operation_003() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_index;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{}, nowait);
		}
		v_ptc.start(f());
		v_ptc.done;	
        alt
		{
        	[] any from p.catch(S, integer:(1..10)) -> @index v_index { 
				setverdict(fail, "The any from catch operation produced incorrect match"); 
			}
			[else] { setverdict(pass); } 
		}
		if(not isbound(v_index)){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
	}

    control {
        execute(TC_Sem_220306_catch_operation_003(), 5000.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.6, @decoded redirect value assignment of a bitstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of an exception, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220306_catch_operation_009 {
	type record R {
        integer id,
        bitstring payload
    }
    
    signature S() exception (R);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var charstring v_src := "abc";
        var R v_rec := { id := 1, payload := encvalue(v_src) };
        p.getcall(S:?);
        p.raise(S, v_rec);
        log("dada");
    }
	
    testcase TC_Sem_220306_catch_operation_009() runs on GeneralComp system GeneralComp {
        var charstring v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{}) {
            [] p.catch(S, R:?) -> value (v_res := payload) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.catch { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220306_catch_operation_009(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.6, Verify that any from catch is not triggered if there hasn't been any exception
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// To catch an exception on any port from a specific port array, use the any from PortArrayRef syntax 
// where PortArrayRef shall be a reference to a  port array identifier.
// The first port which matches all the criteria will cause the operation to be successful even if 
// other ports in the array would also meet the criteria.
module Sem_220306_catch_operation_001 {
	signature S() exception (integer);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}

	testcase TC_Sem_220306_catch_operation_001() runs on GeneralComp system GeneralComp {		
        var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);			
		}
		alt
		{
        	[] any from p.catch { setverdict(fail, "The any from catch operation produced incorrect match"); }
			[else] { setverdict(pass); } 
		}
    }

    control {
        execute(TC_Sem_220306_catch_operation_001(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.6, Verify that any from catch doesn't change index variable when no there's no suitable match
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// It is also possible to store the index of a port in a single-dimensional port array at which 
// the operation was successful to a variable of type integer or, in case of multi-dimensional 
// port arrays the index of the successful port to an integer array or record of integer variable.
module Sem_220306_catch_operation_004 {

    signature S() exception(integer);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].raise(S, i + 100) };
		}
	}
	
    testcase TC_Sem_220306_catch_operation_004() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_index := 99;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{}, nowait);
		}
		v_ptc.start(f());
		v_ptc.done;	
        alt
		{
        	[] any from p.catch(S, integer:(1..10)) -> @index v_index { 
				setverdict(fail, "The any from catch operation produced incorrect match"); 
			}
			[else] { setverdict(pass); } 
		}	
        if(v_index == 99){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
	}

    control {
        execute(TC_Sem_220306_catch_operation_004(), 5000.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.6, Verify that any from catch index redirection works for multidimensional arrays
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction j:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module Sem_220306_catch_operation_006 {

	signature S() exception(integer);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 3;
    type component GeneralComp 
	{
		port P p[c_portCount][c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				p[i][j].getcall;
				if (i == 1 and j == 2 or i == 2 and j == 1) { p[i][j].raise(S, i + 1 ); }
			}
		}
	}
	
    testcase TC_Sem_220306_catch_operation_006() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create, v_src;
		var integer v_index[2], v_parValue;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			for(var integer j := 0; j < c_portCount; j := j + 1) {
				connect(self:p[i][j], v_ptc:p[i][j]);
				p[i][j].call(S:{}, nowait);
			}
		}
		v_ptc.start(f());
		v_ptc.done;	
        alt
		{
        	[] any from p.catch(S, integer:?) -> sender v_src @index v_index { 
				if(v_index[0] == 1 and v_index[1] == 2){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Indices or parameter value incorrectly assigned");
		        }				
			}
			[else] { setverdict(fail, "The any from catch operation didn't match for some reason");  } 
		}
	}

    control {
        execute(TC_Sem_220306_catch_operation_006(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.6, Verify any from catch index redirection to lazy variable
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction k
// If a variable referenced in the @index clause is a lazy or fuzzy variable, the expression 
// assigned to this variable is equal to the result produced by the catch operation. Later 
// evaluation of the lazy or fuzzy variable does not lead to repeated invocation of the
// catch operation.
module Sem_220306_catch_operation_007 {

    signature S() exception(integer);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].raise(S, i + 1) };
		}
	}
    testcase TC_Sem_220306_catch_operation_007() runs on GeneralComp system GeneralComp {
		var @lazy integer v_index;
		var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{}, nowait);
		}
		v_ptc.start(f());
		v_ptc.done;	
        alt
		{
        	[] any from p.catch(S, integer:?) -> @index v_index { 
				if(v_index == 1){  // no catch call during evaluation, v_index remains equal to 1
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index or parameter value incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from catch operation didn't match for some reason");  } 
		}
    }

    control {
        execute(TC_Sem_220306_catch_operation_007(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.6, Verify any from catch index redirection to fuzzy variable
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction k
// If a variable referenced in the @index clause is a lazy or fuzzy variable, the expression 
// assigned to this variable is equal to the result produced by the catch operation. Later 
// evaluation of the lazy or fuzzy variable does not lead to repeated invocation of the
// catch operation.
module Sem_220306_catch_operation_008 {

    signature S() exception(integer);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].raise(S, i + 1) };
		}
	}
    testcase TC_Sem_220306_catch_operation_008() runs on GeneralComp system GeneralComp {
		var @fuzzy integer v_index;
		var GeneralComp v_ptc := GeneralComp.create;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{}, nowait);
		}
		v_ptc.start(f());
		v_ptc.done;	
        alt
		{
        	[] any from p.catch(S, integer:?) -> @index v_index { 
				if(v_index == 1){  // no catch call during evaluation, v_index remains equal to 1
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index or parameter value incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from catch operation didn't match for some reason");  } 
		}	
    }

    control {
        execute(TC_Sem_220306_catch_operation_008(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.6, @decoded redirect value assignment of a universal charstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of an exception, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220306_catch_operation_013 {
	type record R {
        integer id,
        universal charstring payload
    }
    
    signature S() exception (R);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var integer v_src := 1953719668 with { encode "32bit" };
        var R v_rec := { id := 5, payload := encvalue_unichar(v_src) };
        p.getcall(S:?);
        p.raise(S, v_rec);
    }
	
    testcase TC_Sem_220306_catch_operation_013() runs on GeneralComp system GeneralComp {
        var integer v_res with { encode "32bit" };        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{}) {
            [] p.catch(S, R:?) -> value (v_res := payload) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.catch { setverdict(fail); }
        }
        v_ptc.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220306_catch_operation_013(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.3.6, @decoded redirect value assignment of a hexstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of an exception, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220306_catch_operation_010 {
   	type record R {
        integer id,
        hexstring payload
    }

	signature S() exception (R);
    
	type port P procedure {
		inout S;
	}
	
    type component GeneralComp {
		port P p;
	}
    
    function f_server() runs on GeneralComp {
        var charstring v_src := "abc";
        var R v_rec := { id := 2, payload := bit2hex(encvalue(v_src)) };
        p.getcall(S:?);
        p.raise(S, v_rec);
    }
	
    testcase TC_Sem_220306_catch_operation_010() runs on GeneralComp system GeneralComp {
        var charstring v_res;        
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        connect(self:p, v_ptc:p);
        v_ptc.start(f_server());
        p.call(S:{ }) {
            [] p.catch(S, R:?) -> value (v_res := payload) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.catch { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220306_catch_operation_010(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:22.3.6, Verify that any from done assigns index
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// It is also possible to store the index of a port in a single-dimensional port array at which 
// the operation was successful to a variable of type integer or, in case of multi-dimensional 
// port arrays the index of the successful port to an integer array or record of integer variable.
// When checking the port array for matching exceptions, the port indices to be checked are iterated 
// from lowest to highest.
module Sem_220306_catch_operation_005 {

    signature S() exception(integer);
	
	type port P procedure {
		inout S;
	}
	
	const integer c_portCount := 4;
    type component GeneralComp 
	{
		port P p[c_portCount];
	}
	
	function f() runs on GeneralComp
	{
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			p[i].getcall;
			if (i mod 2 == 1) { p[i].raise(S, i + 1); };
		}
	}
	
    testcase TC_Sem_220306_catch_operation_005() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc := GeneralComp.create;
		var integer v_index, v_res;
		for(var integer i := 0; i < c_portCount; i := i + 1) {
			connect(self:p[i], v_ptc:p[i]);
			p[i].call(S:{}, nowait);
		}
		v_ptc.start(f());
		v_ptc.done;	
        alt
		{
        	[] any from p.catch(S, integer:(0..c_portCount)) -> value v_res @index v_index { 
				if(v_index == 1 and v_res == v_index + 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index or parameter value incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from catch operation didn't match for some reason");  } 
		}
	}

    control {
        execute(TC_Sem_220306_catch_operation_005(), 5.0);
    }
}/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:22.2.1, Ensure that the IUT correctly handles message sending operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_220201_SendOperation_001 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_220201_SendOperation_001() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

 template MessageType mw_sendingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

 messagePort.send(mw_sendingTemplate);  //can send also template with specific values

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_220201_SendOperation_001());
}

}
/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:22.2.1, Ensure that the IUT correctly handles message sending operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_220201_SendOperation_003 { 

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 
	
	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

    type port loopbackPort message {
	  inout RecordType, SetType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_220201_SendOperation_003() runs on GeneralComp {


 messagePort.send(RecordType:{1,2,true});  //can send also in-line template

    alt {
     [] messagePort.receive(RecordType:{1,2,true}) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_220201_SendOperation_003());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.1, unicast send operation
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Unicast communication is specified, if the to clause addresses one communication partner 
// only.

module Sem_220201_SendOperation_005 {
	
	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f(integer p_expected) runs on GeneralComp
	{
        alt {
            [] p.receive(p_expected) { setverdict(pass); }
            [] p.receive { setverdict(fail); }
        }
	}
    
    const integer c_ptcCount := 2;
	
    testcase TC_Sem_220201_SendOperation_005() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptcs[c_ptcCount];
        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            v_ptcs[i] := GeneralComp.create;
            connect(self:p, v_ptcs[i]:p);
            v_ptcs[i].start(f(i));
        }
		p.send(0) to v_ptcs[0];
        p.send(1) to v_ptcs[1];
        all component.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220201_SendOperation_005(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.1, multicast send operation
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Multicast communication is used, if the to clause includes a list of communication 
// partners.

module Sem_220201_SendOperation_006 {
    
	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f(integer p_expected) runs on GeneralComp
	{
        alt {
            [] p.receive(p_expected) { setverdict(pass); }
            [] p.receive { setverdict(fail); }
        }
	}
    
    const integer c_ptcCount := 4;
	
    testcase TC_Sem_220201_SendOperation_006() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptcs[c_ptcCount];
        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            v_ptcs[i] := GeneralComp.create;
            connect(self:p, v_ptcs[i]:p);
            v_ptcs[i].start(f(i mod 2));
        }
		p.send(0) to (v_ptcs[0], v_ptcs[2]);
        p.send(1) to (v_ptcs[1], v_ptcs[3]);
        all component.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220201_SendOperation_006(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.1, broadcast send operation
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Broadcast is defined by using the to clause with all component keyword.

module Sem_220201_SendOperation_007 {
	
	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f(integer p_expected) runs on GeneralComp
	{
        alt {
            [] p.receive(p_expected) { setverdict(pass); }
            [] p.receive { setverdict(fail); }
        }
	}
    
    const integer c_ptcCount := 3;
	
    testcase TC_Sem_220201_SendOperation_007() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptcs[c_ptcCount];
        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            v_ptcs[i] := GeneralComp.create;
            connect(self:p, v_ptcs[i]:p);
            v_ptcs[i].start(f(0));
        }
		p.send(0) to all component;
        all component.done;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_220201_SendOperation_007(), 5.0);
    }
}/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:22.2.1, Ensure that the IUT correctly handles message sending operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_220201_SendOperation_002 { 


    type port loopbackPort message {
	  inout integer
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_220201_SendOperation_002() runs on GeneralComp {


 messagePort.send(2);  //can send also in-line template

    alt {
     [] messagePort.receive(2) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_220201_SendOperation_002());
}

}
/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:22.2.1, Ensure that the IUT correctly handles message sending operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_220201_SendOperation_004 { 


    type port loopbackPort message {
	  inout integer
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_220201_SendOperation_004() runs on GeneralComp {
 var integer v_1:=2, v_2:=3;

 messagePort.send(v_1*v_2+1);  //can send also the results of operations

    alt {
     [] messagePort.receive(7) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_220201_SendOperation_004());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, @decoded redirect assignment with encoding parameter
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// In case the referenced field is of the universal charstring type, the @decoded 
// clause can contain an optional parameter defining the encoding format. The 
// parameter shall be of the charstring type and it shall contain one of the 
// strings allowed for the decvalue_unichar function (specified in clause C.5.4).

module Sem_220203_TriggerOperation_016 {
	type record R
    {
        integer id,
        universal charstring payload
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220203_TriggerOperation_016() runs on GeneralComp {
        var integer v_src := 1953719668, v_res with { encode "32bit" };
        var universal charstring v_str := encvalue_unichar(v_src, "UTF-16LE");
        p.send(R:{ id := 1, payload := v_str });
        alt {
            [] p.trigger(R:?) -> value (v_res := payload) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_016(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, redirect assignment storing a component
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// It is also possible to retrieve and store the component reference or address of 
// the sender of a message. This is denoted by the keyword sender.

module Sem_220203_TriggerOperation_017 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	    
    testcase TC_Sem_220203_TriggerOperation_017() runs on GeneralComp system GeneralComp {
        var GeneralComp v_tc := null;
        connect(self:p, self:p);
        p.send(10);
        p.trigger(integer:?) -> sender v_tc;
        if (v_tc == self) { setverdict(pass); }
        else { setverdict(fail); }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_017(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, trigger with a from clause (multiple items)
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// The matching criteria as defined in clause 22.2.2 apply also to the trigger 
// operation.
// In the case of one-to-many connections the [trigger] operation may be restricted 
// to a certain communication partner. This restriction shall be denoted using the 
// from keyword.

module Sem_220203_TriggerOperation_007 {
	
	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f(integer i) runs on GeneralComp
	{
        p.send(i);
	}
    
    const integer c_ptcCount := 3;
	
    testcase TC_Sem_220203_TriggerOperation_007() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptcs[c_ptcCount];
        var integer v_int;
        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            v_ptcs[i] := GeneralComp.create;
            connect(self:p, v_ptcs[i]:p);
            v_ptcs[i].start(f(i));
        }
        
        alt {
            [] p.trigger(integer:?) from (v_ptcs[c_ptcCount - 2], v_ptcs[c_ptcCount - 1]) -> value v_int { 
                if (v_int == c_ptcCount - 2) { setverdict(pass); } 
                else { setverdict(fail) };
            }
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_007(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, @decoded redirect assignment of a universal charstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// When assigning individual fields of a message, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220203_TriggerOperation_015 {
	type record R
    {
        integer id,
        universal charstring payload
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220203_TriggerOperation_015() runs on GeneralComp {
        var integer v_src := 1953719668, v_res with { encode "32bit" };
        var universal charstring v_str := encvalue_unichar(v_src);
        p.send(R:{ id := 1, payload := v_str });
        alt {
            [] p.trigger(R:?) -> value (v_res := payload) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_015(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, redirect assignment of message fields
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// When the keyword value is followed by an assignment list enframed by a pair of 
// parentheses, the whole received message and/or one or more parts of it can be 
// stored. In a single assignment within the list, on the right hand side of the 
// assignment symbol (":=") a field of the template type shall be referenced, on 
// the left hand side the name of the variable or a formal parameter, in which 
// the value shall be stored.

module Sem_220203_TriggerOperation_009 {
	type record R
    {
        integer field1[2],
        charstring field2
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220203_TriggerOperation_009() runs on GeneralComp {
        var integer v_int;
        var charstring v_str;
        p.send(R:{ field1 := { 1, 2 }, field2 := "abc" });
        alt {
            [] p.trigger(R:?) -> value ( v_int := field1[1], v_str := field2) { 
                if (v_int == 2 and v_str == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_009(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, fuzzy variable in @index redirect 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// If a variable referenced in the value, sender or @index clause is a lazy or fuzzy 
// variable, the expression assigned to this variable is equal to the result produced 
// by the trigger operation i.e. later evaluation of the lazy or fuzzy variable does not 
// lead to repeated invocation of the trigger operation.

module Sem_220203_TriggerOperation_028 {
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p[2];
	}
	    
    testcase TC_Sem_220203_TriggerOperation_028() runs on GeneralComp {
        var @fuzzy integer v_int;
        p[1].send(1);
        p[1].send(2);
        p[1].send(3);
        any from p.trigger(integer:?) -> @index v_int;
        if (v_int == 1) { // evaluation of @lazy (receive shall not be called again)
            alt {
                [] p[1].receive(integer:2) { setverdict(pass); }
                [] any from p.receive { setverdict(fail); }
            }
        } else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_028(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, any from port.trigger statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// To trigger on a message at any port from a specific port array, use the any from 
// PortArrayRef syntax where PortArrayRef shall be a reference to a  port array 
// identifier.

module Sem_220203_TriggerOperation_019 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p [3];
        port P altP;
	}
	    
    testcase TC_Sem_220203_TriggerOperation_019() runs on GeneralComp {
        p[2].send(10);
        altP.send(1);
        alt {
            [] any from p.trigger(integer:?) { setverdict(pass); }
            [] any port.receive { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_019(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, @decoded redirect assignment of a bitstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// When assigning individual fields of a message, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220203_TriggerOperation_011 {
	type record R
    {
        integer id,
        bitstring payload
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220203_TriggerOperation_011() runs on GeneralComp {
        var charstring v_src := "abc", v_res;        
        var bitstring v_bs := encvalue(v_src);
        p.send(R:{ id := 1, payload := v_bs });
        alt {
            [] p.trigger(R:?) -> value (v_res := payload) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_011(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, multidimensional index redirect in any from port.trigger statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// It is also possible to store the index of a port in a single-dimensional port array 
// at which the operation was successful to a variable of type integer or, in case of 
// multi-dimensional port arrays the index of the successful port to an integer array 
// or record of integer variable. When checking the port array for matching messages, 
// the port indices to be checked are iterated from lowest to highest. If the port 
// array is multi-dimensional, then the ports are iterated over from innermost to 
// outermost array dimension from lowest to highest index for each dimension, e.g. 
// [0][0], [0][1], [1][0], [1][1]. The first port which matches all the criteria will 
// cause the operation to be successful even if other ports in the array would also 
// meet the criteria.

module Sem_220203_TriggerOperation_021 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p [2][3];
        port P altP;
	}
    
    type record of integer RoI;
	    
    testcase TC_Sem_220203_TriggerOperation_021() runs on GeneralComp {
        var RoI v_index;
        p[0][2].send(10);
        altP.send(1);
        alt {
            [] any from p.trigger(integer:?) -> @index v_index { 
                if (v_index == { 0, 2 }) { setverdict(pass); }
                else { setverdict(fail, "v_index: ", v_index); }
            }
            [] any port.receive { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_021(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, trigger with a from clause (any component)
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// The matching criteria as defined in clause 22.2.2 apply also to the trigger 
// operation.
// In the case of one-to-many connections the [trigger] operation may be restricted 
// to a certain communication partner. This restriction shall be denoted using the 
// from keyword.

module Sem_220203_TriggerOperation_008 {
	
	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
        p.send(1);
	}
    
    const integer c_ptcCount := 3;
	
    testcase TC_Sem_220203_TriggerOperation_008() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptcs[c_ptcCount];
        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            v_ptcs[i] := GeneralComp.create;
            connect(self:p, v_ptcs[i]:p);
            v_ptcs[i].start(f());
        }
        
        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            alt {
                [] p.trigger(integer:?) from any component { setverdict(pass); }
            }
        }        
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_008(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, fuzzy variable in value redirect 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// If a variable referenced in the value, sender or @index clause is a lazy or fuzzy 
// variable, the expression assigned to this variable is equal to the result produced 
// by the trigger operation i.e. later evaluation of the lazy or fuzzy variable does not 
// lead to repeated invocation of the trigger operation.

module Sem_220203_TriggerOperation_026 {
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_Sem_220203_TriggerOperation_026() runs on GeneralComp {
        var @fuzzy integer v_int;
        p.send(1);
        p.send(2);
        p.send(3);
        p.trigger(integer:?) -> value v_int;
        if (v_int == 1) { // evaluation of @lazy (receive shall not be called again)
            alt {
                [] p.receive(integer:2) { setverdict(pass); }
                [] p.receive { setverdict(fail); }
            }
        } else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_026(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, lazy variable in index redirect 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// If a variable referenced in the value, sender or @index clause is a lazy or fuzzy 
// variable, the expression assigned to this variable is equal to the result produced 
// by the trigger operation i.e. later evaluation of the lazy or fuzzy variable does not 
// lead to repeated invocation of the trigger operation.

module Sem_220203_TriggerOperation_025 {
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p[2];
	}
	    
    testcase TC_Sem_220203_TriggerOperation_025() runs on GeneralComp {
        var @lazy integer v_int;
        p[1].send(1);
        p[1].send(2);
        p[1].send(3);
        any from p.trigger(integer:?) -> @index v_int;
        if (v_int == 1) { // evaluation of @lazy (receive shall not be called again)
            alt {
                [] p[1].receive(integer:2) { setverdict(pass); }
                [] any from p.receive { setverdict(fail); }
            }
        } else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_025(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, @decoded redirect assignment of an octetstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// When assigning individual fields of a message, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220203_TriggerOperation_013 {
	type record R
    {
        integer id,
        octetstring payload
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220203_TriggerOperation_013() runs on GeneralComp {
        var charstring v_src := "abc", v_res;        
        var octetstring v_os := bit2oct(encvalue(v_src));
        p.send(R:{ id := 1, payload := v_os });
        alt {
            [] p.trigger(R:?) -> value (v_res := payload) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_013(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, redirect assignment of message fields
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// As a special case the field reference can be absent to indicate that the whole 
// message shall be stored in a variable.

module Sem_220203_TriggerOperation_010 {
	type record R
    {
        integer field1[2],
        charstring field2
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220203_TriggerOperation_010() runs on GeneralComp {
        var integer v_int;
        var charstring v_str;
        var R v_rec;
        p.send(R:{ field1 := { 1, 2 }, field2 := "abc" });
        alt {
            [] p.trigger(R:?) -> value ( v_int := field1[1], v_rec, v_str := field2) { 
                if (v_int == 2 and v_str == "abc" and v_rec == { field1 := { 1, 2 }, field2 := "abc" }) { setverdict (pass); }
                else { setverdict(fail); }
            }
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_010(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, single dimensional index redirect in any from port.trigger statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// It is also possible to store the index of a port in a single-dimensional port array 
// at which the operation was successful to a variable of type integer or, in case of 
// multi-dimensional port arrays the index of the successful port to an integer array 
// or record of integer variable. When checking the port array for matching messages, 
// the port indices to be checked are iterated from lowest to highest. If the port 
// array is multi-dimensional, then the ports are iterated over from innermost to 
// outermost array dimension from lowest to highest index for each dimension, e.g. 
// [0][0], [0][1], [1][0], [1][1]. The first port which matches all the criteria will 
// cause the operation to be successful even if other ports in the array would also 
// meet the criteria.

module Sem_220203_TriggerOperation_020 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p [3];
        port P altP;
	}
	    
    testcase TC_Sem_220203_TriggerOperation_020() runs on GeneralComp {
        var integer v_index;
        p[2].send(10);
        altP.send(1);
        alt {
            [] any from p.trigger(integer:?) -> @index v_index { 
                if (v_index == 2) { setverdict(pass); }
                else { setverdict(fail); }
            }
            [] any port.receive { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_020(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, @decoded redirect assignment of a hexstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// When assigning individual fields of a message, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220203_TriggerOperation_012 {
	type record R
    {
        integer id,
        hexstring payload
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220203_TriggerOperation_012() runs on GeneralComp {
        var charstring v_src := "abc", v_res;        
        var hexstring v_hs := bit2hex(encvalue(v_src));
        p.send(R:{ id := 1, payload := v_hs });
        alt {
            [] p.trigger(R:?) -> value (v_res := payload) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_012(), 5.0);
    }
}/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:22.2.3, Ensure that the IUT correctly handles message trigger operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_220203_TriggerOperation_003 { 


    type port loopbackPort message {
	  inout integer
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_220203_TriggerOperation_003() runs on GeneralComp {
 var integer v_received:=0;
 timer t_timeout:=5.0;

 messagePort.send(2); 
 t_timeout.start;

    alt {
     [] messagePort.trigger(integer:?) -> value v_received { 
       if(v_received==2) {  //check that correct value has been stored
        setverdict(pass);
       }
       else {
        setverdict(fail);
       }
     }
     [] messagePort.receive {
        setverdict(fail);
     }
     [] t_timeout.timeout {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_220203_TriggerOperation_003());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, fuzzy variable in sender redirect 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// If a variable referenced in the value, sender or @index clause is a lazy or fuzzy 
// variable, the expression assigned to this variable is equal to the result produced 
// by the trigger operation i.e. later evaluation of the lazy or fuzzy variable does not 
// lead to repeated invocation of the trigger operation.

module Sem_220203_TriggerOperation_027 {
    type integer address;
    
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_Sem_220203_TriggerOperation_027() runs on GeneralComp {
        var @fuzzy address v_addr;
        p.send(1) to 1;
        p.send(2) to 2;
        p.send(3) to 3;
        p.trigger(integer:?) -> sender v_addr;
        if (v_addr == 1) { // evaluation of @lazy (receive shall not be called again)
            alt {
                [] p.receive(integer:2) { setverdict(pass); }
                [] p.receive { setverdict(fail); }
            }
        } else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_027(), 5.0);
    }
}/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:22.2.3, Ensure that the IUT correctly handles message trigger operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_220203_TriggerOperation_005 { 


    type port loopbackPort message {
	  inout integer
	}	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_220203_TriggerOperation_005() runs on GeneralComp {
 timer t_timeout:=5.0;

 messagePort.send(2); 
 t_timeout.start;

    alt {
     [] any port.trigger(2) {   //checks trigger from any port
        setverdict(pass);
     }
     [] messagePort.trigger {	//this alt is only selected if message was not removed from the queue
        setverdict(fail);
     }
     [] t_timeout.timeout {
       setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_220203_TriggerOperation_005());
}

}
/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:22.2.3, Ensure that the IUT correctly handles message trigger operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_220203_TriggerOperation_004 { 

    type charstring address;
    
    type port loopbackPort message {
      inout integer
    }
	

type component GeneralComp {	    	    
      port loopbackPort messagePort
}	

    const address c_address := "Tester";

testcase TC_Sem_220203_TriggerOperation_004() runs on GeneralComp {
 var address v_sender;
 timer t_timeout:=5.0;
 

 messagePort.send(2) to c_address; 
 t_timeout.start;

    alt {
     [] messagePort.trigger(2) -> sender v_sender { 
       messagePort.send(5) to v_sender;
       alt {
        [] messagePort.trigger(5) from v_sender {  //check that correct sender address has been assigned
         setverdict(pass);
        }
        [] messagePort.receive {
         setverdict(fail);
        }
        [] t_timeout.timeout {
         setverdict(fail);
        }
       }
     }
     [] messagePort.trigger {
        setverdict(fail);
     }
     [] t_timeout.timeout {
       setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_220203_TriggerOperation_004());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, lazy variable in sender redirect 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// If a variable referenced in the value, sender or @index clause is a lazy or fuzzy 
// variable, the expression assigned to this variable is equal to the result produced 
// by the trigger operation i.e. later evaluation of the lazy or fuzzy variable does not 
// lead to repeated invocation of the trigger operation.

module Sem_220203_TriggerOperation_024 {
    type integer address;
    
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_Sem_220203_TriggerOperation_024() runs on GeneralComp {
        var @lazy address v_addr;
        p.send(1) to 1;
        p.send(2) to 2;
        p.send(3) to 3;
        p.trigger(integer:?) -> sender v_addr;
        if (v_addr == 1) { // evaluation of @lazy (receive shall not be called again)
            alt {
                [] p.receive(integer:2) { setverdict(pass); }
                [] p.receive { setverdict(fail); }
            }
        } else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_024(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, lazy variable in value redirect 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// If a variable referenced in the value, sender or @index clause is a lazy or fuzzy 
// variable, the expression assigned to this variable is equal to the result produced 
// by the trigger operation i.e. later evaluation of the lazy or fuzzy variable does not 
// lead to repeated invocation of the trigger operation.

module Sem_220203_TriggerOperation_023 {
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_Sem_220203_TriggerOperation_023() runs on GeneralComp {
        var @lazy integer v_int;
        p.send(1);
        p.send(2);
        p.send(3);
        p.trigger(integer:?) -> value v_int;
        if (v_int == 1) { // evaluation of @lazy (receive shall not be called again)
            alt {
                [] p.receive(integer:2) { setverdict(pass); }
                [] p.receive { setverdict(fail); }
            }
        } else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_023(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, redirect assignment storing an address
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// It is also possible to retrieve and store the component reference or address of 
// the sender of a message. This is denoted by the keyword sender.

module Sem_220203_TriggerOperation_018 {

	type port P message {
		inout integer;
        address integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	    
    testcase TC_Sem_220203_TriggerOperation_018() runs on GeneralComp {
        var P.address v_addr := null;
        p.send(10) to 5;
        p.trigger(integer:?) -> sender v_addr;
        if (v_addr == 5) { setverdict(pass); }
        else { setverdict(fail); }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_018(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, trigger with a from clause (single item)
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// The matching criteria as defined in clause 22.2.2 apply also to the trigger 
// operation.
// In the case of one-to-many connections the [trigger] operation may be restricted 
// to a certain communication partner. This restriction shall be denoted using the 
// from keyword.

module Sem_220203_TriggerOperation_006 {
	
	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f(integer i) runs on GeneralComp
	{
        p.send(i);
	}
    
    const integer c_ptcCount := 3;
	
    testcase TC_Sem_220203_TriggerOperation_006() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptcs[c_ptcCount];
        var integer v_int;
        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            v_ptcs[i] := GeneralComp.create;
            connect(self:p, v_ptcs[i]:p);
            v_ptcs[i].start(f(i));
        }
        
        alt {
            [] p.trigger(integer:?) from v_ptcs[c_ptcCount - 1] -> value v_int { 
                if (v_int == c_ptcCount - 1) { setverdict(pass); } 
                else { setverdict(fail) };
            }
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_006(), 5.0);
    }
}/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:22.2.3, Ensure that the IUT correctly handles message trigger operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_220203_TriggerOperation_001 { 


    type port loopbackPort message {
      inout integer
    }
	

type component GeneralComp {	    	    
      port loopbackPort messagePort
}	

testcase TC_Sem_220203_TriggerOperation_001() runs on GeneralComp {

    timer t_timeout := 1.0;
    t_timeout.start;
    
    messagePort.send(2); 

    alt {
     [] messagePort.trigger(1) {   //must remove message from queue
        setverdict(fail);
     }
     [] messagePort.trigger(2) {	//this alt is only selected if message not removed from the queue
        setverdict(fail);
     }
     [] messagePort.trigger {
        setverdict(fail);
     }
     [] t_timeout.timeout {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_220203_TriggerOperation_001());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, standalone trigger as a shorthand for alt statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// The trigger operation can be used as a stand-alone statement in a behaviour description. 
// In this latter case the receive operation is considered to be shorthand for an alt 
// statement with two alternatives (one alternative expecting the message and another 
// alternative consuming all other messages and repeating the alt statement, see 
// ES 201 873 4 [1]).

module Sem_220203_TriggerOperation_022 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p1, p2;
	}
    
    altstep a() runs on GeneralComp {
        [] p2.receive(integer:?) { setverdict(pass); }
    }
	    
    testcase TC_Sem_220203_TriggerOperation_022() runs on GeneralComp {
        activate(a()); // defaults should be processed as a part of alt
        p1.send(1);
        p2.send(2);
        p1.trigger(integer:(10..20)); // no match here, but because the statement is actually an alt statement,
                      // the default shall be automatically exectuted and accept the message
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_022(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.3, @decoded redirect assignment of a charstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// Rules in clause 22.2.2 shall apply.
// When assigning individual fields of a message, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220203_TriggerOperation_014 {
	type record R
    {
        integer id,
        charstring payload
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220203_TriggerOperation_014() runs on GeneralComp {
        var integer v_src := 1953719668, v_res with { encode "32bit" };
        var charstring v_str := encvalue_unichar(v_src);
        p.send(R:{ id := 1, payload := v_str });
        alt {
            [] p.trigger(R:?) -> value (v_res := payload) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
        }
    }

    control {
        execute(TC_Sem_220203_TriggerOperation_014(), 5.0);
    }
}/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:22.2.3, Ensure that the IUT correctly handles message trigger operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_220203_TriggerOperation_002 { 


    type port loopbackPort message {
	  inout integer
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_220203_TriggerOperation_002() runs on GeneralComp {
 timer t_timeout:=5.0;

 messagePort.send(2); 
 t_timeout.start;

    alt {
     [] messagePort.trigger {   //must remove message from queue
        setverdict(pass);
     }
     [] messagePort.trigger {	//this alt is only selected if message not removed from the queue
        setverdict(fail);
     }
     [] t_timeout.timeout {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_220203_TriggerOperation_002());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, @decoded redirect assignment of an octetstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a message, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220202_ReceiveOperation_013 {
	type record R
    {
        integer id,
        octetstring payload
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220202_ReceiveOperation_013() runs on GeneralComp {
        var charstring v_src := "abc", v_res;        
        var octetstring v_os := bit2oct(encvalue(v_src));
        p.send(R:{ id := 1, payload := v_os });
        alt {
            [] p.receive(R:?) -> value (v_res := payload) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.receive { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_013(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, @decoded redirect assignment of a bitstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a message, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220202_ReceiveOperation_011 {
	type record R
    {
        integer id,
        bitstring payload
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220202_ReceiveOperation_011() runs on GeneralComp {
        var charstring v_src := "abc", v_res;        
        var bitstring v_bs := encvalue(v_src);
        p.send(R:{ id := 1, payload := v_bs });
        alt {
            [] p.receive(R:?) -> value (v_res := payload) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.receive { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_011(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, receive with a from clause (single item)
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// In the case of one-to-many connections the receive operation may be restricted 
// to a certain communication partner. This restriction shall be denoted using the 
// from keyword.

module Sem_220202_ReceiveOperation_006 {
	
	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
        p.send(1);
	}
    
    const integer c_ptcCount := 3;
	
    testcase TC_Sem_220202_ReceiveOperation_006() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptcs[c_ptcCount];
        var integer v_receiveCounter := 0;
        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            v_ptcs[i] := GeneralComp.create;
            connect(self:p, v_ptcs[i]:p);
            v_ptcs[i].start(f());
        }
        
        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            alt {
                [] p.receive(integer:?) from v_ptcs[0] { setverdict(pass); } // expected 1 from match
                [] p.receive(integer:?) { v_receiveCounter := v_receiveCounter + 1; } // expected 2 other received messages
            }
        }
        if (v_receiveCounter != c_ptcCount - 1) { setverdict(fail); }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_006(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, receive with a from clause (multiple items)
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// In the case of one-to-many connections the receive operation may be restricted 
// to a certain communication partner. This restriction shall be denoted using the 
// from keyword.

module Sem_220202_ReceiveOperation_007 {
	
	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
        p.send(1);
	}
    
    const integer c_ptcCount := 3;
	
    testcase TC_Sem_220202_ReceiveOperation_007() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptcs[c_ptcCount];
        var integer v_fromCounter := 0, v_noFromCounter := 0;
        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            v_ptcs[i] := GeneralComp.create;
            connect(self:p, v_ptcs[i]:p);
            v_ptcs[i].start(f());
        }
        
        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            alt {
                [] p.receive(integer:?) from (v_ptcs[0], v_ptcs[1]) { v_fromCounter := v_fromCounter + 1; }
                [] p.receive(integer:?) { v_noFromCounter := v_noFromCounter + 1; }
            }
        }
        if (v_fromCounter == 2 and v_noFromCounter == 1) { setverdict(pass); }
        else { setverdict(fail); }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_007(), 5.0);
    }
}/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:22.2.2, Ensure that the IUT correctly handles message receiving operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_220202_ReceiveOperation_005 { 


    type port loopbackPort message {
	  inout integer
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_220202_ReceiveOperation_005() runs on GeneralComp {

 messagePort.send(2); 

    alt {
     [] any port.receive(2) {   //checks receiving from ny port
        setverdict(pass);
     }
     [] messagePort.receive {	//this alt is only selected if message was not removed from the queue
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_220202_ReceiveOperation_005());
}

}
/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:22.2.2, Ensure that the IUT correctly handles message receiving operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_220202_ReceiveOperation_003 { 


    type port loopbackPort message {
	  inout integer
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_220202_ReceiveOperation_003() runs on GeneralComp {
 var integer v_received:=0;

 messagePort.send(2); 

    alt {
     [] messagePort.receive(integer:?) -> value v_received { 
       if(v_received==2) {  //check that correct value has been stored
        setverdict(pass);
       }
       else {
        setverdict(fail);
       }
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_220202_ReceiveOperation_003());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, standalone receive as a shorthand for alt statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// The receive operation can be used as a stand-alone statement in a behaviour description. 
// In this latter case the receive operation is considered to be shorthand for an alt 
// statement with the receive operation as the only alternative.

module Sem_220202_ReceiveOperation_022 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
    
    altstep a() runs on GeneralComp {
        [] p.receive(10) { setverdict(pass); }
    }
	    
    testcase TC_Sem_220202_ReceiveOperation_022() runs on GeneralComp {
        activate(a()); // defaults should be processed as a part of alt
        p.send(10);
        p.receive(0); // no match here, but because the statement is actually an alt statement,
                      // the default shall be automatically exectuted and accept the message
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_022(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, any from port.receive statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// To receive a message on any port from a specific port array, use the any from 
// PortArrayRef syntax where PortArrayRef shall be a reference to a  port array 
// identifier.

module Sem_220202_ReceiveOperation_019 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p [3];
	}
	    
    testcase TC_Sem_220202_ReceiveOperation_019() runs on GeneralComp {
        p[2].send(10);
        alt {
            [] any from p.receive(integer:?) { setverdict(pass); }
            [] any port.receive { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_019(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, multidimensional index redirect in any from port.receive statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// It is also possible to store the index of a port in a single-dimensional port array 
// at which the operation was successful to a variable of type integer or, in case of 
// multi-dimensional port arrays the index of the successful port to an integer array 
// or record of integer variable. When checking the port array for matching messages, 
// the port indices to be checked are iterated from lowest to highest. If the port 
// array is multi-dimensional, then the ports are iterated over from innermost to 
// outermost array dimension from lowest to highest index for each dimension, e.g. 
// [0][0], [0][1], [1][0], [1][1]. The first port which matches all the criteria will 
// cause the operation to be successful even if other ports in the array would also 
// meet the criteria.

module Sem_220202_ReceiveOperation_021 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p [2][3];
	}
    
    type record of integer RoI;
	    
    testcase TC_Sem_220202_ReceiveOperation_021() runs on GeneralComp {
        var RoI v_index;
        p[0][2].send(10);
        alt {
            [] any from p.receive(integer:?) -> @index v_index { 
                if (v_index == { 0, 2 }) { setverdict(pass); }
                else { setverdict(fail, "v_index: ", v_index); }
            }
            [] any port.receive { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_021(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, lazy variable in value redirect 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// If a variable referenced in the value, sender or @index clause is a lazy or fuzzy 
// variable, the expression assigned to this variable is equal to the result produced 
// by the receive operation i.e. later evaluation of the lazy or fuzzy variable does not 
// lead to repeated invocation of the receive operation.

module Sem_220202_ReceiveOperation_024 {
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_Sem_220202_ReceiveOperation_024() runs on GeneralComp {
        var @lazy integer v_int;
        p.send(1);
        p.send(2);
        p.send(3);
        p.receive(integer:?) -> value v_int;
        if (v_int == 1) { // evaluation of @lazy (receive shall not be called again)
            alt {
                [] p.receive(integer:2) { setverdict(pass); }
                [] p.receive { setverdict(fail); }
            }
        } else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_024(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, redirect assignment of message fields
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When the keyword value is followed by an assignment list enframed by a pair of 
// parentheses, the whole received message and/or one or more parts of it can be 
// stored. In a single assignment within the list, on the right hand side of the 
// assignment symbol (":=") a field of the template type shall be referenced, on 
// the left hand side the name of the variable or a formal parameter, in which 
// the value shall be stored.

module Sem_220202_ReceiveOperation_009 {
	type record R
    {
        integer field1[2],
        charstring field2
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220202_ReceiveOperation_009() runs on GeneralComp {
        var integer v_int;
        var charstring v_str;
        p.send(R:{ field1 := { 1, 2 }, field2 := "abc" });
        alt {
            [] p.receive(R:?) -> value ( v_int := field1[1], v_str := field2) { 
                if (v_int == 2 and v_str == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.receive { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_009(), 5.0);
    }
}/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:22.2.2, Ensure that the IUT correctly handles message receiving operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_220202_ReceiveOperation_002 { 


    type port loopbackPort message {
	  inout integer
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_220202_ReceiveOperation_002() runs on GeneralComp {

 messagePort.send(2); 

    alt {
     [] messagePort.receive {   //must remove message from queue
        setverdict(pass);
     }
     [] messagePort.receive {	//this alt is only selected if message not removed from the queue
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_220202_ReceiveOperation_002());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, @decoded redirect assignment of a hexstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a message, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220202_ReceiveOperation_012 {
	type record R
    {
        integer id,
        hexstring payload
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220202_ReceiveOperation_012() runs on GeneralComp {
        var charstring v_src := "abc", v_res;        
        var hexstring v_hs := bit2hex(encvalue(v_src));
        p.send(R:{ id := 1, payload := v_hs });
        alt {
            [] p.receive(R:?) -> value (v_res := payload) { 
                if (v_res == "abc") { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.receive { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_012(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, single dimensional index redirect in any from port.receive statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// No binding of the incoming values to the terms of the expression or to the template 
// shall occur.

module Sem_220202_ReceiveOperation_023 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	    
    testcase TC_Sem_220202_ReceiveOperation_023() runs on GeneralComp {
        var template integer v_expectedValue := ?;
        p.send(10);
        p.receive(v_expectedValue);
        // make sure the template variable hasn't changed:
        if (istemplatekind(v_expectedValue, "AnyValue")) {setverdict(pass); } 
        else { setverdict(fail); } 
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_023(), 5.0);
    }
}/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:22.2.2, Ensure that the IUT correctly handles message receiving operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_220202_ReceiveOperation_001 { 


    type port loopbackPort message {
	  inout integer
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_220202_ReceiveOperation_001() runs on GeneralComp {

 messagePort.send(2); 

    alt {
     [] messagePort.receive(1) {   //must not remove message from queue
        setverdict(fail);
     }
     [] messagePort.receive(2) {	//this alt is only selected if message not removed from the queue
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_220202_ReceiveOperation_001());
}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, redirect assignment storing a component
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// It is also possible to retrieve and store the component reference or address of 
// the sender of a message. This is denoted by the keyword sender.

module Sem_220202_ReceiveOperation_017 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	    
    testcase TC_Sem_220202_ReceiveOperation_017() runs on GeneralComp system GeneralComp {
        var GeneralComp v_tc := null;
        connect(self:p, self:p);
        p.send(10);
        p.receive(integer:?) -> sender v_tc;
        if (v_tc == self) { setverdict(pass); }
        else { setverdict(fail); }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_017(), 5.0);
    }
}/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:22.2.2, Ensure that the IUT correctly handles message receiving operations 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_220202_ReceiveOperation_004 {

    type charstring address;
    type port loopbackPort message {
        inout integer
    }
	

    type component GeneralComp {
        port loopbackPort messagePort
    }
    
    const address c_address := "Tester";

    testcase TC_Sem_220202_ReceiveOperation_004() runs on GeneralComp {
        var address v_sender;

        messagePort.send(2) to c_address;

        alt {
            [] messagePort.receive(2) -> sender v_sender {
                messagePort.send(5) to v_sender;
                alt {
                    [] messagePort.receive(5) from v_sender {  //check that correct sender address has been assigned
                        setverdict(pass);
                    }
                    [] messagePort.receive {
                        setverdict(fail);
                    }
                }
            }
            [] messagePort.receive {
                setverdict(fail);
            }
        }
    }

    control{
        execute(TC_Sem_220202_ReceiveOperation_004());
    }

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, fuzzy variable in @index redirect 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// If a variable referenced in the value, sender or @index clause is a lazy or fuzzy 
// variable, the expression assigned to this variable is equal to the result produced 
// by the receive operation i.e. later evaluation of the lazy or fuzzy variable does not 
// lead to repeated invocation of the receive operation.

module Sem_220202_ReceiveOperation_029 {
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p[2];
	}
	    
    testcase TC_Sem_220202_ReceiveOperation_029() runs on GeneralComp {
        var @fuzzy integer v_int;
        p[1].send(1);
        p[1].send(2);
        p[1].send(3);
        any from p.receive(integer:?) -> @index v_int;
        if (v_int == 1) { // evaluation of @lazy (receive shall not be called again)
            alt {
                [] p[1].receive(integer:2) { setverdict(pass); }
                [] any from p.receive { setverdict(fail); }
            }
        } else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_029(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, lazy variable in index redirect 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// If a variable referenced in the value, sender or @index clause is a lazy or fuzzy 
// variable, the expression assigned to this variable is equal to the result produced 
// by the receive operation i.e. later evaluation of the lazy or fuzzy variable does not 
// lead to repeated invocation of the receive operation.

module Sem_220202_ReceiveOperation_026 {
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p[2];
	}
	    
    testcase TC_Sem_220202_ReceiveOperation_026() runs on GeneralComp {
        var @lazy integer v_int;
        p[1].send(1);
        p[1].send(2);
        p[1].send(3);
        any from p.receive(integer:?) -> @index v_int;
        if (v_int == 1) { // evaluation of @lazy (receive shall not be called again)
            alt {
                [] p[1].receive(integer:2) { setverdict(pass); }
                [] any from p.receive { setverdict(fail); }
            }
        } else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_026(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, fuzzy variable in value redirect 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// If a variable referenced in the value, sender or @index clause is a lazy or fuzzy 
// variable, the expression assigned to this variable is equal to the result produced 
// by the receive operation i.e. later evaluation of the lazy or fuzzy variable does not 
// lead to repeated invocation of the receive operation.

module Sem_220202_ReceiveOperation_027 {
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_Sem_220202_ReceiveOperation_027() runs on GeneralComp {
        var @fuzzy integer v_int;
        p.send(1);
        p.send(2);
        p.send(3);
        p.receive(integer:?) -> value v_int;
        if (v_int == 1) { // evaluation of @lazy (receive shall not be called again)
            alt {
                [] p.receive(integer:2) { setverdict(pass); }
                [] p.receive { setverdict(fail); }
            }
        } else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_027(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, fuzzy variable in sender redirect 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// If a variable referenced in the value, sender or @index clause is a lazy or fuzzy 
// variable, the expression assigned to this variable is equal to the result produced 
// by the receive operation i.e. later evaluation of the lazy or fuzzy variable does not 
// lead to repeated invocation of the receive operation.

module Sem_220202_ReceiveOperation_028 {
    type integer address;
    
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_Sem_220202_ReceiveOperation_028() runs on GeneralComp {
        var @fuzzy address v_addr;
        p.send(1) to 1;
        p.send(2) to 2;
        p.send(3) to 3;
        p.receive(integer:?) -> sender v_addr;
        if (v_addr == 1) { // evaluation of @lazy (receive shall not be called again)
            alt {
                [] p.receive(integer:2) { setverdict(pass); }
                [] p.receive { setverdict(fail); }
            }
        } else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_028(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, redirect assignment of message fields
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// As a special case the field reference can be absent to indicate that the whole 
// message shall be stored in a variable.

module Sem_220202_ReceiveOperation_010 {
	type record R
    {
        integer field1[2],
        charstring field2
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220202_ReceiveOperation_010() runs on GeneralComp {
        var integer v_int;
        var charstring v_str;
        var R v_rec;
        p.send(R:{ field1 := { 1, 2 }, field2 := "abc" });
        alt {
            [] p.receive(R:?) -> value ( v_int := field1[1], v_rec, v_str := field2) { 
                if (v_int == 2 and v_str == "abc" and v_rec == { field1 := { 1, 2 }, field2 := "abc" }) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.receive { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_010(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, @decoded redirect assignment with encoding parameter
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// In case the referenced field is of the universal charstring type, the @decoded 
// clause can contain an optional parameter defining the encoding format. The 
// parameter shall be of the charstring type and it shall contain one of the 
// strings allowed for the decvalue_unichar function (specified in clause C.5.4).

module Sem_220202_ReceiveOperation_016 {
	type record R
    {
        integer id,
        universal charstring payload
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220202_ReceiveOperation_016() runs on GeneralComp {
        var integer v_src := 1953719668, v_res with { encode "32bit" };
        var universal charstring v_str := encvalue_unichar(v_src, "UTF-16LE");
        p.send(R:{ id := 1, payload := v_str });
        alt {
            [] p.receive(R:?) -> value (v_res := payload) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.receive { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_016(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, @decoded redirect assignment of a universal charstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a message, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220202_ReceiveOperation_015 {
	type record R
    {
        integer id,
        universal charstring payload
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220202_ReceiveOperation_015() runs on GeneralComp {
        var integer v_src := 1953719668, v_res with { encode "32bit" };
        var universal charstring v_str := encvalue_unichar(v_src);
        p.send(R:{ id := 1, payload := v_str });
        alt {
            [] p.receive(R:?) -> value (v_res := payload) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.receive { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_015(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, @decoded redirect assignment of a charstring field
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When assigning individual fields of a message, encoded payload fields can be 
// decoded prior to assignment using the @decoded modifier. In this case, the 
// referenced field on the right hand sided of the assignment shall be one of the 
// bitstring, hexstring, octetstring, charstring or universal charstring types. It 
// shall be decoded into a value of the same type as the variable on the left hand 
// side of the assignment.

module Sem_220202_ReceiveOperation_014 {
	type record R
    {
        integer id,
        charstring payload
    }
    
	type port P message {
		inout R;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
    testcase TC_Sem_220202_ReceiveOperation_014() runs on GeneralComp {
        var integer v_src := 1953719668, v_res with { encode "32bit" };
        var charstring v_str := encvalue_unichar(v_src);
        p.send(R:{ id := 1, payload := v_str });
        alt {
            [] p.receive(R:?) -> value (v_res := payload) { 
                if (v_res == 1953719668) { setverdict (pass); }
                else { setverdict(fail); }
            }
            [] p.receive { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_014(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, single dimensional index redirect in any from port.receive statement
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// It is also possible to store the index of a port in a single-dimensional port array 
// at which the operation was successful to a variable of type integer or, in case of 
// multi-dimensional port arrays the index of the successful port to an integer array 
// or record of integer variable. When checking the port array for matching messages, 
// the port indices to be checked are iterated from lowest to highest. If the port 
// array is multi-dimensional, then the ports are iterated over from innermost to 
// outermost array dimension from lowest to highest index for each dimension, e.g. 
// [0][0], [0][1], [1][0], [1][1]. The first port which matches all the criteria will 
// cause the operation to be successful even if other ports in the array would also 
// meet the criteria.

module Sem_220202_ReceiveOperation_020 {

	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p [3];
	}
	    
    testcase TC_Sem_220202_ReceiveOperation_020() runs on GeneralComp {
        var integer v_index;
        p[2].send(10);
        alt {
            [] any from p.receive(integer:?) -> @index v_index { 
                if (v_index == 2) { setverdict(pass); }
                else { setverdict(fail); }
            }
            [] any port.receive { setverdict(fail); }
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_020(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, redirect assignment storing an address
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// It is also possible to retrieve and store the component reference or address of 
// the sender of a message. This is denoted by the keyword sender.

module Sem_220202_ReceiveOperation_018 {

	type port P message {
		inout integer;
        address integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	    
    testcase TC_Sem_220202_ReceiveOperation_018() runs on GeneralComp {
        var P.address v_addr := null;
        p.send(10) to 5;
        p.receive(integer:?) -> sender v_addr;
        if (v_addr == 5) { setverdict(pass); }
        else { setverdict(fail); }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_018(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, lazy variable in sender redirect 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// If a variable referenced in the value, sender or @index clause is a lazy or fuzzy 
// variable, the expression assigned to this variable is equal to the result produced 
// by the receive operation i.e. later evaluation of the lazy or fuzzy variable does not 
// lead to repeated invocation of the receive operation.

module Sem_220202_ReceiveOperation_025 {
    type integer address;
    
	type port P message {
		inout integer;
	}
	
    type component GeneralComp {
		port P p;
	}
	    
    testcase TC_Sem_220202_ReceiveOperation_025() runs on GeneralComp {
        var @lazy address v_addr;
        p.send(1) to 1;
        p.send(2) to 2;
        p.send(3) to 3;
        p.receive(integer:?) -> sender v_addr;
        if (v_addr == 1) { // evaluation of @lazy (receive shall not be called again)
            alt {
                [] p.receive(integer:2) { setverdict(pass); }
                [] p.receive { setverdict(fail); }
            }
        } else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_025(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:22.2.2, receive with a from clause (any component)
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// In the case of one-to-many connections the receive operation may be restricted 
// to a certain communication partner. This restriction shall be denoted using the 
// from keyword.

module Sem_220202_ReceiveOperation_008 {
	
	type port P message {
		inout integer;
	}
	
    type component GeneralComp 
	{
		port P p;
	}
	
	function f() runs on GeneralComp
	{
        p.send(1);
	}
    
    const integer c_ptcCount := 3;
	
    testcase TC_Sem_220202_ReceiveOperation_008() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptcs[c_ptcCount];
        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            v_ptcs[i] := GeneralComp.create;
            connect(self:p, v_ptcs[i]:p);
            v_ptcs[i].start(f());
        }
        
        for (var integer i := 0; i < c_ptcCount; i := i + 1) {
            alt {
                [] p.receive(integer:?) from any component { setverdict(pass); }
                [] p.receive(integer:?) { setverdict(fail); }
            }
        }        
    }

    control {
        execute(TC_Sem_220202_ReceiveOperation_008(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template(present) base templates are allowed to be modfied to template.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// ATTENTION: valid for TTCN-3:2013 (ETSI ES 201 873-1 V4.5.1) and newer
// Older versions of the core languate standard didn't allow this type of 
// modification because of restriction 15.8.c.

module Sem_1508_TemplateRestrictions_030 {

	type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(present) ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }
	
    template ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 21
    }

	testcase TC_Sem_1508_TemplateRestrictions_030() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 21) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_030());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template(present) base templates are allowed to be modfied to template(omit).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// ATTENTION: valid for TTCN-3:2013 (ETSI ES 201 873-1 V4.5.1) and newer
// Older versions of the core languate standard didn't allow this type of 
// modification because of restriction 15.8.c.

module Sem_1508_TemplateRestrictions_024 {

	type component GeneralComp { }
	
    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(present) ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }

    template(omit) ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 21
    }

	testcase TC_Sem_1508_TemplateRestrictions_024() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 21) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_024());
    }
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a value can be assigned to a template(omit) variable.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_001 {

type component GeneralComp { }

testcase TC_Sem_1508_TemplateRestrictions_001() runs on GeneralComp {
	var template(omit) integer v_omit;
	
	v_omit := 20;
	
	if (valueof(v_omit) == 20) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_001());
}


}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template(present) can be parameter to template(value)
 ** @verdict  pass reject
 *****************************************************************/

module Sem_1508_TemplateRestrictions_046 {

    type record ExampleType {	// Exampletype record integer and a boolean
       	integer a,
	boolean b 
       }	
	
	type component GeneralComp {
	}



	template (value) ExampleType m_baseTemplate(template (present) integer MyintTemplate := 2) :={
		a := MyintTemplate,	 
		b := true
	}
	
	testcase TC_Sem_1508_TemplateRestrictions_046() runs on GeneralComp {
      
		
		if (ispresent(m_baseTemplate.a) == true) {
      		setverdict(pass);
		} else {
            setverdict(fail);
       }
 }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_046());
    }
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a template(omit) can be assigned to a template(present) variable.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_007 {

type component GeneralComp { }

type record ExampleType {
	integer a,
	boolean b optional
}

template(omit) ExampleType exampleOmit := {1, omit};

testcase TC_Sem_1508_TemplateRestrictions_007() runs on GeneralComp {
	var template(present) ExampleType v_present;
	
	v_present := exampleOmit;
	
	if (match(valueof(v_present.a), 1) and
	    match(ispresent(v_present.b), false)
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_007());
}


}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a template(value) base template can be modified with template(value) restriction.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_023 {

    type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(value) ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }

    template(value) ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 22
    }

    testcase TC_Sem_1508_TemplateRestrictions_023() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 22) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_023());
    }


}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template(value) base templates are allowed to be modfied to template(omit).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// ATTENTION: valid for TTCN-3:2013 (ETSI ES 201 873-1 V4.5.1) and newer
// Older versions of the core languate standard didn't allow this type of 
// modification because of restriction 15.8.c.

module Sem_1508_TemplateRestrictions_027 {
	
	type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(value) ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }

// shall be rejected as template(omit) is not an allowed restriction for template(value)
// templates
    template(omit) ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 21
    }

	testcase TC_Sem_1508_TemplateRestrictions_027() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 21) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_027());
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that the restrictiveness of parameters template(omit)->template(present) is handled correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// ATTENTION: valid for TTCN-3:2013 (ETSI ES 201 873-1 V4.5.1) and newer
// Older versions of the core languate standard didn't allow this type of 
// modification because of restriction 15.8.c.

/*
Pro opinion:
Test an intentional change made on the request of the STF160 in TTCN-3:2013. In particular, restriction 15.8.c was taken away from the core language specification (as marked in test case comments). This restriction did indeed mean that the tests would behave as you described, thus producing an error. However, with the restriction missing, the tests are perfectly valid. I also do not understand why you claim that it would not be possible to instantiate super-templates in these cases. Restrictions are always related to actual values and if the values satisfy both restrictions (parent and modified), there's no problem at all. And this is exactly what these test intend to verify.
Besides, the core language specification does not say that the parameters must be the same. There's a rule saying that the parameters shall not be omitted. It is rather unfortunate wording, because it might be interpreted in several ways. There's a CR 6692 regarding this issue.

Contra opinion
The problem is with the semantics of modified templates. For every actual parameter list, first, the template-to-be-modified is implicitly instantiated and then modified by the given modifications. If the template-to-be-modified is not defined for the actual parameters, then neither is the modified one. Of course, you are right in that this restriction could be applied for actual parameters only and need not be checked at the template-level already. However, it does not make sense to lessen the template restriction of a parameter, as implicitly, it still keeps the stronger restriction (because of the modification-semantics). Therefore, it is misleading to SEEMINGLY allow a template(present) parameter for a template where the super-template has a template(value) parameter. If allowed, the user might use a non-value template as an actual parameter and then get a runtime error, even though the template-restriction matched the one in the formal parameter of the template. Therefore, we interpret the standard in such a way that the inheritance of the parameters includes the inheritance of both the types and the template restrictions of the inherited parameters. Strengthening of template restrictions would indeed not be a problem. Lessening is.

*/

module Sem_1508_TemplateRestrictions_035 {

	type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(present) ExampleType m_baseTemplate(template(omit) integer p_myInt) := {
        a := p_myInt,
        b := true
    }

    template(present) ExampleType m_modifiedTemplate(template integer p_myInt) modifies m_baseTemplate := {
        a := 21
    }

	testcase TC_Sem_1508_TemplateRestrictions_035() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate(1).a), 21) and
            match(valueof(m_modifiedTemplate(1).b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_035());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template(omit) base templates are allowed to be modfied to template.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// ATTENTION: valid for TTCN-3:2013 (ETSI ES 201 873-1 V4.5.1) and newer
// Older versions of the core languate standard didn't allow this type of 
// modification because of restriction 15.8.c.

module Sem_1508_TemplateRestrictions_029 {

	type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(omit) ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }

    template ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 21
    }

	testcase TC_Sem_1508_TemplateRestrictions_029() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 21) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_029());
    }
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template(omit) is accepted with value omitvalue.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1508_TemplateRestrictions_001 {

type record ExampleType {
	integer a,
	boolean b optional
}

template(omit) ExampleType exampleOmit := omit;

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a value can be assigned to a template variable.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_010 {

type component GeneralComp { }

testcase TC_Sem_1508_TemplateRestrictions_010() runs on GeneralComp {
	var template integer v_template;
	
	v_template := 20;
	
	if (valueof(v_template) == 20) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_010());
}


}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that the restrictiveness of parameters template(omit)->template(present) is handled correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// ATTENTION: valid for TTCN-3:2013 (ETSI ES 201 873-1 V4.5.1) and newer
// Older versions of the core languate standard didn't allow this type of 
// modification because of restriction 15.8.c.

/*
Pro opinion:
Test an intentional change made on the request of the STF160 in TTCN-3:2013. In particular, restriction 15.8.c was taken away from the core language specification (as marked in test case comments). This restriction did indeed mean that the tests would behave as you described, thus producing an error. However, with the restriction missing, the tests are perfectly valid. I also do not understand why you claim that it would not be possible to instantiate super-templates in these cases. Restrictions are always related to actual values and if the values satisfy both restrictions (parent and modified), there's no problem at all. And this is exactly what these test intend to verify.
Besides, the core language specification does not say that the parameters must be the same. There's a rule saying that the parameters shall not be omitted. It is rather unfortunate wording, because it might be interpreted in several ways. There's a CR 6692 regarding this issue.

Contra opinion
The problem is with the semantics of modified templates. For every actual parameter list, first, the template-to-be-modified is implicitly instantiated and then modified by the given modifications. If the template-to-be-modified is not defined for the actual parameters, then neither is the modified one. Of course, you are right in that this restriction could be applied for actual parameters only and need not be checked at the template-level already. However, it does not make sense to lessen the template restriction of a parameter, as implicitly, it still keeps the stronger restriction (because of the modification-semantics). Therefore, it is misleading to SEEMINGLY allow a template(present) parameter for a template where the super-template has a template(value) parameter. If allowed, the user might use a non-value template as an actual parameter and then get a runtime error, even though the template-restriction matched the one in the formal parameter of the template. Therefore, we interpret the standard in such a way that the inheritance of the parameters includes the inheritance of both the types and the template restrictions of the inherited parameters. Strengthening of template restrictions would indeed not be a problem. Lessening is.

*/

module Sem_1508_TemplateRestrictions_034 {

	type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(present) ExampleType m_baseTemplate(template(omit) integer p_myInt) := {
        a := p_myInt,
        b := true
    }

    template(present) ExampleType m_modifiedTemplate(template(present) integer p_myInt) modifies m_baseTemplate := {
        a := 21
    }

	testcase TC_Sem_1508_TemplateRestrictions_034() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate(1).a), 21) and
            match(valueof(m_modifiedTemplate(1).b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_034());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a template(present) base template can be modified with template(present) restriction.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_019 {

    type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(present) ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }

    template(present) ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 22
    }

    testcase TC_Sem_1508_TemplateRestrictions_019() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 22) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_019());
    }


}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that unrestricted template can be parameter to template(value)
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_045 {

    type record ExampleType {	// Exampletype record integer and a boolean
       	integer a,
	boolean b 
       }	
	
	type component GeneralComp {
	}



	template (value) ExampleType m_baseTemplate(template integer MyintTemplate := 1) :={
		a := MyintTemplate,	 
		b := true
	}
	
	testcase TC_Sem_1508_TemplateRestrictions_045() runs on GeneralComp {
      
		
		if (ispresent(m_baseTemplate.a) == true) {
      		setverdict(pass);
		} else {
            setverdict(fail);
       }
 }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_045());
    }
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a template(present) can be assigned to a template(present) variable.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_009 {

type component GeneralComp { }

type record ExampleType {
	integer a,
	boolean b optional
}

template(present) ExampleType examplePresent := {1, true};

testcase TC_Sem_1508_TemplateRestrictions_009() runs on GeneralComp {
	var template(present) ExampleType v_present;
	
	v_present := examplePresent;
	
	if (match(valueof(v_present.a), 1) and
	    match(valueof(v_present.b), true)
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_009());
}


}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a template(omit) base template can be modified with template(omit) restriction.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_021 {

    type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(omit) ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }

    template(omit) ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 22
    }

    testcase TC_Sem_1508_TemplateRestrictions_021() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 22) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_021());
    }


}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template(value) base templates are allowed to be modfied to template.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// ATTENTION: valid for TTCN-3:2013 (ETSI ES 201 873-1 V4.5.1) and newer
// Older versions of the core languate standard didn't allow this type of 
// modification because of restriction 15.8.c.

module Sem_1508_TemplateRestrictions_028 {

	type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(value) ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }

    template ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 21
    }
	
	testcase TC_Sem_1508_TemplateRestrictions_028() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 21) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_028());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a base template can be modified with template(value) restriction.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_018 {

    type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }

    template(value) ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 22
    }

    testcase TC_Sem_1508_TemplateRestrictions_018() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 22) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_018());
    }


}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a template(omit) can be assigned to a template variable.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_011 {

type component GeneralComp { }

type record ExampleType {
	integer a,
	boolean b optional
}

template(omit) ExampleType exampleOmit := {1, omit};

testcase TC_Sem_1508_TemplateRestrictions_011() runs on GeneralComp {
	var template ExampleType v_template;
	
	v_template := exampleOmit;
	
	if (match(valueof(v_template.a), 1) and
	    match(ispresent(v_template.b), false)
	    ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_011());
}


}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a templat(value) can be assigned to a template(omit) variable.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_003 {

type component GeneralComp { }

type record ExampleType {
	integer a,
	boolean b optional
}

template(value) ExampleType exampleValueOptional := {1, omit};

testcase TC_Sem_1508_TemplateRestrictions_003() runs on GeneralComp {
	var template(omit) ExampleType v_omit;
	
	v_omit := exampleValueOptional;
	
	if (match(valueof(v_omit.a), 1) and
	    match(ispresent(v_omit.b), false )
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_003());
}


}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that the restrictiveness of parameters template(value)->template(omit) is handled correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// ATTENTION: valid for TTCN-3:2013 (ETSI ES 201 873-1 V4.5.1) and newer
// Older versions of the core languate standard didn't allow this type of 
// modification because of restriction 15.8.c.

/*
Pro opinion:
Test an intentional change made on the request of the STF160 in TTCN-3:2013. In particular, restriction 15.8.c was taken away from the core language specification (as marked in test case comments). This restriction did indeed mean that the tests would behave as you described, thus producing an error. However, with the restriction missing, the tests are perfectly valid. I also do not understand why you claim that it would not be possible to instantiate super-templates in these cases. Restrictions are always related to actual values and if the values satisfy both restrictions (parent and modified), there's no problem at all. And this is exactly what these test intend to verify.
Besides, the core language specification does not say that the parameters must be the same. There's a rule saying that the parameters shall not be omitted. It is rather unfortunate wording, because it might be interpreted in several ways. There's a CR 6692 regarding this issue.

Contra opinion
The problem is with the semantics of modified templates. For every actual parameter list, first, the template-to-be-modified is implicitly instantiated and then modified by the given modifications. If the template-to-be-modified is not defined for the actual parameters, then neither is the modified one. Of course, you are right in that this restriction could be applied for actual parameters only and need not be checked at the template-level already. However, it does not make sense to lessen the template restriction of a parameter, as implicitly, it still keeps the stronger restriction (because of the modification-semantics). Therefore, it is misleading to SEEMINGLY allow a template(present) parameter for a template where the super-template has a template(value) parameter. If allowed, the user might use a non-value template as an actual parameter and then get a runtime error, even though the template-restriction matched the one in the formal parameter of the template. Therefore, we interpret the standard in such a way that the inheritance of the parameters includes the inheritance of both the types and the template restrictions of the inherited parameters. Strengthening of template restrictions would indeed not be a problem. Lessening is.

*/

module Sem_1508_TemplateRestrictions_032 {

	type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(present) ExampleType m_baseTemplate(template(value) integer p_myInt) := {
        a := p_myInt,
        b := true
    }

    template(present) ExampleType m_modifiedTemplate(template(omit) integer p_myInt) modifies m_baseTemplate := {
        a := 21
    }
	
	testcase TC_Sem_1508_TemplateRestrictions_032() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate(1).a), 21) and
            match(valueof(m_modifiedTemplate(1).b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_032());
    }

}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that the an unrestriced template can be parameter to template(present)
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_043 {

    type record ExampleType {	// Exampletype record integer and a boolean
       	integer a,
	boolean b 
       }	
	
	type component GeneralComp {
	}



	template (present) ExampleType m_baseTemplate(template integer MyintTemplate := 21) :={
		a := MyintTemplate,	 
		b := true
	}
	
	testcase TC_Sem_1508_TemplateRestrictions_043() runs on GeneralComp {
      
		
		if (ispresent(m_baseTemplate.a) == true) {
      		setverdict(pass);
		} else {
            setverdict(fail);
       }
 }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_043());
    }
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a template(value) can be assigned to a template(value) variable.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_005 {

type component GeneralComp { }

type record ExampleType {
	integer a,
	boolean b optional
}

template(value) ExampleType exampleValue := {1, true};

testcase TC_Sem_1508_TemplateRestrictions_005() runs on GeneralComp {
	var template(value) ExampleType v_value;
	
	v_value := exampleValue;
	
	if (match(valueof(v_value.a), 1) and
	    match(valueof(v_value.b), true)
	    ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_005());
}


}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that decoded content match is allowed for present template restriction
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/


module Sem_1508_TemplateRestrictions_049 { 

	type record MessageType {
	  hexstring payload
	}
	
	type record Mymessage {
	  integer field1,
	  bitstring field2 optional
    }
	

    type port loopbackPort message{inout MessageType};
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_1508_TemplateRestrictions_049() runs on GeneralComp {
    var bitstring v_enc;
    var Mymessage v_testMessage;
    var MessageType Message;
    
    v_testMessage:=  {  
        field1 := 10,
        field2 := '1001'B
     } 

      Message.payload := bit2hex(encvalue(v_testMessage));		//encode message to payload
          
    
    

 template (present) MessageType mw_matchingTemplate:=
  {  			
  //TODO: payload :=  decmatch Mymessage: {field1:= 10, field2 := '1001'B}
  } 


  messagePort.send(Message);	//send message

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail,mw_matchingTemplate);
     }
    }
    
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_049());
}

}
 /*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template(omit) can be parameter to template(value)
 ** @verdict  pass reject
 *****************************************************************/

module Sem_1508_TemplateRestrictions_047 {

    type record ExampleType {	// Exampletype record integer and a boolean
       	integer a,
	boolean b 
       }	
	
	type component GeneralComp {
	}



	template (value) ExampleType m_baseTemplate(template (omit) integer MyintTemplate := 1) :={
		a := MyintTemplate,	 
		b := true
	}
	
	testcase TC_Sem_1508_TemplateRestrictions_047() runs on GeneralComp {
      
		
		if (ispresent(m_baseTemplate.a) == true) {
      		setverdict(pass);
		} else {
            setverdict(fail);
       }
 }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_047());
    }
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a template(value) can be assigned to a template(present) variable.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_008 {

type component GeneralComp { }

type record ExampleType {
	integer a,
	boolean b optional
}

template(value) ExampleType exampleValue := {1, true};

testcase TC_Sem_1508_TemplateRestrictions_008() runs on GeneralComp {
	var template(present) ExampleType v_present;
	
	v_present := exampleValue;
	
	if (match(valueof(v_present.a), 1) and
	    match(valueof(v_present.b), true)
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_008());
}


}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a template(omit) base template can be modified with template(value) restriction.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_022 {

    type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(omit) ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }

    template(value) ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 22
    }

    testcase TC_Sem_1508_TemplateRestrictions_022() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 22) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_022());
    }


}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a base template can be modified with template(omit) restriction.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_017 {

    type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }

    template(omit) ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 22
    }

    testcase TC_Sem_1508_TemplateRestrictions_017() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 22) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_017());
    }


}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a base template can be modified without restrictions.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_015 {

type component GeneralComp { }

type record ExampleType {
	integer a,
	boolean b optional
}

template ExampleType m_baseTemplate := {
	a := 20,
	b := true
}

template ExampleType m_modifiedTemplate modifies m_baseTemplate := {
	a := 22
}

testcase TC_Sem_1508_TemplateRestrictions_015() runs on GeneralComp {	
	if (match(valueof(m_modifiedTemplate.a), 22) and
	    match(valueof(m_modifiedTemplate.b), true)
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_015());
}


}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template(omit) is accepted with a concrete value.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1508_TemplateRestrictions_002 {

type record ExampleType {
	integer a,
	boolean b optional
}

template(omit) ExampleType exampleOmit := {1, true};

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a template(value) can be assigned to a template variable.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_012 {

type component GeneralComp { }

type record ExampleType {
	integer a,
	boolean b optional
}

template(value) ExampleType exampleValue := {1, true};

testcase TC_Sem_1508_TemplateRestrictions_012() runs on GeneralComp {
	var template ExampleType v_template;
	
	v_template := exampleValue;
	
	if (match(valueof(v_template.a), 1) and
	    match(valueof(v_template.b), true)
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_012());
}


}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a template can be assigned to a template variable.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_014 {

type component GeneralComp { }

type record ExampleType {
	integer a,
	boolean b optional
}

template ExampleType exampleTemplate := {1, true};

testcase TC_Sem_1508_TemplateRestrictions_014() runs on GeneralComp {
	var template ExampleType v_template;
	
	v_template := exampleTemplate;
	
	if (match(valueof(v_template.a), 1) and
	    match(valueof(v_template.b), true)
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_014());
}


}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a template(present) can be assigned to a template variable.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_013 {

type component GeneralComp { }

type record ExampleType {
	integer a,
	boolean b optional
}

template(present) ExampleType examplePresent := {1, true};

testcase TC_Sem_1508_TemplateRestrictions_013() runs on GeneralComp {
	var template ExampleType v_template;
	
	v_template := examplePresent;
	
	if (match(valueof(v_template.a), 1) and
	    match(valueof(v_template.b), true)
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_013());
}


}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template(present) can be parameter to template(omit)
 ** @verdict  pass reject
 *****************************************************************/

module Sem_1508_TemplateRestrictions_048 {

    type record ExampleType {	// Exampletype record integer and a boolean
       	integer a,
	boolean b 
       }	
	
	type component GeneralComp {
	}



	template (omit) ExampleType m_baseTemplate(template integer MyintTemplate := 1) :={
		a := MyintTemplate,	 
		b := true
	}
	
	testcase TC_Sem_1508_TemplateRestrictions_048() runs on GeneralComp {
      
		
		if (ispresent(m_baseTemplate.a) == true) {
      		setverdict(pass);
		} else {
            setverdict(fail);
       }
 }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_048());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template(value) base templates are allowed to be modfied to template(present).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// ATTENTION: valid for TTCN-3:2013 (ETSI ES 201 873-1 V4.5.1) and newer
// Older versions of the core languate standard didn't allow this type of 
// modification because of restriction 15.8.c.

module Sem_1508_TemplateRestrictions_026 {

	type component GeneralComp { }
	
    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(value) ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }

    template(present) ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 21
    }

	testcase TC_Sem_1508_TemplateRestrictions_026() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 21) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_026());
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that the restrictiveness of parameters template(value)->template is handled correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// ATTENTION: valid for TTCN-3:2013 (ETSI ES 201 873-1 V4.5.1) and newer
// Older versions of the core languate standard didn't allow this type of 
// modification because of restriction 15.8.c.

/*
Pro opinion:
Test an intentional change made on the request of the STF160 in TTCN-3:2013. In particular, restriction 15.8.c was taken away from the core language specification (as marked in test case comments). This restriction did indeed mean that the tests would behave as you described, thus producing an error. However, with the restriction missing, the tests are perfectly valid. I also do not understand why you claim that it would not be possible to instantiate super-templates in these cases. Restrictions are always related to actual values and if the values satisfy both restrictions (parent and modified), there's no problem at all. And this is exactly what these test intend to verify.
Besides, the core language specification does not say that the parameters must be the same. There's a rule saying that the parameters shall not be omitted. It is rather unfortunate wording, because it might be interpreted in several ways. There's a CR 6692 regarding this issue.

Contra opinion
The problem is with the semantics of modified templates. For every actual parameter list, first, the template-to-be-modified is implicitly instantiated and then modified by the given modifications. If the template-to-be-modified is not defined for the actual parameters, then neither is the modified one. Of course, you are right in that this restriction could be applied for actual parameters only and need not be checked at the template-level already. However, it does not make sense to lessen the template restriction of a parameter, as implicitly, it still keeps the stronger restriction (because of the modification-semantics). Therefore, it is misleading to SEEMINGLY allow a template(present) parameter for a template where the super-template has a template(value) parameter. If allowed, the user might use a non-value template as an actual parameter and then get a runtime error, even though the template-restriction matched the one in the formal parameter of the template. Therefore, we interpret the standard in such a way that the inheritance of the parameters includes the inheritance of both the types and the template restrictions of the inherited parameters. Strengthening of template restrictions would indeed not be a problem. Lessening is.

*/

module Sem_1508_TemplateRestrictions_033 {

	type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(present) ExampleType m_baseTemplate(template(value) integer p_myInt) := {
        a := p_myInt,
        b := true
    }

    template(present) ExampleType m_modifiedTemplate(template integer p_myInt) modifies m_baseTemplate := {
        a := 21
    }

	testcase TC_Sem_1508_TemplateRestrictions_033() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate(1).a), 21) and
            match(valueof(m_modifiedTemplate(1).b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_033());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template(omit) base templates are allowed to be modfied to template(present).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// ATTENTION: valid for TTCN-3:2013 (ETSI ES 201 873-1 V4.5.1) and newer
// Older versions of the core languate standard didn't allow this type of 
// modification because of restriction 15.8.c.

module Sem_1508_TemplateRestrictions_025 {

    type component GeneralComp { }
	
	type record ExampleType {
        integer a,
        boolean b optional
    }

    template(omit) ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }

    template(present) ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 21
    }

	testcase TC_Sem_1508_TemplateRestrictions_025() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 21) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_025());
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that the restrictiveness of parameters template(value)->template(present) is handled correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// ATTENTION: valid for TTCN-3:2013 (ETSI ES 201 873-1 V4.5.1) and newer
// Older versions of the core languate standard didn't allow this type of 
// modification because of restriction 15.8.c.

/*
Pro opinion:
Test an intentional change made on the request of the STF160 in TTCN-3:2013. In particular, restriction 15.8.c was taken away from the core language specification (as marked in test case comments). This restriction did indeed mean that the tests would behave as you described, thus producing an error. However, with the restriction missing, the tests are perfectly valid. I also do not understand why you claim that it would not be possible to instantiate super-templates in these cases. Restrictions are always related to actual values and if the values satisfy both restrictions (parent and modified), there's no problem at all. And this is exactly what these test intend to verify.
Besides, the core language specification does not say that the parameters must be the same. There's a rule saying that the parameters shall not be omitted. It is rather unfortunate wording, because it might be interpreted in several ways. There's a CR 6692 regarding this issue.

Contra opinion
The problem is with the semantics of modified templates. For every actual parameter list, first, the template-to-be-modified is implicitly instantiated and then modified by the given modifications. If the template-to-be-modified is not defined for the actual parameters, then neither is the modified one. Of course, you are right in that this restriction could be applied for actual parameters only and need not be checked at the template-level already. However, it does not make sense to lessen the template restriction of a parameter, as implicitly, it still keeps the stronger restriction (because of the modification-semantics). Therefore, it is misleading to SEEMINGLY allow a template(present) parameter for a template where the super-template has a template(value) parameter. If allowed, the user might use a non-value template as an actual parameter and then get a runtime error, even though the template-restriction matched the one in the formal parameter of the template. Therefore, we interpret the standard in such a way that the inheritance of the parameters includes the inheritance of both the types and the template restrictions of the inherited parameters. Strengthening of template restrictions would indeed not be a problem. Lessening is.

*/

module Sem_1508_TemplateRestrictions_031 {

	type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(present) ExampleType m_baseTemplate(template(value) integer p_myInt) := {
        a := p_myInt,
        b := true
    }
	
    template(present) ExampleType m_modifiedTemplate(template(present) integer p_myInt) modifies m_baseTemplate := {
        a := 21
    }

	testcase TC_Sem_1508_TemplateRestrictions_031() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate(1).a), 21) and
            match(valueof(m_modifiedTemplate(1).b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_031());
    }
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a template(omit) can be assigned to a template(omit) variable.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_002 {

type component GeneralComp { }

type record ExampleType {
	integer a,
	boolean b optional
}

template(omit) ExampleType exampleOmit := omit;

testcase TC_Sem_1508_TemplateRestrictions_002() runs on GeneralComp {
	var template(omit) ExampleType v_omit;
	
	v_omit := exampleOmit;
	
	if ( ispresent(v_omit) ) {
		setverdict(fail);
	} else {
		setverdict(pass);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_002());
}


}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template (omit) can be parameter to template(present)
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_044 {

    type record ExampleType {	// Exampletype record integer and a boolean
       	integer a,
	boolean b 
       }	
	
	type component GeneralComp {
	}



	template (present) ExampleType m_baseTemplate(template (omit) integer MyintTemplate := 21) :={
		a := MyintTemplate,	 
		b := true
	}
	
	testcase TC_Sem_1508_TemplateRestrictions_044() runs on GeneralComp {
      
		
		if (ispresent(m_baseTemplate.a) == true) {
      		setverdict(pass);
		} else {
            setverdict(fail);
       }
 }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_044());
    }
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a value can be assigned to a template(value) variable.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_004 {

type component GeneralComp { }

testcase TC_Sem_1508_TemplateRestrictions_004() runs on GeneralComp {
	var template(value) integer v_value;
	
	v_value := 20;
	
	if (valueof(v_value) == 20) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_004());
}


}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a value can be assigned to a template(present) variable.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_006 {

type component GeneralComp { }

testcase TC_Sem_1508_TemplateRestrictions_006() runs on GeneralComp {
	var template(present) integer v_present;
	
	v_present := 20;
	
	if (valueof(v_present) == 20) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1508_TemplateRestrictions_006());
}


}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template(present) is accepted with a concrete value.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1508_TemplateRestrictions_004 {

type record ExampleType {
	integer a,
	boolean b optional
}

template(present) ExampleType exampleOmit := {1, true};

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that template(value) is accepted with a concrete value.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1508_TemplateRestrictions_003 {

type record ExampleType {
	integer a,
	boolean b optional
}

template(value) ExampleType exampleOmit := {1, true};

}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a template(present) base template can be modified with template(value) restriction.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_020 {

    type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(present) ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }

    template(value) ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 22
    }

    testcase TC_Sem_1508_TemplateRestrictions_020() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 22) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_020());
    }


}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that the restrictiveness of parameters template(omit)->template(present) is handled correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// ATTENTION: valid for TTCN-3:2013 (ETSI ES 201 873-1 V4.5.1) and newer
// Older versions of the core languate standard didn't allow this type of 
// modification because of restriction 15.8.c.

/*
Pro opinion:
Test an intentional change made on the request of the STF160 in TTCN-3:2013. In particular, restriction 15.8.c was taken away from the core language specification (as marked in test case comments). This restriction did indeed mean that the tests would behave as you described, thus producing an error. However, with the restriction missing, the tests are perfectly valid. I also do not understand why you claim that it would not be possible to instantiate super-templates in these cases. Restrictions are always related to actual values and if the values satisfy both restrictions (parent and modified), there's no problem at all. And this is exactly what these test intend to verify.
Besides, the core language specification does not say that the parameters must be the same. There's a rule saying that the parameters shall not be omitted. It is rather unfortunate wording, because it might be interpreted in several ways. There's a CR 6692 regarding this issue.

Contra opinion
The problem is with the semantics of modified templates. For every actual parameter list, first, the template-to-be-modified is implicitly instantiated and then modified by the given modifications. If the template-to-be-modified is not defined for the actual parameters, then neither is the modified one. Of course, you are right in that this restriction could be applied for actual parameters only and need not be checked at the template-level already. However, it does not make sense to lessen the template restriction of a parameter, as implicitly, it still keeps the stronger restriction (because of the modification-semantics). Therefore, it is misleading to SEEMINGLY allow a template(present) parameter for a template where the super-template has a template(value) parameter. If allowed, the user might use a non-value template as an actual parameter and then get a runtime error, even though the template-restriction matched the one in the formal parameter of the template. Therefore, we interpret the standard in such a way that the inheritance of the parameters includes the inheritance of both the types and the template restrictions of the inherited parameters. Strengthening of template restrictions would indeed not be a problem. Lessening is.

*/

module Sem_1508_TemplateRestrictions_036 {

	type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template(present) ExampleType m_baseTemplate(template(present) integer p_myInt) := {
        a := p_myInt,
        b := true
    }

    template(present) ExampleType m_modifiedTemplate(template integer p_myInt) modifies m_baseTemplate := {
        a := 21
    }

	testcase TC_Sem_1508_TemplateRestrictions_036() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate(1).a), 21) and
            match(valueof(m_modifiedTemplate(1).b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_036());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.8, Ensure that a base template can be modified with template(present) restriction.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1508_TemplateRestrictions_016 {

    type component GeneralComp { }

    type record ExampleType {
        integer a,
        boolean b optional
    }

    template ExampleType m_baseTemplate := {
        a := 20,
        b := true
    }

    template(present) ExampleType m_modifiedTemplate modifies m_baseTemplate := {
        a := 22
    }

    testcase TC_Sem_1508_TemplateRestrictions_016() runs on GeneralComp {
        if (match(valueof(m_modifiedTemplate.a), 22) and
            match(valueof(m_modifiedTemplate.b), true)
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_1508_TemplateRestrictions_016());
    }


}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.1, Ensure that a simple record-based message template with a wildcard ? is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1501_DeclaringMessageTemplates_002 {

type record MyMessageType {
	integer field1 optional
}

template MyMessageType m_myTemplate := { 
	field1 := ?
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.1, Ensure that a primitive type template can be defined with a ? wildcard.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1501_DeclaringMessageTemplates_004 {

template integer m_myTemplate := ?;

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.1, Ensure that all port operations are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1501_DeclaringMessageTemplates_006 {

    type port MyMessagePortType message {
        inout MyMessageType
    }

    type component GeneralComp {
        port MyMessagePortType pt_myPort;
    }

    type record MyMessageType {
        integer field1 optional,
        charstring field2,
        boolean field3
    }

    template MyMessageType m_myTemplate := {
        field1 := omit,
        field2 := "My string",
        field3 := true
    }

    testcase TC_Syn_1501_DeclaringMessageTemplates_006() runs on GeneralComp {
        pt_myPort.send(m_myTemplate);
        pt_myPort.receive(m_myTemplate);
        pt_myPort.trigger(m_myTemplate);
        pt_myPort.check(receive(m_myTemplate));
        setverdict(pass);
    }

    control{
        execute(TC_Syn_1501_DeclaringMessageTemplates_006());
    }

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.1, Ensure that a simple record-based message template can be defined with a pattern in a charstring field.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1501_DeclaringMessageTemplates_003 {

type record MyMessageType {
	charstring field2
}

template MyMessageType m_myTemplate := { 
	field2 := pattern "abc*xyz"
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.1, Ensure that a simple record-based message template can be defined.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1501_DeclaringMessageTemplates_001 {

type record MyMessageType {
	integer field1 optional,
	charstring field2,
	boolean field3
}

template MyMessageType m_myTemplate := { 
	field1 := omit,
	field2 := "My string",
	field3 := true 
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.1, Ensure that a primitive type template can be defined with a one-of notation.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1501_DeclaringMessageTemplates_005 {

template integer m_myTemplate := (1, 2, 3);

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15, Ensure that a simple template with a single charstring field is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_15_TopLevel_001 {

type record MyRecord {
	charstring field1
}

template MyRecord m_myTemplate := { 
	field1 := "Hello World!" 
}

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.6.4, Test modification of signature parameters.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_150604_ReferencingSignatureParameters_001 {

/**
 * @desc testing of inline return template for remote procedure call
 * @param p_par1 only input parameter
 * @param p_par2 must have value 4 at return
 * @param p_par3 must have value 5 at return
 * @return must return value 1
 */
 
signature p_Sem_150604_ReferencingSignatureParameters_001(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

template p_Sem_150604_ReferencingSignatureParameters_001 s_baseTemplate := { 
	p_par1 := -,
	p_par2 := 4,
	p_par3 := ?
}

template p_Sem_150604_ReferencingSignatureParameters_001 s_returnTemplate modifies s_baseTemplate := { 
	p_par3 := 5
}

template p_Sem_150604_ReferencingSignatureParameters_001 s_wrongTemplate modifies s_baseTemplate := { 
	p_par3 := 3
}

template p_Sem_150604_ReferencingSignatureParameters_001 s_callTemplate := { 
	p_par1 := 1,
	p_par2 := -,
	p_par3 := 3
}

    type port remotePort procedure {
    	out p_Sem_150604_ReferencingSignatureParameters_001;
	}

type component GeneralComp {	    	    
	  port remotePort PCO;
}	

testcase TC_Sem_150604_ReferencingSignatureParameters_001() runs on GeneralComp {
	
 PCO.call(p_Sem_150604_ReferencingSignatureParameters_001:s_callTemplate, 5.0) {
	
	[] PCO.getreply(p_Sem_150604_ReferencingSignatureParameters_001:s_wrongTemplate value 1) {		
		setverdict(fail);
	} 
	[] PCO.getreply(p_Sem_150604_ReferencingSignatureParameters_001:s_returnTemplate value 2) {		
		setverdict(fail);
	} 
	[] PCO.getreply(p_Sem_150604_ReferencingSignatureParameters_001:s_returnTemplate value 1) {		//check that procedure is returning correct values
		setverdict(pass);
	} 
	[] PCO.catch (timeout) {
		setverdict(fail);
	}
 }
}

control{
    execute(TC_Sem_150604_ReferencingSignatureParameters_001());
}

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.6.2, ? shall be returned for mandatory subfields and * shall be returned for optional subfields.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_150602_ReferencingRecordAndSetFields_001 {

    type component GeneralComp { }

    type record MyRecordTwo {
        integer g1,
        MyRecordTwo g2 optional
    }

    type record MyRecordOne {
        integer f1 optional,
        MyRecordTwo f2 optional
    }

    testcase TC_Sem_150602_ReferencingRecordAndSetFields_001() runs on GeneralComp {
        var template MyRecordOne m_R1 := {
            f1 := 0,
            f2 := ?
        }

        // m_R2.g1 is mandatory, therefore it shall be ?
        // m_R2.g2 is optional, therefore it shall be *
        var template MyRecordTwo m_R2 := m_R1.f2;
 
        var template(value) MyRecordTwo m_value := {
            g1 := 5,
            g2 := omit
        }

        // match against ?
        var boolean v_matchRes1 := match(5, m_R2.g1);


        if (v_matchRes1) {
            setverdict(pass);
        } else {
            setverdict(fail, "match against ?");
        }

    }

    control{
        execute(TC_Sem_150602_ReferencingRecordAndSetFields_001());
    }


}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.6.2, Ensure that the recurisve anyvalue expansion is performed correctly when new values are assigned.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_150602_ReferencingRecordAndSetFields_002 {

type component GeneralComp { }

type record MyRecordTwo {
	integer g1,
	MyRecordTwo g2 optional
}

type record MyRecordOne {
	integer f1 optional,
	MyRecordTwo f2 optional
}

testcase TC_Sem_150602_ReferencingRecordAndSetFields_002() runs on GeneralComp {
	var template MyRecordOne m_R1 := {
		f1 := 0,
		f2 := ?
	}

	m_R1.f2.g2.g2 := {g1:=1, g2:=omit};
	// as f2 is ? and we access g2.g2, TTCN-3 should expand the following fields to
	// contain the following values:
	// m_R1.f1 = 0
	// m_R1.f2 = {
	//   g1 = ?
	//   g2 = {
	//     g1 = ?,
	//     g2 = {
	//       g1 = 1
	//       g2 = omit
	//     }
	//   }
	// }

	if (match(valueof(m_R1.f1), 0) and 
     ispresent(m_R1.f2.g2) and
	 ispresent(m_R1.f2.g2.g2) and
	 ( ispresent(m_R1.f2.g2.g2.g2) == false) and
	 match( valueof(m_R1.f2.g2.g2.g1), 1 )
    ) { 
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_150602_ReferencingRecordAndSetFields_002());
}


}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.6.2, ? shall be returned for mandatory subfields and * shall be returned for optional subfields.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_150602_ReferencingRecordAndSetFields_003 {

    type component GeneralComp { }

    type record MyRecordTwo {
        integer g1,
        MyRecordTwo g2 optional
    }

    type record MyRecordOne {
        integer f1 optional,
        MyRecordTwo f2 optional
    }

    testcase TC_Sem_150602_ReferencingRecordAndSetFields_003() runs on GeneralComp {
        var boolean v_matchRes;
        var template MyRecordOne m_R1 := {
            f1 := 0,
            f2 := ?
        }

        // m_R2.g1 is mandatory, therefore it shall be ?
        // m_R2.g2 is optional, therefore it shall be *
        var template MyRecordTwo m_R2 := m_R1.f2;
        var template(value) MyRecordTwo m_value := {
            g1 := 5,
            g2 := omit
        }

        // match against {?, *}
        v_matchRes := match(m_value, MyRecordTwo:{m_R2.g1, m_R2.g2});


        if (v_matchRes) {
            setverdict(pass);
        } else {
            setverdict(fail, "match against {?, *}");
        }

    }

    control{
        execute(TC_Sem_150602_ReferencingRecordAndSetFields_003());
    }


}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.6.2, ? shall be returned for mandatory subfields and * shall be returned for optional subfields.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_150602_ReferencingRecordAndSetFields_004 {

    type component GeneralComp { }

    type record MyRecordTwo {
        integer g1,
        MyRecordTwo g2 optional
    }

    type record MyRecordOne {
        integer f1 optional,
        MyRecordTwo f2 optional
    }

    testcase TC_Sem_150602_ReferencingRecordAndSetFields_004() runs on GeneralComp {
        var template MyRecordOne m_R1 := {
            f1 := 0,
            f2 := ?
        }

        // m_R2.g1 is mandatory, therefore it shall be ?
        // m_R2.g2 is optional, therefore it shall be *
        var template MyRecordTwo m_R2 := m_R1.f2;
 
        var template(value) MyRecordTwo m_value := {
            g1 := 5,
            g2 := omit
        }

        // match against {?, *} - use dotted notation to cover other expansion thread
        var boolean v_matchRes := match(m_value, MyRecordTwo:{m_R1.f2.g1, m_R1.f2.g2});


        if (v_matchRes) {
            setverdict(pass);
        } else {
            setverdict(fail, "match against {?, *} - use dotted notation to cover other expansion thread");
        }
    }

    control{
        execute(TC_Sem_150602_ReferencingRecordAndSetFields_004());
    }


}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.6.5, Ensure that template variables allow referencing with an Anyvalue union template
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
 
//Restriction b)
/*when referencing an alternative of a union template or template field to which AnyValue is
assigned, at the right hand side of an assignment, AnyValue shall be returned.*/

module Sem_150605_Referencing_union_alternatives_003 {

    type union My_Union {
        integer   u1,
        float     u2
    }
    
    type record ExampleType {	// Exampletype record with union
	    integer a,
	    My_Union b 
       }
       
    type port loopbackPort message{inout ExampleType};
	

    type component GeneralComp {	    	    
	  port loopbackPort messagePort
    }	


    testcase TC_Sem_150605_Referencing_union_alternatives_003() runs on GeneralComp {
    
    var template ExampleType m_template;
    var template ExampleType m_template_2;

    //assign values to template:
    
		m_template.a:=10;	
		m_template.b := ?;

		m_template_2 := m_template;	
		
		m_template_2.b.u1:=1;
		
    
      if (match(valueof(m_template_2),{a := 10,b :={u1 := 1}}))
	    {
		setverdict(pass,m_template_2);
	} else {
		setverdict(fail,m_template_2);
	}

 }

    control{
        execute(TC_Sem_150605_Referencing_union_alternatives_003());
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.6.5, Ensure that template variables allow referencing with an Anyvalue union template
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
 
//Restriction a)
/*When referencing an alternative of a union template or template field to which AnyValueOrNone or omit is
assigned, at the left hand side of an assignment, the template field is implicitly set to be present and the
referenced alternative becomes the chosen one.*/

module Sem_150605_Referencing_union_alternatives_004 {

    type union My_Union {
        integer   u1,
        float     u2
    }
    
    type record ExampleType {	// Exampletype record with union
	    integer a,
	    My_Union b optional 
       }
       
    type port loopbackPort message{inout ExampleType};
	

    type component GeneralComp {	    	    
	  port loopbackPort messagePort
    }	


    testcase TC_Sem_150605_Referencing_union_alternatives_004() runs on GeneralComp {
    

    


    var template ExampleType m_template;
    var template ExampleType m_template_2;

    //assign values to template:
    
		m_template.a:=10;	
		m_template.b := omit;

		m_template_2 := m_template;	
		
		m_template_2.b.u1:=1;
		
    
      if (match(valueof(m_template_2),{a := 10,b :={u1 := 1}}))
	    {
		setverdict(pass,m_template_2);
	} else {
		setverdict(fail,m_template_2);
	}

 }

    control{
        execute(TC_Sem_150605_Referencing_union_alternatives_004());
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.6.5, Ensure that template variables allow referencing with an Anyvalue union template
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
 
//Restriction b)
/*when referencing an alternative of a union template or template field to which AnyValue is
assigned, at the right hand side of an assignment, AnyValue shall be returned.*/

module Sem_150605_Referencing_union_alternatives_002{

    type union My_Union {
        integer   u1,
        float     u2
    }
    
    type record ExampleType {	// Exampletype record with union
	    integer a,
	    My_Union b optional
       }
       
    type port loopbackPort message{inout ExampleType};
	

    type component GeneralComp {	    	    
	  port loopbackPort messagePort
    }	


    testcase TC_Sem_150605_Referencing_union_alternatives_002() runs on GeneralComp {
    

    


    var template ExampleType m_template;
    var template integer m_template_2;

    //assign values to template:
    
		m_template.a:=10;	
		m_template.b := ?;

		m_template_2 := m_template.b.u1;	//m_template_2 :=?
    
      if (ispresent(m_template_2))
	    {
		setverdict(pass,m_template_2);
	} else {
		setverdict(fail,m_template_2);
	}

 }

    control{
        execute(TC_Sem_150605_Referencing_union_alternatives_002());
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.6.5, Ensure that template variables allow referencing alternatives inside a union template definition
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_150605_Referencing_union_alternatives_001 {

    type union My_Union {
        integer   u1,
        float     u2
    }
    
    type record ExampleType {	// Exampletype record with union
	    integer a,
	    My_Union b 
       }
       
    type port loopbackPort message{inout ExampleType};
	

    type component GeneralComp {	    	    
	  port loopbackPort messagePort
    }	


    testcase TC_Sem_150605_Referencing_union_alternatives_001() runs on GeneralComp {
    

    

    var template ExampleType m_template;

    //assign values to template:
    
		m_template.a:=10;	
		m_template.b.u1:=1;
		m_template.b.u2:=2.0;
  
  
  messagePort.send(m_template);	//send message

    alt {
     [] messagePort.receive(m_template) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }


 }

    control{
        execute(TC_Sem_150605_Referencing_union_alternatives_001());
    }
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.6.3, Ensure that assignment to a anyvalue in the context of record of is handled correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_150603_ReferencingRecordOfAndSetElements_002 {

    type component GeneralComp { }

    type record of integer RoI;

    testcase TC_Sem_150603_ReferencingRecordOfAndSetElements_002() runs on GeneralComp {
        var template RoI m_one;
    
        m_one := ?;
        m_one[2] := 2;
        // assignment should yield {?,?,2,*}
    
        if (not match(5,m_one[0])) {
            setverdict(fail);
        }
        if (not match(5,m_one[1])) {
            setverdict(fail);
        }
        if (not match(2,m_one[2])) {
            setverdict(fail);
        }

        setverdict(pass);
    }

    control{
        execute(TC_Sem_150603_ReferencingRecordOfAndSetElements_002());
    }



}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.6.3, Ensure that assignment to a anyvalue in the context of record of is handled correctly when the first element is changed.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_150603_ReferencingRecordOfAndSetElements_004 {

	type component GeneralComp { }

	type record of integer RoI;

	testcase TC_Sem_150603_ReferencingRecordOfAndSetElements_004() runs on GeneralComp {
		var template RoI m_one;
	
		m_one := ?;
		m_one[0] := 2;
		// assignment should yield {2,*}
	
		if (not match(2,m_one[0])) {
			setverdict(fail);
		}

		setverdict(pass);
	}

	control{
		execute(TC_Sem_150603_ReferencingRecordOfAndSetElements_004());
	}



}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.6.3, Ensure that access outside permutation fields is allowed and works as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_150603_ReferencingRecordOfAndSetElements_005 {

    type component GeneralComp { }

    type record of integer RoI;

    testcase TC_Sem_150603_ReferencingRecordOfAndSetElements_005() runs on GeneralComp {
        var template RoI m_one;
        var template integer m_two;
	
        m_one := {permutation(0,1,3,?),2,?};
        // assignment should yield ?
        m_two := m_one[5];
	
        if (match(5,m_two)) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_150603_ReferencingRecordOfAndSetElements_005());
    }



}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.6.3, Ensure that referencing an element within a record of, set of or array field to which omit is assigned works as expected
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Restriction a)
/*Omit: referencing an element within a record of, set of or array field to which omit is assigned shall follow the rules specified in clause 6.2.3.*/


module Sem_150603_ReferencingRecordOfAndSetElements_006 {

    type component GeneralComp { }

    type record of integer RoI;

    testcase TC_Sem_150603_ReferencingRecordOfAndSetElements_006() runs on GeneralComp {
        var template RoI m_one;
        var template RoI m_two := {6};
	
        m_one := {1,-,3};
        // assignment should yield omit
        m_two := m_one;
	
        if (ispresent(m_two)) {
            setverdict(pass,m_two);
        } else {
            setverdict(fail,m_two);
        }
    }

    control{
        execute(TC_Sem_150603_ReferencingRecordOfAndSetElements_006());
    }



}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.6.3, Ensure that referencing an element within a record of, set of or array field to which omit is assigned works as expected
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

 //Restriction g)
/*  AnyElementsOrNone: when referencing an element of a record of or set of template or field that contains AnyElementsOrNone, the result of an operation
 *  is dependent on the position of AnyElementsOrNone, the referenced index and length attributes attached to AnyElementsOrNone.
*/


module Sem_150603_ReferencingRecordOfAndSetElements_002 {

    type component GeneralComp { }

    type record of integer RoI;

    testcase TC_Sem_150603_ReferencingRecordOfAndSetElements_007() runs on GeneralComp {
        var template RoI m_one;
    
        m_one := {1,?, * length(1..3), 5};
        m_one[1] := 2;
        m_one[2] := 2;
        
        // assignment should yield {1,2,2,?,?,5}
    
        if (not match(1,m_one[0])) {
            setverdict(fail,m_one);
        }
        if (not match(2,m_one[1])) {
            setverdict(fail,m_one);
        }
        if (not match(2,m_one[2])) {
            setverdict(fail,m_one);
        }

        setverdict(pass);
    }

    control{
        execute(TC_Sem_150603_ReferencingRecordOfAndSetElements_007());
    }

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.6.3, Ensure that assignment to a anyvalue in the context of record of is handled correctly in two subsequent assignments.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_150603_ReferencingRecordOfAndSetElements_003 {

    type component GeneralComp { }

    type record of integer RoI;

    testcase TC_Sem_150603_ReferencingRecordOfAndSetElements_003() runs on GeneralComp {
        var template RoI m_one;
	
        m_one := ?;
        m_one[2] := 2;
        // assignment should yield {?,?,2,*}
        m_one[4] := 3;
        // assignment should yield {?,?,2,?,3,*}
	
        if (match(5,m_one[0]) and
            match(5,m_one[1]) and
            match(2,m_one[2]) and
            match(5,m_one[3]) and
            match(3,m_one[4])
        ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_150603_ReferencingRecordOfAndSetElements_003());
    }



}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.6.3, Ensure that assignment of an anyvalue on the right hand side yields an anyvalue in the context of record of.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_150603_ReferencingRecordOfAndSetElements_001 {

    type component GeneralComp { }

    type record of integer RoI;

    testcase TC_Sem_150603_ReferencingRecordOfAndSetElements_001() runs on GeneralComp {
        var template RoI m_one;
        var template RoI m_two;
	
        m_one := {0,?,2};
        m_two := {0,1,2};
        m_two[1] := m_one[1];
	
        if (match(5,m_two[1])) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_150603_ReferencingRecordOfAndSetElements_001());
    }



}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.2, Ensure that signature templates with explicit values are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1502_DeclaringSignatureTemplates_001 {

    signature p_Syn_1502_DeclaringSignatureTemplates_001(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Syn_1502_DeclaringSignatureTemplates_001 s_myTemplate := {
        p_par1 := 1,
        p_par2 := 2,
        p_par3 := 3
    }

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.2, Ensure that signature templates with wildcards are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1502_DeclaringSignatureTemplates_002 {

    signature p_Syn_1502_DeclaringSignatureTemplates_002(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Syn_1502_DeclaringSignatureTemplates_002 s_myTemplate := {
        p_par1 := 1,
        p_par2 := ?,
        p_par3 := ?
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.2, Test in-line templates for accepting procedure replies.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1502_DeclaringSignatureTemplates_002 {

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return can return value any value
    */
    signature p_Sem_1502_DeclaringSignatureTemplates_002(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Sem_1502_DeclaringSignatureTemplates_002 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_1502_DeclaringSignatureTemplates_002 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_1502_DeclaringSignatureTemplates_002 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_1502_DeclaringSignatureTemplates_002;
    }

    type component GeneralComp {
        port remotePort PCO;
    }

    function f_ClientQuery() runs on GeneralComp {
	
        PCO.call(p_Sem_1502_DeclaringSignatureTemplates_002:s_callTemplate, 5.0) {
	
            [] PCO.getreply(p_Sem_1502_DeclaringSignatureTemplates_002:s_wrongTemplate value ?) {
                setverdict(fail);
            }
            [] PCO.getreply(p_Sem_1502_DeclaringSignatureTemplates_002:s_returnTemplate value ?) {		//check that procedure is returning correct values
                setverdict(pass);
            }
            [] PCO.catch (timeout) {
                setverdict(fail);
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
	
	var integer v_par1;
	var integer v_par3;
	timer t_timeout:=30.0;
		
	template p_Sem_1502_DeclaringSignatureTemplates_002 s_acceptTemplate := {
        p_par1 := ?,
        p_par2 := ?,
        p_par3 := ?
    };

		
	t_timeout.start;
	
	 alt {
      [] PCO.getcall(p_Sem_1502_DeclaringSignatureTemplates_002:s_acceptTemplate) -> param(v_par1, - , v_par3) {
        PCO.reply(p_Sem_1502_DeclaringSignatureTemplates_002:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1);  	//procedure return values are sent
		repeat;
	  }
      [] t_timeout.timeout {
        setverdict(fail);
      }
	 }
	 
    }

	
	testcase TC_Sem_1502_DeclaringSignatureTemplates_002() runs on GeneralComp system GeneralComp {
       var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
       var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
       // map the PTCs to the system port
       connect(server:PCO, client:PCO);

       server.start(f_ServerResponses());
       client.start(f_ClientQuery());

       alt {
           [] client.done {
               server.stop;
           }
       }

       alt {
           [] all component.done {}
       }

       disconnect(server:PCO);
   }

    control{
        execute(TC_Sem_1502_DeclaringSignatureTemplates_002());
    }

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.2, Ensure that the basic operations call and getreply are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1502_DeclaringSignatureTemplates_003 {

    type port MyProcedurePortType procedure {
        inout p_Syn_1502_DeclaringSignatureTemplates_003;
    }

    type component GeneralComp {
        port MyProcedurePortType pt_myPort;
    }

    signature p_Syn_1502_DeclaringSignatureTemplates_003(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Syn_1502_DeclaringSignatureTemplates_003 m_myTemplate := {
        p_par1 := 1,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Syn_1502_DeclaringSignatureTemplates_003 mw_myTemplate := {
        p_par1 := 1,
        p_par2 := ?,
        p_par3 := ?
    }

    testcase TC_Syn_1502_DeclaringSignatureTemplates_003() runs on GeneralComp {
        pt_myPort.call(p_Syn_1502_DeclaringSignatureTemplates_003:m_myTemplate, nowait);
        pt_myPort.getreply(p_Syn_1502_DeclaringSignatureTemplates_003:m_myTemplate);
        setverdict(pass);
    }

    control{
        execute(TC_Syn_1502_DeclaringSignatureTemplates_003());
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.2, Test in-line templates for accepting procedure replies.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1502_DeclaringSignatureTemplates_003 {

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return can return value any value
    */
    signature p_Sem_1502_DeclaringSignatureTemplates_003(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Sem_1502_DeclaringSignatureTemplates_003 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_1502_DeclaringSignatureTemplates_003 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_1502_DeclaringSignatureTemplates_003 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_1502_DeclaringSignatureTemplates_003;
    }

    type component GeneralComp {
        port remotePort PCO;
    }

    function f_ClientQuery() runs on GeneralComp {
	
        PCO.call(p_Sem_1502_DeclaringSignatureTemplates_003:s_callTemplate, 5.0) {
	
            [] PCO.getreply(p_Sem_1502_DeclaringSignatureTemplates_003:?) {		//any reply is accepted
                setverdict(pass);
            }
            [] PCO.catch (timeout) {
                setverdict(fail);
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
	
	var integer v_par1;
	var integer v_par3;
	timer t_timeout:=30.0;
		
	template p_Sem_1502_DeclaringSignatureTemplates_003 s_acceptTemplate := {
        p_par1 := ?,
        p_par2 := ?,
        p_par3 := ?
    };

		
	t_timeout.start;
	
	 alt {
      [] PCO.getcall(p_Sem_1502_DeclaringSignatureTemplates_003:s_acceptTemplate) -> param(v_par1, - , v_par3) {
        PCO.reply(p_Sem_1502_DeclaringSignatureTemplates_003:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1);  	//procedure return values are sent
		repeat;
	  }
      [] t_timeout.timeout {
        setverdict(fail);
      }
	 }
	 
    }

	
	testcase TC_Sem_1502_DeclaringSignatureTemplates_003() runs on GeneralComp system GeneralComp {
       var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
       var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
       // map the PTCs to the system port
       connect(server:PCO, client:PCO);

       server.start(f_ServerResponses());
       client.start(f_ClientQuery());

       alt {
           [] client.done {
               server.stop;
           }
       }

       alt {
           [] all component.done {}
       }

       disconnect(server:PCO);
   }

    control{
        execute(TC_Sem_1502_DeclaringSignatureTemplates_003());
    }

}
/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.2, Test in-line templates for accepting procedure replies.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1502_DeclaringSignatureTemplates_001 {

    /**
    * @desc testing of inline return template for remote procedure call
    * @param p_par1 only input parameter
    * @param p_par2 must have value 4 at return
    * @param p_par3 must have value 5 at return
    * @return must return value 1
    */
    signature p_Sem_1502_DeclaringSignatureTemplates_001(in integer p_par1, out integer p_par2, inout integer p_par3) return integer;

    template p_Sem_1502_DeclaringSignatureTemplates_001 s_returnTemplate := {
        p_par1 := -,
        p_par2 := 4,
        p_par3 := 5
    }

    template p_Sem_1502_DeclaringSignatureTemplates_001 s_wrongTemplate := {
        p_par1 := -,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Sem_1502_DeclaringSignatureTemplates_001 s_callTemplate := {
        p_par1 := 1,
        p_par2 := -,
        p_par3 := 3
    }

    type port remotePort procedure {
        inout p_Sem_1502_DeclaringSignatureTemplates_001;
    }

    type component GeneralComp {
        port remotePort PCO;
    }

    function f_ClientQuery() runs on GeneralComp {
	
        PCO.call(p_Sem_1502_DeclaringSignatureTemplates_001:s_callTemplate, 5.0) {
	
            [] PCO.getreply(p_Sem_1502_DeclaringSignatureTemplates_001:s_wrongTemplate value 1) {
                setverdict(fail);
            }
            [] PCO.getreply(p_Sem_1502_DeclaringSignatureTemplates_001:s_returnTemplate value 2) {
                setverdict(fail);
            }
            [] PCO.getreply(p_Sem_1502_DeclaringSignatureTemplates_001:s_returnTemplate value 1) {		//check that procedure is returning correct values
                setverdict(pass);
            }
            [] PCO.catch (timeout) {
                setverdict(fail);
            }
        }
    }

    function f_ServerResponses() runs on GeneralComp {
	
	var integer v_par1;
	var integer v_par3;
	timer t_timeout:=30.0;
		
	template p_Sem_1502_DeclaringSignatureTemplates_001 s_acceptTemplate := {
        p_par1 := ?,
        p_par2 := ?,
        p_par3 := ?
    };

		
	t_timeout.start;
	
	 alt {
      [] PCO.getcall(p_Sem_1502_DeclaringSignatureTemplates_001:s_acceptTemplate) -> param(v_par1, - , v_par3) {
        PCO.reply(p_Sem_1502_DeclaringSignatureTemplates_001:{p_par1 := -, p_par2 := v_par1+v_par3, p_par3 := v_par1+v_par3+1} value v_par1);  	//procedure return values are sent
		repeat;
	  }
      [] t_timeout.timeout {
        setverdict(fail);
      }
    }
  }

	
	testcase TC_Sem_1502_DeclaringSignatureTemplates_001() runs on GeneralComp system GeneralComp {
       var GeneralComp server := GeneralComp.create("RemoteProcedure Service");
       var GeneralComp client := GeneralComp.create("RemoteProcedure Client");
       // map the PTCs to the system port
       connect(server:PCO, client:PCO);

       server.start(f_ServerResponses());
       client.start(f_ClientQuery());

       alt {
           [] client.done {
               server.stop;
           }
       }

       alt {
           [] all component.done {}
       }

       disconnect(server:PCO);
   }

    control{
        execute(TC_Sem_1502_DeclaringSignatureTemplates_001());
    }

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.2, Ensure that the raise and catch operations are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1502_DeclaringSignatureTemplates_004 {

    type port MyProcedurePortType procedure {
        inout p_Syn_1502_DeclaringSignatureTemplates_004;
    }

    type component GeneralComp {
        port MyProcedurePortType pt_myPort;
    }

    signature p_Syn_1502_DeclaringSignatureTemplates_004(in integer p_par1, out integer p_par2, inout integer p_par3) return integer exception (integer);

    template p_Syn_1502_DeclaringSignatureTemplates_004 m_myTemplate := {
        p_par1 := 1,
        p_par2 := 2,
        p_par3 := 3
    }

    template p_Syn_1502_DeclaringSignatureTemplates_004 mw_myTemplate := {
        p_par1 := 1,
        p_par2 := ?,
        p_par3 := ?
    }

    testcase TC_Syn_1502_DeclaringSignatureTemplates_004() runs on GeneralComp {
        pt_myPort.raise(p_Syn_1502_DeclaringSignatureTemplates_004, integer:5);
        pt_myPort.catch(p_Syn_1502_DeclaringSignatureTemplates_004, integer:5);
        setverdict(pass);
    }

    control{
        execute(TC_Syn_1502_DeclaringSignatureTemplates_004());
    }

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.5, Ensure that default values in formal parameters of modified templates are working as expected when the modified template uses the dash for the default value.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1505_ModifiedTemplates_004 {

type component GeneralComp { }

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3
}

template MyMessageType m_templateOne(integer p_intValue:=2) := {
	field1 := p_intValue,
	field2 := "Hello World",
	field3 := true
}

template MyMessageType m_templateTwo(integer p_intValue := -) modifies m_templateOne := {  
	field1 := p_intValue
}

testcase TC_Sem_1505_ModifiedTemplates_004() runs on GeneralComp {
	if (match(valueof(m_templateTwo.field1), 2) and
	    match(valueof(m_templateTwo.field2), "Hello World") and
	    match(valueof(m_templateTwo.field3), true)
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1505_ModifiedTemplates_004());
}

}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.5, Ensure that default values in formal parameters of modified templates are working as expected
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Restriction a)
/*In case of templates, template fields or list elements of simple types, union and enumerated types, the
matching mechanism specified in the modified template is simply replacing its corresponding content in its
parent.*/

module Sem_1505_ModifiedTemplates_006 {

type component GeneralComp { }

    
type enumerated MyEnum  {
	A,B,C
}

type record MyMessageType {
  integer field1,
  MyEnum  field2
}

template MyMessageType m_templateOne := {
	field1 :=10,
	field2 := A	//enum type
}

template MyMessageType m_templateTwo(MyEnum p_intValue := B) modifies m_templateOne := {  
	field2 := p_intValue
}

testcase TC_Sem_1505_ModifiedTemplates_006() runs on GeneralComp {
	if (match(valueof(m_templateTwo.field2) , B) and match(valueof(m_templateTwo.field1) , 10)) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1505_ModifiedTemplates_006());
}

}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.5, Ensure that default values in formal parameters of modified templates are working as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
 
//Restriction c)
/*if the value list notation is used, only the number of elements listed in the modified template is inherited
from the parent (i.e. the list is truncated at the last element of the list notation in the modified template)*/

module Sem_1505_ModifiedTemplates_009 {

type component GeneralComp { }

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3,
	charstring field4
}

template MyMessageType m_templateOne := {
	field1 := 1,
	field2 := "Hello World",
	field3 := true,
	field4 := "Hello World2"
}

template MyMessageType m_templateTwo modifies m_templateOne := { -, "ABC", false}	//field 4 is not inherited from the parent

testcase TC_Sem_1505_ModifiedTemplates_009() runs on GeneralComp {
	if (
	   (match(valueof(m_templateOne.field1),1)) and
	   (match(valueof(m_templateTwo.field2),"ABC")) and
	   (match(valueof(m_templateTwo.field3), false)) and
	   (match(valueof(m_templateTwo.field4),"<undefined>"))	 
	    ){
		setverdict(pass,m_templateTwo.field4);
	} else {
		setverdict(fail,m_templateTwo.field4);
	}
}

control{
    execute(TC_Sem_1505_ModifiedTemplates_009());
}

}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.5, Ensure that default values in formal parameters of modified templates are working as expected
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

 //Restriction a)
/*In case of templates, template fields or list elements of simple types, union and enumerated types, the
matching mechanism specified in the modified template is simply replacing its corresponding content in its
parent.*/

module Sem_1505_ModifiedTemplates_005 {

type component GeneralComp { }

type union MyMessageType {
	integer field
}

template MyMessageType m_templateOne := {	//union type
	field :=2
}

template MyMessageType m_templateTwo(integer p_intValue := 10) modifies m_templateOne := {  
	field := p_intValue
}

testcase TC_Sem_1505_ModifiedTemplates_005() runs on GeneralComp {
	if (match(valueof(m_templateTwo.field) , 10) ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1505_ModifiedTemplates_005());
}

}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.5, Ensure that default values in formal parameters of modified templates are working as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
 
//Restriction c)
/*if the value list notation is used, only the number of elements listed in the modified template is inherited
from the parent (i.e. the list is truncated at the last element of the list notation in the modified template)*/

module Sem_1505_ModifiedTemplates_010 {

type component GeneralComp { }

type set MyMessageType {
	integer field1,
	charstring field2,
	boolean field3,
	charstring field4
}

template MyMessageType m_templateOne := {
	field1 := 1,
	field2 := "Hello World",
	field3 := true,
	field4 := "Hello World2"
}

template MyMessageType m_templateTwo modifies m_templateOne := { -, "ABC", false}	//field 4 is not inherited from the parent

testcase TC_Sem_1505_ModifiedTemplates_010() runs on GeneralComp {
	if (
	   (match(valueof(m_templateOne.field1),1)) and
	   (match(valueof(m_templateTwo.field2),"ABC")) and
	   (match(valueof(m_templateTwo.field3), false)) and
	   (match(valueof(m_templateTwo.field4),"<undefined>"))	 
	    ){
		setverdict(pass,m_templateTwo.field4);
	} else {
		setverdict(fail,m_templateTwo.field4);
	}
}

control{
    execute(TC_Sem_1505_ModifiedTemplates_010());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.5, Ensure that the values of plain modified template definitions are as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1505_ModifiedTemplates_001 {

type port MyMessagePortType message {
	inout MyMessageType
}

type component GeneralComp {
	port MyMessagePortType pt_myPort;
}

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3
}

template MyMessageType m_templateOne := {
	field1 := 2,
	field2 := "Hello World",
	field3 := true
}

template MyMessageType m_templateTwo modifies m_templateOne := {
	field1 := 4
}

testcase TC_Sem_1505_ModifiedTemplates_001() runs on GeneralComp {
	if (match(valueof(m_templateTwo.field1), 4) and 
	    match(valueof(m_templateTwo.field2), "Hello World") and 
	    match(valueof(m_templateTwo.field3), true)
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1505_ModifiedTemplates_001());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.5, Ensure that a modified template does not omit possible parameters introduced in any modification step.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1505_ModifiedTemplates_002 {

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3
}

template MyMessageType m_templateOne(integer p_value) := {
	field1 := p_value,
	field2 := "Hello World",
	field3 := true
}

template MyMessageType m_templateTwo(integer p_value, boolean p_boolValue) modifies m_templateOne := {  
	field1 := p_value,
	field3 := p_boolValue
}

template MyMessageType m_templateThree(integer p_value, boolean p_boolValue) modifies m_templateTwo := {  
	field2 := "foobar"
}


}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.5, Ensure that dash as default parameter values are accepted. 
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1505_ModifiedTemplates_004 {

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3
}

template MyMessageType m_templateOne(integer p_intValue:=2) := {
	field1 := p_intValue,
	field2 := "Hello World",
	field3 := true
}

template MyMessageType m_templateTwo(integer p_intValue := -) modifies m_templateOne := {  
	field1 := p_intValue
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.5, Ensure that the default values in formal parameters of modified templates are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1505_ModifiedTemplates_003 {

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3
}

template MyMessageType m_templateOne(integer p_intValue) := {
	field1 := p_intValue,
	field2 := "Hello World",
	field3 := true
}

template MyMessageType m_templateTwo(integer p_intValue:=2, boolean p_boolValue:=false) modifies m_templateOne := {  
	field1 := p_intValue,
	field3 := p_boolValue
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.5, Ensure that default values in formal parameters of modified templates are working as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1505_ModifiedTemplates_003 {

type component GeneralComp { }

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3
}

template MyMessageType m_templateOne(integer p_intValue) := {
	field1 := p_intValue,
	field2 := "Hello World",
	field3 := true
}

template MyMessageType m_templateTwo(integer p_intValue:=2, boolean p_boolValue:=false) modifies m_templateOne := {  
	field1 := p_intValue,
	field3 := p_boolValue
}

testcase TC_Sem_1505_ModifiedTemplates_003() runs on GeneralComp {
	if (match(valueof(m_templateTwo.field1), 2) and
	    match(valueof(m_templateTwo.field2), "Hello World") and
	    match(valueof(m_templateTwo.field3), false)
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1505_ModifiedTemplates_003());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.5, Ensure that plain modified template definitions are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1505_ModifiedTemplates_001 {

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3
}

template MyMessageType m_templateOne := {
	field1 := 2,
	field2 := "Hello World",
	field3 := true
}

template MyMessageType m_templateTwo modifies m_templateOne := {
	field1 := 4
}

}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.5, Ensure that default values in formal parameters of modified templates are working as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

 //Restriction b)
 
/*If a record or set field or its corresponding matching mechanism is  implicitly or explicitly by using the not used symbol "-" -
left unspecified in the modified template, then the matching mechanism in the corresponding field of the
parent template shall be used.*/

module Sem_1505_ModifiedTemplates_007 {

type component GeneralComp { }

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3
}

template MyMessageType m_templateOne(integer p_intValue) := {
	field1 := p_intValue,
	field2 := "Hello World",
	field3 := true
}

template MyMessageType m_templateTwo(integer p_intValue:=2, boolean p_boolValue:=false) modifies m_templateOne := {  
	field1 := p_intValue,
	field2 := -,		//not used symbol
	field3 := p_boolValue
}

testcase TC_Sem_1505_ModifiedTemplates_007() runs on GeneralComp {
	if (match(valueof(m_templateTwo.field1) , 2) and
	    match(valueof(m_templateTwo.field2) , "Hello World") and
	    match(valueof(m_templateTwo.field3) , false)
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1505_ModifiedTemplates_007());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.5, Ensure that a modified template of a record of type using index notation access works as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1505_ModifiedTemplates_002 {

type component GeneralComp {
}

type record of integer MyMessageType;

template MyMessageType m_myBaseTemplate := { 0, 1, 2, 3, 4 };

template MyMessageType m_myOtherTemplate modifies m_myBaseTemplate := { 
	[2]:=3, // switch the positions of 2 and 3 
	[3]:=2 
}

testcase TC_Sem_1505_ModifiedTemplates_002() runs on GeneralComp {
	if (match(valueof(m_myOtherTemplate[0]), 0) and 
		match(valueof(m_myOtherTemplate[1]), 1) and 
		match(valueof(m_myOtherTemplate[2]), 3) and
		match(valueof(m_myOtherTemplate[3]), 2) and
		match(valueof(m_myOtherTemplate[4]), 4)
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1505_ModifiedTemplates_002());
}

}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.5, Ensure that the values of plain modified template definitions are as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
 
/*A modified template may also be declared fuzzy using the @fuzzy modifier. 
If a fuzzy modified template modifies a non-fuzzy unparameterized template, the inherited fields before modification will be the same for every evaluation of the fuzzy template.*/

module Sem_1505_ModifiedTemplates_008 {

type port MyMessagePortType message {
	inout MyMessageType
}

type component GeneralComp {
	port MyMessagePortType pt_myPort;
}

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3
}

template MyMessageType m_templateOne := {
	field1 := 2,
	field2 := "Hello World",
	field3 := -
}

template @fuzzy MyMessageType m_templateTwo modifies m_templateOne := {
	field1 := 4,
    field3 := true
}

testcase TC_Sem_1505_ModifiedTemplates_008() runs on GeneralComp {
	if ((valueof(m_templateTwo.field1) == 4) and 
	    (valueof(m_templateTwo.field2) == "Hello World") and 
	    (valueof(m_templateTwo.field3) == true)
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1505_ModifiedTemplates_008());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.10, Ensure that the valueof operation works as expected for fully initialized templates.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1510_ValueOfOperation_001 {

type component GeneralComp { }

type record ExampleType {
	integer field1,
	boolean field2
}

template ExampleType m_template := {
	field1 := 1,
	field2 := true
}

testcase TC_Sem_1510_ValueOfOperation_001() runs on GeneralComp {
	var ExampleType v_value := valueof(m_template);

	if (match(v_value.field1, 1) and
	    match(v_value.field2, true)
	   ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1510_ValueOfOperation_001());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.9, Ensure that the match operation works correctly if the types are incompatible.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1509_MatchOperation_005 {

type component GeneralComp { }

type record MyRecord {
	charstring field1,
	boolean field2
}

template MyRecord m_receiveTemplate := {
	field1 := "ab*de",
	field2 := ?
}

testcase TC_Sem_1509_MatchOperation_005() runs on GeneralComp {
	var integer v_value := 20;

	if (match(v_value, m_receiveTemplate)) {
		setverdict(fail);
	} else {
		setverdict(pass);
	}
}

control{
    execute(TC_Sem_1509_MatchOperation_005());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.9, Ensure that the match operation works as expected on a template with range restriction when the tested value is outside the range.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1509_MatchOperation_002 {

type component GeneralComp { }

template integer m_lessThan10 := (-infinity..9);

testcase TC_Sem_1509_MatchOperation_002() runs on GeneralComp {
	var integer v_value := 20;

	if (match(v_value, m_lessThan10)) {
		setverdict(fail);
	} else {
		setverdict(pass);
	}
}

control{
    execute(TC_Sem_1509_MatchOperation_002());
}

}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.9, Ensure that the match operation works correctly on sets in the negative case.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1509_MatchOperation_008 {

type component GeneralComp { }

type set MySet {
	charstring field1,
	boolean field2
}

template MySet m_receiveTemplate := {
	field1 := "ab*de",
	field2 := ?
}

testcase TC_Sem_1509_MatchOperation_008() runs on GeneralComp {
	var MySet v_value := {
		field1 := "abc",
		field2 := true
	}

	if (match(v_value, mw_receiveTemplate)) {
		setverdict(fail);
	} else {
		setverdict(pass);
	}
}

control{
    execute(TC_Sem_1509_MatchOperation_008());
}

}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.9, Ensure that the match operation works correctly on sets with optional fields in the positive case.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1509_MatchOperation_010 {

type component GeneralComp { }

type set MySet {
	charstring field1,
	boolean field2 optional
}

template MySet mw_receiveTemplate := {
	field1 := pattern "ab*de",
	field2 := *
}

testcase TC_Sem_1509_MatchOperation_010() runs on GeneralComp {
	var MySet v_value := {
		field1 := "abcde",
		field2 := omit
	}

	if (match(v_value, mw_receiveTemplate)) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1509_MatchOperation_010());
}

}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.9, Ensure that the match operation works correctly if the set types are incompatible.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1509_MatchOperation_009 {

type component GeneralComp { }

type set MySet {
	charstring field1,
	boolean field2
}

template MySet mw_receiveTemplate := {
	field1 := "ab*de",
	field2 := ?
}

testcase TC_Sem_1509_MatchOperation_009() runs on GeneralComp {
	var integer v_value := 20;

	if (match(v_value, mw_receiveTemplate)) {
		setverdict(fail);
	} else {
		setverdict(pass);
	}
}

control{
    execute(TC_Sem_1509_MatchOperation_009());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.9, Ensure that the match operation works correctly on records in the negative case.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1509_MatchOperation_004 {

type component GeneralComp { }

type record MyRecord {
	charstring field1,
	boolean field2
}

template MyRecord m_receiveTemplate := {
	field1 := "ab*de",
	field2 := ?
}

testcase TC_Sem_1509_MatchOperation_004() runs on GeneralComp {
	var MyRecord v_value := {
		field1 := "abc",
		field2 := true
	}

	if (match(v_value, m_receiveTemplate)) {
		setverdict(fail);
	} else {
		setverdict(pass);
	}
}

control{
    execute(TC_Sem_1509_MatchOperation_004());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.9, Ensure that the match operation works correctly on records in the positive case.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1509_MatchOperation_003 {

type component GeneralComp { }

type record MyRecord {
	charstring field1,
	boolean field2
}

template MyRecord m_receiveTemplate := {
	field1 := pattern "ab*de",
	field2 := ?
}

testcase TC_Sem_1509_MatchOperation_003() runs on GeneralComp {
	var MyRecord v_value := {
		field1 := "abcde",
		field2 := true
	}

	if (match(v_value, m_receiveTemplate)) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1509_MatchOperation_003());
}

}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.9, Ensure that the match operation works correctly on sets in the positive case.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1509_MatchOperation_007 {

type component GeneralComp { }

type set MySet {
	charstring field1,
	boolean field2
}

template MySet mw_receiveTemplate := {
	field1 := pattern "ab*de",
	field2 := ?
}

testcase TC_Sem_1509_MatchOperation_007() runs on GeneralComp {
	var MySet v_value := {
		field1 := "abcde",
		field2 := true
	}

	if (match(v_value, mw_receiveTemplate)) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1509_MatchOperation_007());
}

}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:15.9, Ensure that the match operation works correctly on records with optional fields in the positive case.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1509_MatchOperation_006 {

type component GeneralComp { }

type record MyRecord {
	charstring field1,
	boolean field2 optional
}

template MyRecord mw_receiveTemplate := {
	field1 := pattern "ab*de",
	field2 := *
}

testcase TC_Sem_1509_MatchOperation_006() runs on GeneralComp {
	var MyRecord v_value := {
		field1 := "abcde",
		field2 := omit
	}

	if (match(v_value, mw_receiveTemplate)) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1509_MatchOperation_006());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.9, Ensure that the match operation works as expected on a template with range restriction when the tested value is inside the range.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1509_MatchOperation_001 {

type component GeneralComp { }

template integer m_lessThan10 := (-infinity..9);

testcase TC_Sem_1509_MatchOperation_001() runs on GeneralComp {
	var integer v_value := -20;

	if (match(v_value, m_lessThan10)) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1509_MatchOperation_001());
}

}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:15.11, Ensure that concatenation of octetstring types and ? patterns works as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_013 {

type component GeneralComp { }

testcase TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_013() runs on GeneralComp {
    var template octetstring v_myString1 := ('ABCD'O & ? length(2)) length (1..6);
    // results in 'ABCD??'O matching an octet string of length 4 (8 hex digits)
    if (match('ABCD1234'O, v_myString1)) {
        setverdict(pass);
    } else {
        setverdict(fail);
    }
}

control{
    execute(TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_013());
}

}
/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.11, Ensure that concatenations of record of charstrings work when parameterized.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Note: see CR5805 regarding corresponding BNF update

module Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_008 {

type component GeneralComp { }

type record of charstring RecOfChar;

template RecOfChar m_concatenation := {"ABC"} & * length(3) & {pattern "E" & "?" & "F"};

testcase TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_008() runs on GeneralComp {
    var RecOfChar m_reference := {"ABC","A","B","C","E2F"}; // some value that matches	

    if (match(m_reference, m_concatenation)) {
        setverdict(pass);
    } else {
        setverdict(fail);
    }

}

control{
    execute(TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_008());
}

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.11, Ensure that concatenation of octetstring types works as expected  (matching patterns in quotation).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Note: see CR5805 regarding corresponding BNF update

module Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_011 {

type component GeneralComp { }

testcase TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_011() runs on GeneralComp {
    var template octetstring v_myString1 := 'ABCC'O & 'DD*'O & 'EE?FF'O;
    if (match('ABCCDD22EE11FF'O, v_myString1)) {
        setverdict(pass);
    } else {
        setverdict(fail);
    }
}

control{
    execute(TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_011());
}

}
/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.11, Ensure that concatenation of octetstring types works as expected (variant 1).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Note: see CR5805 regarding corresponding BNF update

module Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_004 {

type component GeneralComp { }

testcase TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_004() runs on GeneralComp {
	var template octetstring v_str := 'ABCD'O & 'AB*'O & 'EF'O;

	if (match('ABCDABEF'O, v_str)) { //matching not present values
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_004());
}

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.11, Ensure that concatenation of octetstring types works as expected (variant 2).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Note: see CR5805 regarding corresponding BNF update

module Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_005 {

type component GeneralComp { }

testcase TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_005() runs on GeneralComp {
	var template octetstring v_template := 'ABCD'O & '??'O & 'EF'O;

	if (match('ABCDAABBEF'O, v_template)) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_005());
}

}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:15.11, Ensure that concatenation of charstring and universal charsting types are concatenated as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
 
/* When templates of charstring and universal charstring type are both
 * present in the concatenation, the charstring values are implicitly converted to universal charstring values*/

module Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_014 {

type component GeneralComp { }

testcase TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_014() runs on GeneralComp {
    var template universal charstring v_myString1 := (char ( 0, 0, 1, 113) & "AB" & char ( 0, 0, 1, 112));     // "AB"

    if (match("AB", v_myString1)) {
        setverdict(pass);
    } else {
        setverdict(fail,v_myString1);
    }
}

control{
    execute(TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_014());
}

}
/*****************************************************************
 ** @author   STF 451 and 470
 ** @version  0.0.1
 ** @purpose  1:15.11, Ensure that concatenation of octetstring types and ? patterns works as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_012 {

type component GeneralComp { }

testcase TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_012() runs on GeneralComp {
    var template octetstring v_myString1 := 'AB'O & 'CD'O & ? & ? length(1) & 'EF'O;  //results in 'ABCD*?EF'O
    if (match('ABCD2233EF'O, v_myString1)) {
        setverdict(pass);
    } else {
        setverdict(fail);
    }
}

control{
    execute(TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_012());
}

}
/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.11, Ensure that concatenations of set of integers are accepted.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Note: see CR5805 regarding corresponding BNF update

module Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_009 {

type component GeneralComp { }

type set of integer SetOfInt;

testcase TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_009() runs on GeneralComp {
	var template SetOfInt m_concatenation := {1, 2} & * length(2) & {3, 4};
	
	var SetOfInt m_reference := {1,2, 20, 21, 3, 4};	
	if (match(m_reference,m_concatenation)) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_009());
}

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.11, Ensure that concatenation of charstring types works as expected  (variant 1).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Note: see CR5805 regarding corresponding BNF update

module Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_001 {

type component GeneralComp { }

testcase TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_001() runs on GeneralComp {
    var template charstring v_myChar1 := pattern "ABC" & "D" & "*" & "E?F";
    if (match("ABCD2E1F", v_myChar1)) {
        setverdict(pass);
    } else {
        setverdict(fail);
    }
}

control{
    execute(TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_001());
}

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.11, Ensure that the inline template definitions are correctly concatenated.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_010 {

type component GeneralComp { }

type record MyRecord {
	charstring field1,
	charstring field2
}

template MyRecord m_receiveTemplate := {
	field1 := pattern "ab*de",
	field2 := "ABC" & "DE*" & "F?"	//concatenation of literal characters
}

testcase TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_010() runs on GeneralComp {
	var MyRecord v_value := {
		field1 := "ab*de",
		field2 := "ABCDE1F1"
	}

	if (match(v_value, m_receiveTemplate)) {
		setverdict(fail);
	} else {
		setverdict(pass);
	}
}

control{
    execute(TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_010());
}

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.11, Ensure that concatenation of octetstring types works as expected  (variant 2).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Note: see CR5805 regarding corresponding BNF update

module Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_002 {

type component GeneralComp { }

testcase TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_002() runs on GeneralComp {
    var template octetstring v_myString1 := 'ABCC'O &  * length(1) & 'EF'O;
    if (match('ABCC22EF'O,v_myString1)) {
        setverdict(pass);
    } else {
        setverdict(fail);
    }
}

control{
    execute(TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_002());
}

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.11, Ensure that a concatenation of charstrings with a fixed length AnyValueOrNone be matched.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Note: see CR5805 regarding corresponding BNF update

module Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_006 {

type component GeneralComp { }

testcase TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_006() runs on GeneralComp {
    var template charstring m_str := pattern "ABC?#3" & "E?F";  //equivalent to ABC???E?F pattern

    if (match("ABCXYZE2F", m_str)) {
        setverdict(pass);
    } else {
        setverdict(fail);
    }
}

control{
    execute(TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_006());
}

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.11, Ensure that concatenation of bitstring types works as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Note: see CR5805 regarding corresponding BNF update

module Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_003 {

type component GeneralComp { }

testcase TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_003() runs on GeneralComp {
	var template bitstring v_myBitStr := '010'B & '*'B & '1?1'B;

	if (match('010010101101'B, v_myBitStr)) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_003());
}

}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.2
 ** @purpose  1:15.11, Ensure that concatenations of record of charstrings are accepted.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_007 {

type component GeneralComp { }

type record of charstring RecOfChar;

testcase TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_007() runs on GeneralComp {
    var template RecOfChar m_concatenation := {"ABC"} & {pattern "D*", pattern "E?" & "F"};

    var RecOfChar m_reference := {"ABC","D213","E2F"}; // some value that matches	

    if (match(m_reference,m_concatenation)) {
        setverdict(pass);
    } else {
        setverdict(fail);
    }
}

control{
    execute(TC_Sem_1511_ConcatenatingTemplatesOfStringAndListTypes_007());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.4, Ensure that inline templates are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1504_InlineTemplates_001 {

type port MyMessagePortType message {
	inout MyMessageType
}

type component GeneralComp {
	port MyMessagePortType pt_myPort;
}

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3
}

testcase TC_Syn_1504_InlineTemplates_001() runs on GeneralComp {
    pt_myPort.send(MyMessageType:{2, "abcxyz", true});
	setverdict(pass);
}

control{
    execute(TC_Syn_1504_InlineTemplates_001());
}
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.4, Ensure that modified parameterized inline templates are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1504_InlineTemplates_002 {

type port MyMessagePortType message {
	inout MyMessageType
}

type component GeneralComp {
	port MyMessagePortType pt_myPort;
}

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3
}

template MyMessageType m_myTemplate(integer p_myFormalParam):= {
	field1 := p_myFormalParam, 
	field2 := pattern "abc*xyz", 
	field3 := true
}

testcase TC_Syn_1504_InlineTemplates_002() runs on GeneralComp {
	pt_myPort.send(MyMessageType:modifies m_myTemplate(2) := {field2:="foobar"});
	setverdict(pass);
}

control{
    execute(TC_Syn_1504_InlineTemplates_002());
}
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.4, Ensure that modified plain inline templates are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1504_InlineTemplates_003 {

type port MyMessagePortType message {
	inout MyMessageType
}

type component GeneralComp {
	port MyMessagePortType pt_myPort;
}

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3
}

template MyMessageType m_myTemplate := {
	field1 := 2, 
	field2 := pattern "abc*xyz", 
	field3 := true
}

testcase TC_Syn_1504_InlineTemplates_003() runs on GeneralComp {
	pt_myPort.send(MyMessageType:modifies m_myTemplate := {field2:="foobar"});
	setverdict(pass);
}

control{
    execute(TC_Syn_1504_InlineTemplates_003());
}
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.3, Ensure that a parameterized local template in the control part is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1503_GlobalAndLocalTemplates_004 {

    type port MyMessagePortType message {
        inout MyMessageType
    }

    type component GeneralComp {
        port MyMessagePortType pt_myPort;
    }

    type record MyMessageType {
        integer field1,
        charstring field2,
        boolean field3
    }

    control{
        template MyMessageType m_myTemplate(integer p_myFormalParam):= {
            field1 := p_myFormalParam,
            field2 := pattern "abc*xyz",
            field3 := true
        }
    }


}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.3, Ensure that a send operation with actual parameters of a global parameterized template is accepted with the actual parameter being a template parameter.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1503_GlobalAndLocalTemplates_005 {

    type port MyMessagePortType message {
        inout MyMessageType
    }

    type component GeneralComp {
        port MyMessagePortType pt_myPort;
    }

    type record MyMessageType {
        integer field1,
        charstring field2,
        MyMessageType field3 optional
    }

    template MyMessageType m_myTemplate(integer p_myFormalParam):= {
        field1 := p_myFormalParam,
        field2 := "abc1xyz",
        field3 := omit
    }

    template MyMessageType m_myOtherTemplate(template MyMessageType p_myTemplate):= {
        field1 := 2,
        field2 := "abcxyz",
        field3 := p_myTemplate
    }

    testcase TC_Sem_1503_GlobalAndLocalTemplates_005() runs on GeneralComp {
        pt_myPort.send(m_myOtherTemplate(m_myTemplate(2)));
        setverdict(pass);
    }

    control{
        execute(TC_Sem_1503_GlobalAndLocalTemplates_005());
    }


}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.3, Ensure that a send operation with actual parameters of a global parameterized template is accepted with the actual parameter being an inline template.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1503_GlobalAndLocalTemplates_006 {

    type port MyMessagePortType message {
        inout MyMessageType
    }

    type component GeneralComp {
        port MyMessagePortType pt_myPort;
    }

    type record MyMessageType {
        integer field1,
        charstring field2,
        MyMessageType field3 optional
    }

    template MyMessageType m_myOtherTemplate(template MyMessageType p_myTemplate):= {
        field1 := 2,
        field2 := "abcxyz",
        field3 := p_myTemplate
    }

    testcase TC_Sem_1503_GlobalAndLocalTemplates_006() runs on GeneralComp {
        pt_myPort.send(m_myOtherTemplate(MyMessageType:{2,"foobar",omit}));
        setverdict(pass);
    }

    control{
        execute(TC_Sem_1503_GlobalAndLocalTemplates_006());
    }


}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.3, Ensure that a parameterized local template in an altstep is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1503_GlobalAndLocalTemplates_006 {

    type port MyMessagePortType message {
        inout MyMessageType
    }

    type component GeneralComp {
        port MyMessagePortType pt_myPort;
    }

    type record MyMessageType {
        integer field1,
        charstring field2,
        boolean field3
    }

    altstep f_testTemplate() runs on GeneralComp {
        [] pt_myPort.receive {
            template MyMessageType m_myTemplate(integer p_myFormalParam):= {
                field1 := p_myFormalParam,
                field2 := pattern "abc*xyz",
                field3 := true
            }
        }
    }

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.3, Ensure that a global parameterized template is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1503_GlobalAndLocalTemplates_001 {

    type record MyMessageType {
        integer field1,
        charstring field2,
        boolean field3
    }

    template MyMessageType m_myTemplate(integer p_myFormalParam):= {
        field1 := p_myFormalParam,
        field2 := pattern "abc*xyz",
        field3 := true
    }

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.3, Ensure that a template values can be accessed with the dot notation as expected.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1503_GlobalAndLocalTemplates_001 {

type port MyMessagePortType message {
	inout MyMessageType
}

type component GeneralComp {
	port MyMessagePortType pt_myPort;
}

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3
}

template MyMessageType m_myTemplate := {
	field1 := 2, 
	field2 := "foobar", 
	field3 := true
}

testcase TC_Sem_1503_GlobalAndLocalTemplates_001() runs on GeneralComp {
	if (match(2,m_myTemplate.field1) and match("foobar", m_myTemplate.field2) and match(true, m_myTemplate.field3)) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1503_GlobalAndLocalTemplates_001());
}
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.3, Ensure that a send operation with actual parameters of a global parameterized template is accepted.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1503_GlobalAndLocalTemplates_003 {

    type port MyMessagePortType message {
        inout MyMessageType
    }

    type component GeneralComp {
        port MyMessagePortType pt_myPort;
    }

    type record MyMessageType {
        integer field1,
        charstring field2,
        boolean field3
    }

    template MyMessageType m_myTemplate(integer p_myFormalParam):= {
        field1 := p_myFormalParam,
        field2 := "abcxyz",
        field3 := true
    }

    testcase TC_Sem_1503_GlobalAndLocalTemplates_003() runs on GeneralComp {
        pt_myPort.send(m_myTemplate(2));
        setverdict(pass);
    }

    control{
        execute(TC_Sem_1503_GlobalAndLocalTemplates_003());
    }


}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:15.3, Ensure that a parameterized local template in a test case is accepted.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1503_GlobalAndLocalTemplates_004 {

    type port MyMessagePortType message {
        inout MyMessageType
    }

    type component GeneralComp {
        port MyMessagePortType pt_myPort;
    }

    type record MyMessageType {
        integer field1,
        charstring field2,
        boolean field3
    }

    testcase TC_Sem_1503_GlobalAndLocalTemplates_004() runs on GeneralComp {
        template MyMessageType m_myTemplate(integer p_myFormalParam):= {
            field1 := p_myFormalParam,
            field2 := "abcxyz",
            field3 := true
        }
	
        pt_myPort.send(m_myTemplate(2));
        setverdict(pass);
    }

    control{
        execute(TC_Sem_1503_GlobalAndLocalTemplates_004());
    }


}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.3, Ensure that a template actual parameter is passed through correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1503_GlobalAndLocalTemplates_002 {

type port MyMessagePortType message {
	inout MyMessageType
}

type component GeneralComp {
	port MyMessagePortType pt_myPort;
}

type record MyMessageType {
	integer field1,
	charstring field2,
	boolean field3
}

template MyMessageType m_myTemplate(integer p_myFormalParam):= {
	field1 := p_myFormalParam, 
	field2 := pattern "abc*xyz", 
	field3 := true
}

testcase TC_Sem_1503_GlobalAndLocalTemplates_002() runs on GeneralComp {
	if (valueof(m_myTemplate(2).field1) == 2) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1503_GlobalAndLocalTemplates_002());
}
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:15.3, Ensure that a parameterized local template in a function is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1503_GlobalAndLocalTemplates_005 {

    type port MyMessagePortType message {
        inout MyMessageType
    }

    type component GeneralComp {
        port MyMessagePortType pt_myPort;
    }

    type record MyMessageType {
        integer field1,
        charstring field2,
        boolean field3
    }

    function f_testTemplate() {
        template MyMessageType m_myTemplate(integer p_myFormalParam):= {
            field1 := p_myFormalParam,
            field2 := pattern "abc*xyz",
            field3 := true
        }
    }

}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:D, Ensure that __FILE__ macro stores the path and file name in a charstring
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Sem_D02_macro_file_001 {

    type component GeneralComp {	}
	
    testcase TC_Sem_D02_macro_file_001() runs on GeneralComp system GeneralComp {
       
        const charstring MyConst:= __FILE__;
        // will match file paths of the form .../Sem_D02_macro_file_001.ttcn or ...\Sem_D02_macro_file_001.ttcn
        template charstring namePattern := pattern "*[\\/]Sem_D02_macro_file_001.ttcn";

        if(match(MyConst, namePattern)){
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_D02_macro_file_001());
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:D, Ensure that __LINE__ macro stores the actual line number when it is called
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// In this case the line number when the macro is called at line 15.
module Sem_D04_macro_line_001 {

    type component GeneralComp {}
    function f1 ( ) runs on GeneralComp {}
	
    testcase TC_Sem_D04_macro_line_001() runs on GeneralComp system GeneralComp {
        
        const integer MyConst:= __LINE__; // line 15
		
        if (match(MyConst, 15)) {
            setverdict(pass);
        } else {
            setverdict(fail, "Expected line 15, wrong line number");
        }
    }

    control {
        execute(TC_Sem_D04_macro_line_001());
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:D, Ensure that __SCOPE__ replaces the actual higher basic unit
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// __SCOPE__ replaces the actual higher basic unit
module Sem_D05_macro_scope_002 {

    type component GeneralComp {
        var charstring variable1:=__SCOPE__; //variable1=="GeneralComp"
    }
	
    type record MyRecord {
        charstring variable0 ("1","2",__SCOPE__)
    }
	
    testcase TC_Sem_D05_macro_scope_002() runs on GeneralComp system GeneralComp {
        
        template MyRecord Mytemplate:={
            variable0:="MyRecord"  //MyRecord is a legal element because of __SCOPE__
        }
	
        if(match(variable1, "GeneralComp")){
            setverdict(pass);
        } else {
            setverdict(fail);
        }
		
    }

    control {
        execute(TC_Sem_D05_macro_scope_002());
    }
}/*****************************************************************
 * @author STF 451
 * @version 0.0.1
 * @purpose 1:D, Ensure that __SCOPE__ replaces the actual higher basic unit
 * @verdict pass accept, ttcn3verdict:pass
 *****************************************************************/
// __SCOPE__ replaces the actual higher basic unit (name of the test component)
module Sem_D05_macro_scope_001 {
	type component GeneralComp {
		const charstring MyConst := __SCOPE__;
	}

	testcase TC_Sem_D05_macro_scope_001()
		runs on GeneralComp system GeneralComp {


		if (match(MyConst, "GeneralComp")) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	control {
		execute(TC_Sem_D05_macro_scope_001());
	}
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:D, Ensure that the __BFILE__ macro replaces the actual file name
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// the actual file name is given in __BFILE__ macro.
module Sem_D03_macro_bfile_001 {

    type component GeneralComp {}
	
    testcase TC_Sem_D03_macro_bfile_001() runs on GeneralComp system GeneralComp {
        
	const charstring MyConst:=__BFILE__;
		
    	if(match(MyConst, "Sem_D03_macro_bfile_001.ttcn")){
		    setverdict(pass);
	    } else {
		    setverdict(fail);
	    }
    }

    control {
        execute(TC_Sem_D03_macro_bfile_001());
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:D, Ensure that __MODULE__ replaces the module name
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The name of the module is stored in __MODULE__ macro
module Sem_D01_macro_module_001 {

    type component GeneralComp {}
	function f1 ( ) runs on GeneralComp {}
	
    testcase TC_Sem_D01_macro_module_001() runs on GeneralComp system GeneralComp {
        
	const charstring MyConst:= __MODULE__;
	
	if(match(MyConst, "Sem_D01_macro_module_001")){
	    setverdict(pass);}
	else {
	    setverdict(fail);}
    }

    control {
        execute(TC_Sem_D01_macro_module_001());
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.3, Ensure timer stop syntax
 ** @verdict  pass accept, noexecute
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.3 The Stop timer operation/Timer stop syntax

module Syn_2303_timer_stop_006 {
    type component TComp{
        timer t_timer := 1.0; 
    }
    testcase TC_Syn_2303_timer_stop_006() runs on TComp{
        t_timer.start;
        t_timer.stop;
        setverdict(pass);
    }
    control{
        
            execute(TC_Syn_2303_timer_stop_006())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.3, Ensure can be stopped after timeout
 ** @verdict  pass accept, ttcn3verdict:none
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.3 The Stop timer operation/Stopping inactive timer is ok, but unobservable


module Sem_2303_timer_stop_004 {
    type component TComp{
        timer t_timer := 1.0; 
    }
    altstep a_step() runs on TComp{
        []t_timer.timeout{
            t_timer.stop;
        }
    }
    testcase TC_Sem_2303_timer_stop_004() runs on TComp{
        t_timer.start;
        a_step();
        
    }
    control{
        
            execute(TC_Sem_2303_timer_stop_004())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.3, Ensure all timer stop syntax
 ** @verdict  pass accept, noexecute
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.3 The Stop timer operation/Timer stop syntax
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Allow all timer.stop

module Syn_2303_timer_stop_007 {
    type component TComp{
        timer t_timer := 1.0; 
    }
    testcase TC_Syn_2303_timer_stop_007() runs on TComp{
        t_timer.start;
        all timer.stop;
        setverdict(pass);
        
    }
    control{
        
            execute(TC_Syn_2303_timer_stop_007())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.3, Ensure timer stop sets elapsed time to zero
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.3 The Stop timer operation/stopped timer is inactive and elapsed time is 0


module Sem_2303_timer_stop_002 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }
    testcase TC_Sem_2303_timer_stop_002() runs on TComp{
        t_timer[0].start;
        t_timer[1].start;
        t_timer[0].stop;
        if (t_timer[0].read!=0.0){
            setverdict(fail);
        }
        setverdict(pass);
        
    }
    control{
        
            execute(TC_Sem_2303_timer_stop_002())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.3, Ensure timer all timer identifier
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.3 The Stop timer operation/all keyword can be used for timers in component or module control
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Allow all timer.stop

module Sem_2303_timer_stop_003 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }
    testcase TC_Sem_2303_timer_stop_003() runs on TComp{
        t_timer[0].start;
        t_timer[1].start;
        all timer.stop;
        if (t_timer[0].read!=0.0 or t_timer[1].read!=0.0){
            setverdict(fail);
        }
        setverdict(pass);
        
    }
    control{
        
            execute(TC_Sem_2303_timer_stop_003())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer with value 0.0 expires immediately
 ** @verdict  pass accept, ttnc3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Timer with the timer value 0.0 times out immediately.


module Sem_2302_timer_start_004 {
    type component TComp{
        timer t_timer := 0.0;
        timer t_timer_with_long_default := 100.0;
    }
    
    testcase TC_Sem_2302_timer_start_004() runs on TComp{
        t_timer.start;
        if (t_timer.running)
        {
            setverdict(fail);
        }
        else
        {
            setverdict(pass);
        }
        
        t_timer_with_long_default.start(0.0);
        if (t_timer_with_long_default.running)
        {
            setverdict(fail);
        }
        else
        {
            setverdict(pass);
        }
        
        
    }
    control{
        
            execute(TC_Sem_2302_timer_start_004())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer runs from zero to stated value
 ** @verdict  pass accept, ttnc3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/timer clock runs from 0 to the value set

module Sem_2302_timer_start_001 {
    type component TComp{
        timer t_timer := 1.0;
    }
    testcase TC_Sem_2302_timer_start_001() runs on TComp{
        timer t_short, t_long;
        var float v_elapsed;
        var float v_last := 0.0;
        
        t_long.start(2.0);
        t_timer.start(1.0);
        t_short.start(0.5);
                
		while (t_short.running) {
			v_elapsed := t_timer.read;
			log("t_timer.read = ", v_elapsed);
			if (v_elapsed<0.0 or v_elapsed < v_last){
				setverdict(fail)
			}
			v_last := v_elapsed;
		}
		while (t_timer.running) {
			v_elapsed := t_long.read;
			log("t_long.read = ", v_elapsed);
			if (v_elapsed < v_last){
				setverdict(fail)
			}
			v_last := v_elapsed;
		}
        setverdict(pass);
        
    }
    control{
        execute(TC_Sem_2302_timer_start_001())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer can be restarted
 ** @verdict  pass accept, ttnc3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/timer can be restarted by repeated start operation


module Sem_2302_timer_start_002 {
    type component TComp{
    }
    
    testcase TC_Sem_2302_timer_start_002() runs on TComp{
        timer t_short := 0.5, t_target := 1.0, t_long := 1.0;
        
        t_short.start;
        t_target.start;
        t_long.start;
        
        alt {
            []t_short.timeout {
                setverdict(pass);
                t_target.start; // restart timer
            }
            []t_target.timeout {
                setverdict(fail);
                stop;
            }
            []t_long.timeout {
                setverdict(fail);
                stop;
            }
        }
        alt {
            []t_long.timeout {
                setverdict(pass);
            }
            []t_target.timeout {
                // Expected that t_target timeouts in 1.5 seconds since start: 
                // 0.5 sec. elapsed by t_short and 1.0 sec. by restarted timer
                setverdict(fail);
                stop;
            }
        }
    }
    control{
        
            execute(TC_Sem_2302_timer_start_002())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer default value can be modified by start value
 ** @verdict  pass accept, ttnc3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/timer clock runs from 0 to the value set
// #reqname  /Requirements/23 Timer operations/23.2 The start timer operation/Overridden timer value applies only to current instance

module Sem_2302_timer_start_003 {
    type component TComp{
        timer t_timer := 1.0;
    }
    
    testcase TC_Sem_2302_timer_start_003() runs on TComp{
        timer t_short := 0.95, t_long := 1.05;
        
        t_long.start;
        t_timer.start(0.9);
        t_short.start;
        
        // t_timer is expected to expire before other timers: its duration 0.9 < t_short < t_long
        alt {
            []t_timer.timeout {
                setverdict(pass);
            }
            []t_short.timeout {
                setverdict(fail);
                stop;
            }
            []t_long.timeout {
                setverdict(fail);
                stop;
            }
        }
        
        t_short.timeout;
        t_long.timeout;
        
        t_long.start;
        t_timer.start;
        t_short.start;
        // t_timer is expected to expire before between t_short and t_long timers: 
        // its default duration t_short < 1.0 < t_long
        alt {
            []t_short.timeout {
                setverdict(pass);
            }
            []t_timer.timeout {
                setverdict(fail);
                stop;
            }
            []t_long.timeout {
                setverdict(fail);
                stop;
            }
        }
        alt {
            []t_timer.timeout {
                setverdict(pass);
            }
            []t_long.timeout {
                setverdict(fail);
                stop;
            }
        }
    }
    control{
        
            execute(TC_Sem_2302_timer_start_003())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.5, Ensure timer running any timer identifier works
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.5 The Running timer operation/The any keyword may be used to check if any timer started on a component or module control is running


module Sem_2305_timer_running_001 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.0}; 
    }
    testcase TC_Sem_2305_timer_running_001() runs on TComp{
        t_timer[0].start;
        t_timer[1].start;
        all timer.stop;
        if (any timer.running){
            setverdict(fail);
            stop;
        }
        setverdict(pass);
        
    }
    control{
        
            execute(TC_Sem_2305_timer_running_001())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.5, Ensure timer running operation works
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.5 The Running timer operation/The operation returns the value true if the timer is listed on the running list, false otherwise.
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Allow any timer.running

module Sem_2305_timer_running_004 {
    type component TComp{
        timer t_timer := 5.0; 
    }
    testcase TC_Sem_2305_timer_running_004() runs on TComp{
        t_timer.start;
        if (any timer.running){
	        setverdict(pass);
        } else {
            setverdict(fail, "no timer running");
        }
        t_timer.stop;
    }
    control{
            execute(TC_Sem_2305_timer_running_004())
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:23.5, Ensure that correct number of timers from a timer array is still running
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_2305_timer_running_005 {
    type component TComp {
        timer t_TimerArray[2][2] :={{3.0,3.0}, {5.0,5.0}};
    }
    testcase TC_Sem_2305_timer_running_005() runs on TComp {

        var integer v_foundIndex[2];
        for (var integer i := 0; i < lengthof(t_TimerArray); i := i + 1) {
            for (var integer j := 0; j < lengthof(t_TimerArray[i]); j := j + 1) {
                t_TimerArray[i][j].start;
            }
        }
        t_TimerArray[0][0].stop;
        if (any from t_TimerArray.running -> @index v_foundIndex and v_foundIndex[0] == 0 and v_foundIndex[1] == 1) {
            setverdict(pass);
        } else {
            setverdict(fail, "wrong number of timers running");
        }
    }
    
    control    {
        execute(TC_Sem_2305_timer_running_005())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.5, Ensure timer running operation works
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.5 The Running timer operation/The operation returns the value true if the timer is listed on the running list, false otherwise.


module Sem_2305_timer_running_002 {
    type component TComp{
        timer t_timer := 1.0; 
    }
    testcase TC_Sem_2305_timer_running_002() runs on TComp{
        t_timer.start;
        if (t_timer.running){
	        setverdict(pass);
        } else {
            setverdict(fail);
        }
    }
    control{
            execute(TC_Sem_2305_timer_running_002())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.5, Ensure timer running operation works
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.5 The Running timer operation/The operation returns the value true if the timer is listed on the running list, false otherwise.


module Sem_2305_timer_running_003 {
    type component TComp{
        timer t_timer := 1.0; 
    }
    testcase TC_Sem_2305_timer_running_003() runs on TComp{
        t_timer.start;
        t_timer.stop;
        if (t_timer.running){
	        setverdict(fail);
        } else {
            setverdict(pass);
        }
    }
    control{
            execute(TC_Sem_2305_timer_running_003())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure timer timeout happen in order from the shortest to the longest 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/The timeout can be used as a standalone statement

module Sem_2306_timer_timeout_007 {
    type component TComp{
        timer t_short, t_medium, t_long;
    }
    testcase TC_Sem_2306_timer_timeout_007() runs on TComp{
        t_long.start(3.0);
        t_medium.start(2.0);
        t_short.start(1.0);
        
		t_medium.timeout;
        if (t_short.running)
        {
            setverdict(fail, "The timer has expired too early");
            stop;
        }
		if (not t_long.running)
		{
		    setverdict(fail, "The timer has expired too late");
		    stop;
		}
		setverdict(pass);
    }
    control{
        
            execute(TC_Sem_2306_timer_timeout_007())
       
        
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:23.6, removing random timeout when using any timer.timeout 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_2306_timer_timeout_009 {

    type component TComp{
        timer t_tmr := 0.5;
    }

    testcase TC_Sem_2306_timer_timeout_009() runs on TComp{
        t_tmr.start;
        any timer.timeout; // it should remove t_tmr timeout from the timeout table
        alt {
            [] t_tmr.timeout { setverdict(fail, "Timeout not removed by any timer.timeout"); }
            [else] { setverdict(pass); }
        }
    }

    control {
        execute(TC_Sem_2306_timer_timeout_009(), 5.0)
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure timer timeout operations: timed-out timer does not timeout until restarted
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/Timeout operational semantics/Timeout a timer that is already timed out


module Sem_2306_timer_timeout_002 {
    type component TComp{
        timer t_timedout_timer := 0.5;
        timer t_aux := 2.0; 
    }
    testcase TC_Sem_2306_timer_timeout_002() runs on TComp{
        t_timedout_timer.start;
        t_timedout_timer.timeout ;
        
        t_aux.start;
        alt
        {
            [] t_timedout_timer.timeout {
                setverdict(fail);
            }
            [] t_aux.timeout {
                setverdict(pass);
            }
        }
    }
    control{
        
            execute(TC_Sem_2306_timer_timeout_002())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.5, Ensure timer runnig syntax
 ** @verdict  pass accept, noexecution
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.5 The Running timer operation/Timer running syntax

module Syn_2306_timer_timeout_001 
{
    type component TComp {}
    
    testcase TC_Syn_2306_timer_timeout_001() runs on TComp
    {
        var boolean v_bool;
        timer t_timer := 0.1;
        timer t_array[3] := { 1.0, 2.0, 3.0 }
        
        t_timer.start;
        if (t_timer.running)
        {
            t_array[0].start;
            if (t_array[0].running)
            {
	            v_bool := t_array[1].running;
            }
        }
        
        v_bool := any timer.running;
        if (any timer.running and true)
        {
        }
        if (not any timer.running)
        {
        }
    }
    
    control{
            execute(TC_Syn_2306_timer_timeout_001())    
    }
    
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure timer timeout operations: non-started timer does not timeout 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/Timeout operational semantics/Timeout unstarted timer


module Sem_2306_timer_timeout_001 {
    type component TComp{
        timer t_unstarted_timer;
        timer t_started_timer := 2.0; 
    }
    testcase TC_Sem_2306_timer_timeout_001() runs on TComp{
        t_started_timer.start;
        alt
        {
            [] t_unstarted_timer.timeout {
                setverdict(fail);
            }
            [] t_started_timer.timeout {
                setverdict(pass);
            }
        }
    }
    control{
        
            execute(TC_Sem_2306_timer_timeout_001())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure any timer.timeout operation handles timeout of any timer in the component, not only visible from a function or altstep
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/The any keyword used with the timeout operation succeeds if the timeout-list is not empty./Wait for timers that are outside of scope
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Allow any timer.timeout

module Sem_2306_timer_timeout_006 {
    const float PTC_TIMEOUT := 5.0;
    
    type port MyPort message { inout charstring };
    
    type component System {}
    
    type component MTC {
        port MyPort signalPort; 
    }
    
    type component PTC {
    	port MyPort signalPort;
    }
    function f_ptc1() runs on PTC
    {
        timer t_timer := PTC_TIMEOUT;
        t_timer.start;
        
        t_timer.timeout;
        setverdict(fail, "The component was expected to be killed before this point");
        signalPort.send("I'm timed out!");
    }
    
    altstep a_step() runs on MTC {
        [] any timer.timeout {
            setverdict(pass);
        }
        [] signalPort.receive {
            // PTC timer out
            setverdict(fail, "Any timer.timeout failed to see the timer outside altstep scope");
        }
    }
    
    testcase TC_Sem_2306_timer_timeout_006() runs on MTC system System{
        var PTC ptc := PTC.create;
        timer t_timer;
        connect(ptc:signalPort, mtc:signalPort);
        ptc.start(f_ptc1());
        
        // Start a timer outside of the scope of a_step 
        t_timer.start(1.0);
        a_step();
        ptc.kill;
    }
    control{
        
            execute(TC_Sem_2306_timer_timeout_006())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure any timer.timeout operation 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation//Requirements/23 Timer operations/23.6 The Timeout operation/The any keyword used with the timeout operation succeeds if the timeout-list is not empty./Wait for timers in scope of the alt
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/The any keyword used with the timeout operation succeeds if the timeout-list is not empty./Wait for timers in scope of the alt
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Allow any timer.timeout


module Sem_2306_timer_timeout_004 {
    type component TComp{
        timer t_timer[2] := {1.0, 1.1}; 
    }
    altstep a_step() runs on TComp{
        [] any timer.timeout {
            setverdict(pass);
        }
    }
    testcase TC_Sem_2306_timer_timeout_004() runs on TComp{
        t_timer[0].start;
        t_timer[1].start;
        a_step();
        a_step();
        if (t_timer[0].running or t_timer[1].running){
            setverdict(fail);
        }
        setverdict(pass);
    }
    control{
        
            execute(TC_Sem_2306_timer_timeout_004())
       
        
    }
}
/***************************************************
 ** @author   STF 470, corrected by STF 487
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure that timeout of a timer from a timer array works correctly 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_2306_timer_timeout_008 {
    type component TComp{
        timer t_TimerArray[2][2] :={{0.5, 1.0}, {5.0, 5.5}};
    }
    testcase TC_Sem_2306_timer_timeout_008() runs on TComp{
        var integer v_foundIndex[2];
        for (var integer i := 0; i < lengthof(t_TimerArray); i := i + 1) {
            for (var integer j := 0; j < lengthof(t_TimerArray[i]); j := j + 1) {
                t_TimerArray[i][j].start;
            }
        }
        t_TimerArray[0][0].stop;
        
        any from t_TimerArray.timeout -> @index v_foundIndex;
        if(v_foundIndex[0] == 0 and v_foundIndex[1] == 1){
            setverdict(pass);
        } else {
            setverdict(fail, "wrong number of timers with timeout");
        }

    }
    control{
        
            execute(TC_Sem_2306_timer_timeout_008(), 5.0)
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure timer timeout happen in order from the shortest to the longest 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/Timeout operational semantics/Timeout started timer
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/The timeout can be used as alternative in alt

module Sem_2306_timer_timeout_003 {
    type component TComp{
        timer t_short, t_medium, t_long;
    }
    testcase TC_Sem_2306_timer_timeout_003() runs on TComp{
        t_long.start(3.0);
        t_medium.start(2.0);
        t_short.start(1.0);
        
        alt
        {
            [] t_long.timeout { 
                setverdict(fail, 
                    "Timer started for 3 seconds expired earlier than the timer started for 1 second");
                stop;
            }
            [] t_medium.timeout { 
                setverdict(fail, 
                    "Timer started for 2 seconds expired earlier than the timer started for 1 second");
                stop;
            }
            [] t_short.timeout {
                setverdict(pass);
            }
        }
        alt
        {
            [] t_long.timeout { 
                setverdict(fail, 
                    "Timer started for 3 seconds expired earlier than the timer started for 2 second");
                stop;
            }
            [] t_medium.timeout { 
                setverdict(pass);
            }
        }
		t_long.timeout;                
    }
    control{
        
            execute(TC_Sem_2306_timer_timeout_003())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23.6, Ensure any timer.timeout operation for timeouts that are not in scope 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.6 The Timeout operation/The any keyword used with the timeout operation succeeds if the timeout-list is not empty./Any timer ignores timeouts in other components
// #reqname  /Requirements/23 Timer operations/23.7 Summary of use of any and all with timers/Allow any timer.timeout

module Sem_2306_timer_timeout_005 {
    const float PTC_TIMEOUT := 1.0;
    
    type port MyPort message { inout charstring };
    
    type component System {}
    
    type component MTC {
        port MyPort signalPort; 
    }
    
    type component PTC {
    	port MyPort signalPort;
    }
    function f_wait_for_mtc_timeout() runs on PTC
    {
        timer t_timer := PTC_TIMEOUT;
        t_timer.start;
        
        alt {
            [] signalPort.receive {
                // any timer.timeout happend in MTC
                setverdict(fail, "MTC detected timeout happened in PTC -- it is wrong!");
            }
            [] t_timer.timeout {
                setverdict(pass);
                signalPort.send("I'm timed out!");
            }
        }
    }
    
    altstep a_step() runs on MTC {
        [] any timer.timeout {
            setverdict(fail, "MTC detected timeout happened in PTC -- it is wrong!");
            signalPort.send("I saw your timeout?");
        }
        [] signalPort.receive {
            // PTC timer out
            setverdict(pass);
        }
    }
    
    testcase TC_Sem_2306_timer_timeout_005() runs on MTC system System{
        var PTC ptc := PTC.create;
        connect(ptc:signalPort, mtc:signalPort);
        ptc.start(f_wait_for_mtc_timeout());
        
        a_step();
    }
    control{
        
            execute(TC_Sem_2306_timer_timeout_005())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24.4, Ensure timer read result is non-negative float
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.4 The Read timer operation/Read returns elapsed time that is non-neg float


module Sem_2304_timer_read_003 {
    type component TComp{
        timer t_aux := 1.0; 
        timer t_aux2 := 1.05;
        timer t_timer := 20.0; 
    }
    testcase TC_Sem_2304_timer_read_003() runs on TComp{
        var float v_elapsed;
        
        t_aux2.start;
        
        t_timer.start;

		// wait for 1 second
        t_aux.start;
		t_aux.timeout;

        v_elapsed:=t_timer.read;
        if (v_elapsed < 1.0){
            setverdict(fail);
        } else {
			setverdict(pass);
        }
        if (t_aux2.running) {
            if (v_elapsed <= 1.05) {
                setverdict(pass);
            } else {
            	setverdict(fail);
            }
        }
    }
    control{
        
            execute(TC_Sem_2304_timer_read_003())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24.4, Ensure timer read result of inactive timer is zero
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.4 The Read timer operation/Read on an inactive timer returns float zero


module Sem_2304_timer_read_001 {
    type component TComp{
        timer t_timer := 1.0; 
    }
    testcase TC_Sem_2304_timer_read_001() runs on TComp{
        if (t_timer.read!=0.0){
            setverdict(fail);
			stop;
        }
        t_timer.start;
        t_timer.stop;
        if (t_timer.read!=0.0){
            setverdict(fail);
        } else {
			setverdict(pass);
		}
        
    }
    control{
            execute(TC_Sem_2304_timer_read_001())
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24.4, Ensure timer read result is non-negative float
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/23.4 The Read timer operation/Read returns elapsed time that is non-neg float


module Sem_2304_timer_read_002 {
    type component TComp{
        timer t_timer := 1.0; 
    }
    testcase TC_Sem_2304_timer_read_002() runs on TComp{
        var float f:=0.0;
        t_timer.start;
        f:=t_timer.read;
        if (f < 0.0){
            setverdict(fail);
        } else {
			setverdict(pass);
        }
    }
    control{
        
            execute(TC_Sem_2304_timer_read_002())
       
        
    }
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer allowed in module control, test case, function, altstep
 ** @verdict  pass accept, noexecution
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/Usage of timers is allowed in test cases, functions, altsteps, module control/Positive syntax test

module Syn_23_toplevel_001 
{
    type port MyPort message
    {
        inout integer;
    }
    
    type component TComp 
    {
    	port MyPort p_port;
    }
    
    function f_function()
    {
        var float v_float;
        timer t_timer;
        
        t_timer.start(1.0);
        v_float := t_timer.read;
        if (t_timer.running)
        {
            t_timer.timeout;
        }
        t_timer.stop;
    }
    
    altstep a_step() runs on TComp
    {
        [] p_port.receive {
            var float v_float;
            timer t_timer;
            
            t_timer.start(1.0);
            v_float := t_timer.read;
            if (t_timer.running)
            {
           		t_timer.timeout;
            }
           	t_timer.stop;
        }
    }
    
    testcase TC_Syn_23_toplevel_001() runs on TComp
    {
        var float v_float;
        timer t_timer;

        t_timer.start(1.0);
        v_float := t_timer.read;
        if (t_timer.running)
        {
            t_timer.timeout;
        }
        t_timer.stop;
	}
	
	control
	{
        var float v_float;
        timer t_timer;

        t_timer.start(1.0);
        v_float := t_timer.read;
        if (t_timer.running)
        {
            t_timer.timeout;
        }
        t_timer.stop;	    
	}
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:23, Ensure timer allowed in module control, test case, function, altstep
 ** @verdict  pass accept, noexecution
 ***************************************************/
// #reqname  /Requirements/23 Timer operations/Usage of timers is allowed in test cases, functions, altsteps, module control/Positive syntax test

module Syn_23_toplevel_002 
{
    type port MyPort message
    {
        inout integer;
    }
    
    type component TComp 
    {
    	port MyPort p_port;
    }
    
    function f_function()
    {
        var float v_float;
        timer t_timer[5] := {1.0, 2.0, 3.0, 4.0, 5.0};
        
        t_timer[0].start(1.0);
        v_float := t_timer[1].read;
        if (t_timer[2].running)
        {
            t_timer[3].timeout;
        }
        t_timer[4].stop;
    }
    
    altstep a_step() runs on TComp
    {
        timer t_timer[5] := {1.0, 2.0, 3.0, 4.0, 5.0};
        [] p_port.receive {
            var float v_float;
        
            t_timer[0].start(1.0);
            v_float := t_timer[1].read;
            if (t_timer[2].running)
            {
                t_timer[3].timeout;
            }
            t_timer[4].stop;
        }
    }
    
    testcase TC_Syn_23_toplevel_002() runs on TComp
    {
        var float v_float;
        timer t_timer[5] := {1.0, 2.0, 3.0, 4.0, 5.0};
        
        t_timer[0].start(1.0);
        v_float := t_timer[1].read;
        if (t_timer[2].running)
        {
            t_timer[3].timeout;
        }
        t_timer[4].stop;
	}
	
	control
	{
        var float v_float;
        timer t_timer[5] := {1.0, 2.0, 3.0, 4.0, 5.0};
        
        t_timer[0].start(1.0);
        v_float := t_timer[1].read;
        if (t_timer[2].running)
        {
            t_timer[3].timeout;
        }
        t_timer[4].stop;
	}
}
/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Ensure that the alive keyword is properly evaluated
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_210308_killed_operation_003 {

    type component GeneralComp {}
	function f1 ( ) runs on GeneralComp {}
	
    testcase TC_Sem_210308_killed_operation_003() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
        var GeneralComp ptc2;
		ptc:=GeneralComp.create alive;
		ptc2:=GeneralComp.create;
		
		ptc.start(f1()); 
		ptc2.start(f1()); 
        
		ptc.stop;
		ptc2.stop;
		
		alt {
			[] all component.killed {setverdict(fail);} //ptc is alive only kill stops it
			[] ptc2.killed {setverdict(pass);}
		}

		
    }

    control {
        execute(TC_Sem_210308_killed_operation_003());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that any from killed is not triggered if no component has been started
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// When the any from component array notation is used, the components from the referenced array 
// are iterated over and individually checked for being killed from innermost to outermost 
// dimension from lowest to highest index for each dimension. The first component to be found 
// killed causes the killed operation to succeed.
module Sem_210308_killed_operation_004 {

    type component GeneralComp {}
	
	testcase TC_Sem_210308_killed_operation_004() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create;
		}
        alt
		{
        	[] any from v_ptc.killed { setverdict(fail, "The any from killed operation found killed component"); }
			[else] { setverdict(pass); } 
		}
    }

    control {
        execute(TC_Sem_210308_killed_operation_004(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify any from killed index redirection to lazy variable
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction f
// If a variable referenced in the @index clause is a lazy or fuzzy variable, the expression 
// assigned to this variable is equal to the result produced by the killed operation. Later 
// evaluation of the lazy or fuzzy variable does not lead to repeated invocation of the
// killed operation.
module Sem_210308_killed_operation_011 {

    type component GeneralComp {}

	function f(float p_time) runs on GeneralComp {
		timer t := p_time;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210308_killed_operation_011() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var @lazy integer v_index;
		timer t := 2.0;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i == 2) { v_ptc[i].start(f(1.0)); }
			else { v_ptc[i].start(f(100.0)); }
		}
		t.start;
		t.timeout;
        alt
		{
        	[] any from v_ptc.killed -> @index v_index { 
				v_ptc[0].kill; // component at position 0 is killed after the redirect assignment
				if(v_index == 2){ // no killed call during evaluation, v_index remains equal to 2
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from killed operation didn't found killed component"); } 
		}
    }

    control {
        execute(TC_Sem_210308_killed_operation_011(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that any from killed doesn't change index variable when no component has been killed
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The index of the matched component can optionally be assigned to an integer variable 
// for single-dimensional component arrays...
module Sem_210308_killed_operation_007 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210308_killed_operation_007() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index := 99;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create alive;
			v_ptc[i].start(f());
		}
        alt
		{
        	[] any from v_ptc.killed -> @index v_index { setverdict(fail, "The any from killed operation didn't found killed component"); }
			[else] { setverdict(pass); } 
		}
        if(v_index == 99){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_Sem_210308_killed_operation_007(), 5000.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that any from killed matches if at least one component is stopped or killed
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// When the any from component array notation is used, the components from the referenced array 
// are iterated over and individually checked for being killed from innermost to outermost 
// dimension from lowest to highest index for each dimension. The first component to be found 
// killed causes the killed operation to succeed.
module Sem_210308_killed_operation_005 {

    type component GeneralComp {}

	function f(float p_time) runs on GeneralComp {
		timer t := p_time;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210308_killed_operation_005() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		timer t := 2.0;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create;
			if (i == 3) { v_ptc[i].start(f(1.0)); }
			else { v_ptc[i].start(f(100.0)); }
		}
		t.start;
		t.timeout;
        alt
		{
        	[] any from v_ptc.killed { setverdict(pass); }
			[else] { setverdict(fail, "The any from killed operation didn't found killed component"); } 
		}
    }

    control {
        execute(TC_Sem_210308_killed_operation_005(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Ensure that all component kill can be checked with killed operator
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// all components are killed, than check the status with killed operator

module Sem_210308_killed_operation_001 {

    type component GeneralComp {}
	function f1 ( ) runs on GeneralComp {}
	
    testcase TC_Sem_210308_killed_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
        var GeneralComp ptc2;
		ptc:=GeneralComp.create alive;
		ptc2:=GeneralComp.create alive;
		
		ptc.start(f1()); 
		ptc2.start(f1()); 
        
		all component.kill;
		
		alt {
			[] all component.killed {setverdict(pass);}
		}

		
    }

    control {
        execute(TC_Sem_210308_killed_operation_001());
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:21.3.8, check that any component and killed operator can check that at least one test component is running or not
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// Check that at least one test component is still running or not
module Sem_210308_killed_operation_002 {

    type component GeneralComp {}
	function f1 ( ) runs on GeneralComp {}
	
    testcase TC_Sem_210308_killed_operation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
        var GeneralComp ptc2;
		ptc:=GeneralComp.create alive;
		ptc2:=GeneralComp.create alive;
		
		ptc.start(f1()); 
		ptc2.start(f1()); 
        
		ptc.kill;
		
		alt {
			[] any component.killed {setverdict(pass);}
		}

		
    }

    control {
        execute(TC_Sem_210308_killed_operation_002());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that any from killed is not triggered if when alive component has stopped execution
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// When the any from component array notation is used, the components from the referenced array 
// are iterated over and individually checked for being killed from innermost to outermost 
// dimension from lowest to highest index for each dimension. The first component to be found 
// killed causes the killed operation to succeed.
module Sem_210308_killed_operation_013 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 1.0;
		t.start;
		t.timeout;
	}

	testcase TC_Sem_210308_killed_operation_013() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		timer t := 2.0;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create alive;
			v_ptc[i].start(f());
		}
		t.start;
		t.timeout;
        alt
		{
        	[] any from v_ptc.killed { setverdict(fail, "The any from killed operation found killed component"); }
			[else] { setverdict(pass); } 
		}
    }

    control {
        execute(TC_Sem_210308_killed_operation_013(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:21.3.8, storing verdict in killed operation
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When the killed operation is applied to a PTC and matches, the final local verdict of the PTC
// can be retrieved and stored in variable of the type verdicttype. This is denoted by the 
// symbol '->' the keyword value followed by the name of the variable into which the verdict 
// is stored.

module Sem_210308_killed_operation_012 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		setverdict(pass);
	}
	
    testcase TC_Sem_210308_killed_operation_012() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
        var verdicttype v_verdict;
        v_ptc.start(f());
		alt {
			[] v_ptc.killed -> value v_verdict { 
                if (v_verdict != pass) { setverdict(fail, "Invalid PTC verdict"); }
            }
		}
    }

    control {
        execute(TC_Sem_210308_killed_operation_012(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify any from killed index redirection to fuzzy variable
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction f
// If a variable referenced in the @index clause is a lazy or fuzzy variable, the expression 
// assigned to this variable is equal to the result produced by the killed operation. Later 
// evaluation of the lazy or fuzzy variable does not lead to repeated invocation of the 
// killed operation.
module Sem_210308_killed_operation_012 {

    type component GeneralComp {}

	function f(float p_time) runs on GeneralComp {
		timer t := p_time;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210308_killed_operation_012() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var @fuzzy integer v_index;
		timer t := 2.0;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i == 2) { v_ptc[i].start(f(1.0)); }
			else { v_ptc[i].start(f(100.0)); }
		}
		t.start;
		t.timeout;
        alt
		{
        	[] any from v_ptc.killed -> @index v_index { 
				v_ptc[0].kill; // component at position 0 is killed after the redirect assignment
				if(v_index == 2){ // no killed call during evaluation, v_index remains equal to 2
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from killed operation didn't found killed component"); } 
		}
    }

    control {
        execute(TC_Sem_210308_killed_operation_012(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that any from killed index redirection works for multidimensional arrays
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction d:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module Sem_210308_killed_operation_010 {

    type component GeneralComp {}

	function f(float p_time) runs on GeneralComp {
		timer t := p_time;
		t.start;
		t.timeout;
		kill;
	}
	
    testcase TC_Sem_210308_killed_operation_010() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 3;
        var GeneralComp v_ptc[c_size][c_size];
		var integer v_index[2];
		timer t := 2.0;
		for (var integer i := 0; i < c_size; i := i + 1) {
			for (var integer j := 0; j < c_size; j := j + 1) {				
				v_ptc[i][j] := GeneralComp.create alive; // created components are inactive
				if (i == 2 and j == 1) { v_ptc[i][j].start(f(1.0)); }
				else { v_ptc[i][j].start(f(100.0));} // activate v_ptc
			}
		}
        t.start;
		t.timeout;
        alt
		{
        	[] any from v_ptc.killed -> @index v_index { 
				if(v_index[0] == 2 and v_index[1] == 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from killed operation didn't found killed component"); } 
		}
    }

    control {
        execute(TC_Sem_210308_killed_operation_010(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that any from killed doesn't assign index when no component has been killed
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The index of the matched component can optionally be assigned to an integer variable 
// for single-dimensional component arrays...
module Sem_210308_killed_operation_006 {

    type component GeneralComp {}
	
	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210308_killed_operation_006() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create alive;
			v_ptc[i].start(f());
		}
        alt
		{
        	[] any from v_ptc.killed -> @index v_index { setverdict(fail, "The any from killed operation didn't found killed component"); }
			[else] { setverdict(pass); } 
		}
        if(not isbound(v_index)){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
	}

    control {
        execute(TC_Sem_210308_killed_operation_006(), 5000.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that any from killed assigns index
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The index of the matched component can optionally be assigned to an integer variable 
// for single-dimensional component arrays...
module Sem_210308_killed_operation_008 {

    type component GeneralComp {}

	function f(float f_time) runs on GeneralComp {
		timer t := f_time;
		t.start;
		t.timeout;
		kill;
	}
	
    testcase TC_Sem_210308_killed_operation_008() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index;
		timer t := 2.0;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create alive;
			if (i == 2) { v_ptc[i].start(f(1.0)); }
			else { v_ptc[i].start(f(100.0)); }
		}
		t.start;
		t.timeout;
        alt
		{
        	[] any from v_ptc.killed -> @index v_index { 
				if(v_index == 2){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from killed operation didn't found killed component"); } 
		}
    }

    control {
        execute(TC_Sem_210308_killed_operation_008(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.8, Verify that any from killed is not triggered if all components are executing function
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// When the any from component array notation is used, the components from the referenced array 
// are iterated over and individually checked for being killed from innermost to outermost 
// dimension from lowest to highest index for each dimension. The first component to be found 
// killed causes the killed operation to succeed.
module Sem_210308_killed_operation_009 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}

	testcase TC_Sem_210308_killed_operation_009() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create alive;
			v_ptc[i].start(f());
		}
        alt
		{
        	[] any from v_ptc.killed { setverdict(fail, "The any from killed operation found killed component"); }
			[else] { setverdict(pass); } 
		}
    }

    control {
        execute(TC_Sem_210308_killed_operation_009(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:21.3.1, Ensure that unnamed components can be created
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_210301_CreateOperation_001 {

    type component GeneralComp {
        var NewComp vc_NewComp;
        timer t := 5.0;
    }
    type component NewComp { }
    
    function f_testComp() runs on GeneralComp {
        var NewComp v_NewComp := NewComp.create;
        t.start;
        a_createComp();
        setverdict(pass);
    }

    function f_createComp() return NewComp {
        return NewComp.create;
    }

    altstep a_createComp() runs on GeneralComp {
        [] t.timeout {
            vc_NewComp := NewComp.create;
            setverdict(pass);
        }
    }

    testcase TC_Sem_210301_CreateOperation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create;
        ptc.start(f_testComp());
        setverdict(pass);
    }

    control {
        execute(TC_Sem_210301_CreateOperation_001());
    }
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:21.3.1, Ensure that named components can be created
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_210301_CreateOperation_002 {

    type component GeneralComp {
        var NewComp vc_NewComp;
        timer t := 5.0;
    }

    type component NewComp { }
    
    function f_testComp() runs on GeneralComp {
        var NewComp v_NewComp := NewComp.create("1 & * 5abc");
        t.start;
        a_createComp();
        setverdict(pass);
    }

    function f_createComp() return NewComp {
        return NewComp.create("some name");
    }

    altstep a_createComp() runs on GeneralComp {
        [] t.timeout {
            vc_NewComp := NewComp.create("component#" & int2str(2));
            setverdict(pass);
        }
    }

    testcase TC_Sem_210301_CreateOperation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create("a component name");
        ptc.start(f_testComp());
        setverdict(pass);
    }

    control {
        execute(TC_Sem_210301_CreateOperation_002());
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:21.3.1, Ensure that unnamed alive components on hosts can be created
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_210301_CreateOperation_003 {

    type component GeneralComp {
        var NewComp vc_NewComp;
        timer t := 5.0;
    }

    type component NewComp { }
    
    function f_testComp() runs on GeneralComp {
        var NewComp v_NewComp := NewComp.create alive;
        t.start;
        a_createComp();
        setverdict(pass);
    }

    function f_createComp() return NewComp {
        return NewComp.create alive;
    }

    altstep a_createComp() runs on GeneralComp {
        [] t.timeout {
            vc_NewComp := NewComp.create alive;
            setverdict(pass);
        }
    }

    testcase TC_Sem_210301_CreateOperation_003() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create alive;
        ptc.start(f_testComp());
        setverdict(pass);
    }

    control {
        execute(TC_Sem_210301_CreateOperation_003());
    }
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:21.3.1, Ensure that named components on hosts are accepted
 ** @verdict  pass accept, noexecution
 *****************************************************************/
// only syntactic test since it cannot be tested if "localhost" is not supported for component creation
module Syn_210301_CreateOperation_001 {
    const charstring hostname := "localhost";

    type component GeneralComp {
        var NewComp vc_NewComp;
        timer t := 5.0;
    }

    type component NewComp { }
    
    function f_testComp() runs on GeneralComp {
        var NewComp v_NewComp := NewComp.create("1 & * 5abc", hostname);
        t.start;
        a_createComp();
        setverdict(pass);
    }

    function f_createComp() return NewComp {
        return NewComp.create(-, "localhost");
    }

    altstep a_createComp() runs on GeneralComp {
        [] t.timeout {
            vc_NewComp := NewComp.create("component#" & int2str(2), hostname);
            setverdict(pass);
        }
    }

    testcase TC_Syn_210301_CreateOperation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create("a component name", "localhost");
        ptc.start(f_testComp());
        setverdict(pass);
    }

    control {
        execute(TC_Syn_210301_CreateOperation_001());
    }
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:21.3.1, Ensure that named alive components can be created
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_210301_CreateOperation_004 {
    const charstring componentName := "component#";

    type component GeneralComp {
        var NewComp vc_NewComp;
        timer t := 5.0;
    }

    type component NewComp { }
    
    function f_testComp() runs on GeneralComp {
        var NewComp v_NewComp := NewComp.create("1 & * 5abc") alive;
        t.start;
        a_createComp();
        setverdict(pass);
    }

    function f_createComp() return NewComp {
        return NewComp.create("some name") alive;
    }

    altstep a_createComp() runs on GeneralComp {
        [] t.timeout {
            vc_NewComp := NewComp.create(componentName & int2str(2)) alive;
            setverdict(pass);
        }
    }

    testcase TC_Sem_210301_CreateOperation_004() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create("a component name") alive;
        ptc.start(f_testComp());
        setverdict(pass);
    }

    control {
        execute(TC_Sem_210301_CreateOperation_004());
    }

}/*****************************************************************
 ** @author   STF 451, modified by STF 487
 ** @version  0.0.1
 ** @purpose  1:21.3.4, Ensure that self kill called in a functions stops non alive test comp.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// non alive test component calls function with self.kill

module Sem_210304_kill_test_component_004 {
	
    type component GeneralComp {
    	timer t;
    }
	function f() runs on GeneralComp {
	    self.kill;
	    setverdict(fail);
	}

	
    testcase TC_Sem_210304_kill_test_component_004() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create;

		ptc.start(f()); 
		t.start(5.0);
		alt {
            [] ptc.killed { setverdict(pass); }
            [] t.timeout { setverdict(fail); }
		}
    }

    control {
        execute(TC_Sem_210304_kill_test_component_004());
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:21.3.4, killing MTC from PTC
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// The kill operation can be applied on the current test component itself by a simple 
// kill statement or by addressing itself using the self operation in conjunction with
// the kill operation.


module Sem_210304_kill_test_component_006 {
    
    type component GeneralComp {
    	timer t;
    }
    
	function f() runs on GeneralComp {
        var boolean v_bCond := true;
        setverdict(pass);
        if (v_bCond) { mtc.kill; } // to bypass possible "unreachable statement" errors
	    setverdict(fail);
	}
	
    testcase TC_Sem_210304_kill_test_component_006() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create alive;

		ptc.start(f()); 
		t.start(5.0);
		t.timeout;
        setverdict(fail);
    }

    control {
        execute(TC_Sem_210304_kill_test_component_006());
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:21.3.4, standalone kill in alive PTC
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// The kill operation can be applied on the current test component itself by a simple 
// kill statement or by addressing itself using the self operation in conjunction with
// the kill operation.


module Sem_210304_kill_test_component_005 {
	
    type component GeneralComp {
    	timer t;
    }
    
	function f() runs on GeneralComp {
        var boolean v_bCond := true;
        if (v_bCond) { kill; } // to bypass possible "unreachable statement" errors
	    setverdict(fail);
	}
	
    testcase TC_Sem_210304_kill_test_component_005() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc := GeneralComp.create alive;

		ptc.start(f()); 
		t.start(5.0);
		alt {
            [] ptc.killed { setverdict(pass); }
            [] t.timeout { setverdict(fail); }
		}
    }

    control {
        execute(TC_Sem_210304_kill_test_component_005());
    }
}/*****************************************************************
 ** @author   STF 451, modified by STF 487
 ** @version  0.0.1
 ** @purpose  1:21.3.4, Ensure that kill operator stops a non alive test components.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// The kill operation applied on a test component stops the execution of the currently
// running behaviour - if any - of that component and frees all resources associated 
// to it (including all port connections of the killed component) and removes the 
// component from the test system. 
//
// The kill operation can also be applied to another test component. In this case the 
// component to be killed shall be addressed using its component reference. 

module Sem_210304_kill_test_component_001 {

    type port P message {
        inout integer;
    }
    
    type component GeneralComp { 
        port P p;
    }
    
	function f() runs on GeneralComp {
        p.receive(integer:?);
    }
	
    testcase TC_Sem_210304_kill_test_component_001() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
		ptc:=GeneralComp.create;
		
		ptc.start(f()); 
        ptc.kill;
        ptc.killed;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_210304_kill_test_component_001());
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:21.3.4, Ensure that all component kill stop all ptcs
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Kill all component (ptc and ptc2) with all component.kill
module Sem_210304_kill_test_component_002 {

    type component GeneralComp {
	 var integer v_gc:=0; 
	 var integer v_res:=0;}
	function f1 ( ) runs on GeneralComp {}
	
    testcase TC_Sem_210304_kill_test_component_002() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
        var GeneralComp ptc2;
		ptc:=GeneralComp.create alive;
		ptc2:=GeneralComp.create alive;
		
		ptc.start(f1()); 
		ptc2.start(f1()); 
        
        all component.kill;
		
		if (all component.alive==false) { 
        setverdict(pass);
        }
        else
        {
        setverdict(fail);
        }
     
    }

    control {
        execute(TC_Sem_210304_kill_test_component_002());
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:21.3.4, Ensure that kill operator stops only non alive test components
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Kill only stops non alive test components
module Sem_210304_kill_test_component_003 {

    type component GeneralComp {
	 var integer v_gc:=0; 
	 var integer v_res:=0;}
	function f1 ( ) runs on GeneralComp {}
	
    testcase TC_Sem_210304_kill_test_component_003() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
        var GeneralComp ptc2;
		ptc:=GeneralComp.create alive;
		ptc2:=GeneralComp.create alive;
		
		ptc.start(f1()); 
		ptc2.start(f1()); 
        ptc.kill;
        
		
		if (match(ptc.alive, false) and match(ptc2.alive, true)) { 
        setverdict(pass);
        }
        else
        {
        setverdict(fail);
        }
     
    }

    control {
        execute(TC_Sem_210304_kill_test_component_003());
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:21.3.3, stopping all PTCs
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// The all keyword can be used by the MTC only in order to stop all running PTCs but 
// the MTC itself.

module Sem_210303_Stop_test_component_011 {

    type port P message {
        inout integer;
    }
    
    type component GeneralComp {
        port P p;
    }
    
	function f() runs on GeneralComp {
        p.receive(integer:?); // infinite blocking
	}
	
    testcase TC_Sem_210303_Stop_test_component_011() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc1 := GeneralComp.create, ptc2 := GeneralComp.create;
		ptc1.start(f()); 
        ptc2.start(f()); 
        all component.stop;
		interleave {
            [] ptc1.done {}
            [] ptc2.done {}
        }
        setverdict(pass);
    }

    control {
        execute(TC_Sem_210303_Stop_test_component_011());
    }
}/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.2, verdict value reuse in alive component after explicit stop
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// Furthermore, the local verdict of the component keeps its value.

module Sem_210303_Stop_test_component_009 { 

    type port P message {
        inout integer;
    }
    
	type component GeneralComp {
        port P p;
	}
    
    function f_ptcBehaviour() runs on GeneralComp {
        setverdict(pass);
        p.send(1);
        p.receive(integer:?);
        setverdict(fail);
    }

    function f_ptcSecondBehaviour() runs on GeneralComp {
        if (getverdict != pass) { setverdict(fail); }
    }

    
	testcase TC_Sem_210303_Stop_test_component_009() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC") alive;
        connect(self:p, v_ptc:p);
        v_ptc.start(f_ptcBehaviour());
        p.receive(integer:?);
        v_ptc.stop;
        v_ptc.start(f_ptcSecondBehaviour());
        v_ptc.done;
	}
	
	control{
	    execute(TC_Sem_210303_Stop_test_component_009());
	}
}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:21.3.3, stop.self in MTC
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// A component can stop its own behaviour by using a simple stop execution statement 
// (see clause 19.9) or by addressing itself in the stop operation, e.g. by using the 
// self operation.
//
// If the stopped test component is the MTC, resources of all existing PTCs shall be 
// released, the PTCs shall be removed from the test system and the test case shall 
// terminate (see clause 26.1). 

module Sem_210303_Stop_test_component_004 {

    type component GeneralComp {
    }
    
	function f() runs on GeneralComp {
        timer t_tmr := 2.0; 
        t_tmr.start;
        t_tmr.timeout;
        setverdict(fail); // in case the stop operation doesn't work
	}
	
    testcase TC_Sem_210303_Stop_test_component_004() runs on GeneralComp system GeneralComp {
        var boolean v_cond := true;
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f()); 
		if (v_cond) { // to prevent "unreachable statement" errors
            setverdict(pass);
            self.stop; // stops the MTC and as a consequence the PTC is stopped too
        }
        setverdict(fail); // this statement shall never be reached
    }
    
    testcase TC_Sem_210303_Stop_test_component_004_next() runs on GeneralComp system GeneralComp {
        timer t_tmr := 2.5; 
        t_tmr.start;
        t_tmr.timeout;
        setverdict(pass);
    }

    control {
        execute(TC_Sem_210303_Stop_test_component_004());
        // run another test case to make sure the PTC is not active and doesn't influence its result
        execute(TC_Sem_210303_Stop_test_component_004_next());
    }
}/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.3, component variable value reuse in alive component after explicit stop
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// Stopping an alive-type component means that all variables, timers and ports 
// declared in the component type definition of the alive-type component keep their
// value, contents or state. 

module Sem_210303_Stop_test_component_006 { 

    type port P message {
        inout charstring;
    }
        
	type component GeneralComp {
        var integer vc_val := 0;
        port P p;
	}
    
    function f_ptcBehaviour() runs on GeneralComp {
        vc_val := 1;
        p.send("PTC started");
        p.receive(charstring:?); // this will never come
        setverdict(fail);
    }

    function f_ptcSecondBehaviour() runs on GeneralComp {
        if (vc_val == 1) { setverdict(pass); }
        else { setverdict(fail); }
    }

    
	testcase TC_Sem_210303_Stop_test_component_006() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC") alive;
        connect(self:p, v_ptc:p);
        v_ptc.start(f_ptcBehaviour());
        p.receive(charstring:?);
        v_ptc.stop;
        p.send("greetings from the MTC");
        v_ptc.start(f_ptcSecondBehaviour());
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_Sem_210303_Stop_test_component_006());
	}
}
/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.3, alive component restart after explicit stop
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// Stopping an alive-type component shall stop the currently running behaviour only 
// but the component continues to exist and can execute new behaviour (started on 
// it using the start operation). 

module Sem_210303_Stop_test_component_005 { 

	type component GeneralComp {
	}
    
    function f_ptcBehaviour() runs on GeneralComp {
    }

    function f_ptcSecondBehaviour() runs on GeneralComp {
        setverdict(pass);
    }

    
	testcase TC_Sem_210303_Stop_test_component_005() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC") alive;
        v_ptc.start(f_ptcBehaviour());
        v_ptc.stop;
        v_ptc.start(f_ptcSecondBehaviour());
        v_ptc.done;
	}
	
	control{
	    execute(TC_Sem_210303_Stop_test_component_005());
	}
}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:21.3.3, stopping MTC from PTC
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// By using the stop test component statement a test component can stop the execution
// of its own currently running test behaviour or the execution of the test behaviour
// running on another test component. If a component does not stop its own behaviour,
// but the behaviour running on another test component in the test system, the component
// to be stopped has to be identified by using its component reference. 
//
// If the stopped test component is the MTC, resources of all existing PTCs shall be 
// released, the PTCs shall be removed from the test system and the test case shall 
// terminate (see clause 26.1). 

module Sem_210303_Stop_test_component_003 {

    type component GeneralComp {
    }
    
	function f() runs on GeneralComp {
        var boolean v_cond := true;
        if (v_cond) { // to prevent "unreachable statement" errors
            setverdict(pass);
            mtc.stop; //stops the MTC and as a consequence the PTC is stopped too
        }
        setverdict(fail); // in case the stop operation doesn't work
	}
	
    testcase TC_Sem_210303_Stop_test_component_003() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f()); 
		v_ptc.done;
        setverdict(fail); // this statement shall never be reached
    }

    control {
        execute(TC_Sem_210303_Stop_test_component_003());
    }
}/*****************************************************************
 ** @author   STF 451, updated by STF 487
 ** @version  0.0.1
 ** @purpose  1:21.3.3, Ensure that self.stop stops current component 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// A component can stop its own behaviour by using a simple stop execution statement
// (see clause 19.9) or by addressing itself in the stop operation, e.g. by using 
// the self operation.

module Sem_210303_Stop_test_component_002 {

    type component GeneralComp {
    }
	function f() runs on GeneralComp {
        var boolean v_cond := true;
        if (v_cond) {
            setverdict(pass);
            self.stop; //stops the ptc
        }
        setverdict(fail); // in case the stop operation doesn't work
	}
	
    testcase TC_Sem_210303_Stop_test_component_002() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
		v_ptc.start(f()); 
		v_ptc.done;     
    }

    control {
        execute(TC_Sem_210303_Stop_test_component_002());
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:21.3.3, Ensure that component.stop causes the stopping of the target component. 
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_210303_Stop_test_component_001 {

    type component GeneralComp { }

    function f() runs on GeneralComp {
    	// wait until component is stopped from outside
        while (true) {}
    }

	
    testcase TC_Sem_210303_Stop_test_component_001() runs on GeneralComp system GeneralComp {
        timer t := 1.0;
        var GeneralComp ptc;
        ptc:=GeneralComp.create;
		
        ptc.start(f());
	
		// wait until component started
		t.start;
		t.timeout;

        ptc.stop;
        
		// Test ptc behavior after stop
        if (ptc.running==false)
        {
            setverdict(pass);
        }
        else
        {
            setverdict(fail, "Component still running");
        }
     
    }

    control {
        execute(TC_Sem_210303_Stop_test_component_001());
    }
}/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.3, deactivation of defaults in alive components after explicit stop
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// In contrast to that, all active defaults are automatically deactivated when 
// the alive-type component is stopped. 

module Sem_210303_Stop_test_component_010 { 

    type port P message {
        inout integer;
    }
    
	type component GeneralComp {
        timer tc_tmr := 1.0;
        port P p;
	}
    
    altstep a_receive() runs on GeneralComp {
        [] p.receive(integer:?) { setverdict(fail); }
    }
    
    function f_ptcBehaviour() runs on GeneralComp {
        activate(a_receive());
        p.send(1);
        p.receive(integer:?); // infinite blocking as MTC doesn't send anything
        setverdict(fail);
    }

    function f_ptcSecondBehaviour() runs on GeneralComp {
        tc_tmr.start;
        alt {
            [] tc_tmr.timeout { setverdict(pass); }
        }
    }

    
	testcase TC_Sem_210303_Stop_test_component_010() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC") alive;
        connect(self:p, v_ptc:p);
        v_ptc.start(f_ptcBehaviour());
        p.receive(integer:?);
        v_ptc.stop;
        p.send(2);
        v_ptc.start(f_ptcSecondBehaviour());
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_Sem_210303_Stop_test_component_010());
	}
}/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.3, timer reuse in alive component after explicit stop
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// Stopping an alive-type component means that all variables, timers and ports 
// declared in the component type definition of the alive-type component keep their
// value, contents or state.

module Sem_210303_Stop_test_component_007 { 

    type port P message {
        inout integer;
    }
    
	type component GeneralComp {
        timer tc_tmr := 2.0;
        port P p;
	}
    
    function f_ptcBehaviour() runs on GeneralComp {
        tc_tmr.start;
        p.send(1);
        p.receive(integer:?);
        setverdict(fail);
    }

    function f_ptcSecondBehaviour() runs on GeneralComp {
        tc_tmr.timeout;
        setverdict(pass);
    }

    
	testcase TC_Sem_210303_Stop_test_component_007() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC") alive;
        connect(self:p, v_ptc:p);
        v_ptc.start(f_ptcBehaviour());
        p.receive(integer:?);
        v_ptc.stop;
        v_ptc.start(f_ptcSecondBehaviour());
        v_ptc.done;
	}
	
	control{
	    execute(TC_Sem_210303_Stop_test_component_007());
	}
}

/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.3, port reuse in alive component after explicit stop
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// Stopping an alive-type component means that all variables, timers and ports 
// declared in the component type definition of the alive-type component keep their
// value, contents or state. 

module Sem_210303_Stop_test_component_008 { 

    type port P message {
        inout integer;
    }
    
	type component GeneralComp {
        port P p1, p2;
	}
    
    function f_ptcBehaviour() runs on GeneralComp {
        connect(self:p1, self:p1); // loopback
        connect(mtc:p2, self:p2); // mtc
        p1.send(1);
        p2.send(2);
        p2.receive(integer:?);
        setverdict(fail);
    }

    function f_ptcSecondBehaviour() runs on GeneralComp {
        p1.receive(integer:?);
        setverdict(pass);
    }

    
	testcase TC_Sem_210303_Stop_test_component_008() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC") alive;        
        v_ptc.start(f_ptcBehaviour());        
        p2.receive(integer:?);
        v_ptc.stop;
        v_ptc.start(f_ptcSecondBehaviour());
        v_ptc.done;
	}
	
	control{
	    execute(TC_Sem_210303_Stop_test_component_008());
	}
}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify any from done index redirection to fuzzy variable
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction g
// If a variable referenced in the @index clause is a lazy or fuzzy variable, the expression 
// assigned to this variable is equal to the result produced by the done operation. Later 
// evaluation of the lazy or fuzzy variable does not lead to repeated invocation of the 
// done operation.
module Sem_210307_done_operation_010 {

    type component GeneralComp {}

	function f(float p_time) runs on GeneralComp {
		timer t := p_time;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210307_done_operation_010() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var @fuzzy integer v_index;
		timer t := 2.0;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i == 2) { v_ptc[i].start(f(1.0)); }
			else { v_ptc[i].start(f(100.0)); }
		}
		t.start;
		t.timeout;
        alt
		{
        	[] any from v_ptc.done -> @index v_index { 
				v_ptc[0].kill; // component at position 0 is killed after the redirect assignment
				if(v_index == 2){ // no done call during evaluation, v_index remains equal to 2
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from done operation didn't found stopped or killed component"); } 
		}
    }

    control {
        execute(TC_Sem_210307_done_operation_010(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:21.3.7, storing verdict in done operation
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirements are tested:
// When the done operation is applied to a PTC and matches, the final local verdict of the PTC
// can be retrieved and stored in variable of the type verdicttype. This is denoted by the 
// symbol '->' the keyword value followed by the name of the variable into which the verdict 
// is stored.

module Sem_210307_done_operation_012 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		setverdict(pass);
	}
	
    testcase TC_Sem_210307_done_operation_012() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
        var verdicttype v_verdict;
        v_ptc.start(f());
		alt {
			[] v_ptc.done -> value v_verdict { 
                if (v_verdict != pass) { setverdict(fail, "Invalid PTC verdict"); }
            }
		}
    }

    control {
        execute(TC_Sem_210307_done_operation_012(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Ensure that all component with done can check that at least one test component is not done
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// Any component done to check that two test component finished.

module Sem_210307_done_operation_001 {

    type component GeneralComp {}
	function f1 ( ) runs on GeneralComp {}
	
    testcase TC_Sem_210307_done_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
        var GeneralComp ptc2;
		ptc:=GeneralComp.create alive;
		ptc2:=GeneralComp.create alive;
		
		ptc.start(f1()); 
		ptc2.start(f1()); 
        
		all component.done;
		
		alt {
			[] all component.done {setverdict(pass);}
		}

		
    }

    control {
        execute(TC_Sem_210307_done_operation_001());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that any from done is not triggered if no component has been started
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// When the any from component array notation is used, the components from the referenced array 
// are iterated over and individually checked for being stopped or killed from innermost to 
// outermost dimension from lowest to highest index for each dimension. The first component to 
// be found stopped or killed causes the done operation to succeed.
module Sem_210307_done_operation_002 {

    type component GeneralComp {}
	
	testcase TC_Sem_210307_done_operation_002() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create;
		}
        alt
		{
        	[] any from v_ptc.done { setverdict(fail, "The any from done operation found stopped or killed component"); }
			[else] { setverdict(pass); } 
		}
    }

    control {
        execute(TC_Sem_210307_done_operation_002(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that any from done doesn't assign index when no component has been stopped or killed
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The index of the matched component can optionally be assigned to an integer variable 
// for single-dimensional component arrays...
module Sem_210307_done_operation_004 {

    type component GeneralComp {}
	
	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210307_done_operation_004() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create;
			v_ptc[i].start(f());
		}
        alt
		{
        	[] any from v_ptc.done -> @index v_index { setverdict(fail, "The any from done operation didn't found stopped or killed component"); }
			[else] { setverdict(pass); } 
		}
        if(not isbound(v_index)){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
	}

    control {
        execute(TC_Sem_210307_done_operation_004(), 5000.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that any from done assigns index
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The index of the matched component can optionally be assigned to an integer variable 
// for single-dimensional component arrays...
module Sem_210307_done_operation_006 {

    type component GeneralComp {}

	function f(float f_time) runs on GeneralComp {
		timer t := f_time;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210307_done_operation_006() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index;
		timer t := 2.0;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i == 2) { v_ptc[i].start(f(1.0)); }
			else { v_ptc[i].start(f(100.0)); }
		}
		t.start;
		t.timeout;
        alt
		{
        	[] any from v_ptc.done -> @index v_index { 
				if(v_index == 2){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from done operation didn't found stopped or killed component"); } 
		}
    }

    control {
        execute(TC_Sem_210307_done_operation_006(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that all component.done produces true if some components haven't been started
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// When the all keyword is used with the done operation, it matches if no one PTC is executing its 
// behaviour. It also matches if no PTC has been created.
// Interpretation according to the following note:
// The difference between the done operation applied to a single ptc and the usage of the all 
// keyword leads to the situation that ptc.done does not match if the ptc has never been started 
// but all component.done matches at the same time as it considers only those components that 
// ever have been started .
module Sem_210307_done_operation_011 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210307_done_operation_011() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 4;
        var GeneralComp v_ptc := GeneralComp.create;
		alt {
			[] v_ptc.done { setverdict(fail, "PTC is not done yet (it actually hasn't been started yet)" )}
			[] all component.done { setverdict(pass); }
			[else] { setverdict(fail, "all component.done wasn't triggered"); }
		}
    }

    control {
        execute(TC_Sem_210307_done_operation_011(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that any from done doesn't change index variable when no component has been stopped or killed
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The index of the matched component can optionally be assigned to an integer variable 
// for single-dimensional component arrays...
module Sem_210307_done_operation_005 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210307_done_operation_005() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index := 99;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create;
			v_ptc[i].start(f());
		}
        alt
		{
        	[] any from v_ptc.done -> @index v_index { setverdict(fail, "The any from done operation didn't found stopped or killed component"); }
			[else] { setverdict(pass); } 
		}
        if(v_index == 99){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_Sem_210307_done_operation_005(), 5000.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify any from done index redirection to lazy variable
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction g
// If a variable referenced in the @index clause is a lazy or fuzzy variable, the expression 
// assigned to this variable is equal to the result produced by the done operation. Later 
// evaluation of the lazy or fuzzy variable does not lead to repeated invocation of the
// done operation.
module Sem_210307_done_operation_009 {

    type component GeneralComp {}

	function f(float p_time) runs on GeneralComp {
		timer t := p_time;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210307_done_operation_009() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var @lazy integer v_index;
		timer t := 2.0;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i == 2) { v_ptc[i].start(f(1.0)); }
			else { v_ptc[i].start(f(100.0)); }
		}
		t.start;
		t.timeout;
        alt
		{
        	[] any from v_ptc.done -> @index v_index { 
				v_ptc[0].kill; // component at position 0 is killed after the redirect assignment
				if(v_index == 2){ // no done call during evaluation, v_index remains equal to 2
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from done operation didn't found stopped or killed component"); } 
		}
    }

    control {
        execute(TC_Sem_210307_done_operation_009(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that any from done matches if at least one component is stopped or killed
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// When the any from component array notation is used, the components from the referenced array 
// are iterated over and individually checked for executing currently from innermost to outermost 
// dimension from lowest to highest index for each dimension. The first component to be found 
// executing causes the done operation to succeed.
module Sem_210307_done_operation_003 {

    type component GeneralComp {}

	function f(float p_time) runs on GeneralComp {
		timer t := p_time;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210307_done_operation_003() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		timer t := 2.0;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i == 3) { v_ptc[i].start(f(1.0)); }
			else { v_ptc[i].start(f(100.0)); }
		}
		t.start;
		t.timeout;
        alt
		{
        	[] any from v_ptc.done { setverdict(pass); }
			[else] { setverdict(fail, "The any from done operation didn't found stopped or killed component"); } 
		}
    }

    control {
        execute(TC_Sem_210307_done_operation_003(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that any from done index redirection works for multidimensional arrays
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction e:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module Sem_210307_done_operation_008 {

    type component GeneralComp {}

	function f(float p_time) runs on GeneralComp {
		timer t := p_time;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210307_done_operation_008() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 3;
        var GeneralComp v_ptc[c_size][c_size];
		var integer v_index[2];
		timer t := 2.0;
		for (var integer i := 0; i < c_size; i := i + 1) {
			for (var integer j := 0; j < c_size; j := j + 1) {				
				v_ptc[i][j] := GeneralComp.create; // created components are inactive
				if (i == 2 and j == 1) { v_ptc[i][j].start(f(1.0)); }
				else { v_ptc[i][j].start(f(100.0));} // activate v_ptc
			}
		}
        t.start;
		t.timeout;
        alt
		{
        	[] any from v_ptc.done -> @index v_index { 
				if(v_index[0] == 2 and v_index[1] == 1){
		            setverdict(pass);
		        } else {
		            setverdict(fail, "Index incorrectly assigned");
		        }
			}
			[else] { setverdict(fail, "The any from done operation didn't found stopped or killed component"); } 
		}
    }

    control {
        execute(TC_Sem_210307_done_operation_008(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.7, Verify that any from done is not triggered if all components are executing function
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// When the any from component array notation is used, the components from the referenced array 
// are iterated over and individually checked for being stopped or killed from innermost to 
// outermost dimension from lowest to highest index for each dimension. The first component to 
// be found stopped or killed causes the done operation to succeed.
module Sem_210307_done_operation_007 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}

	testcase TC_Sem_210307_done_operation_007() runs on GeneralComp system GeneralComp {
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create;
			v_ptc[i].start(f());
		}
        alt
		{
        	[] any from v_ptc.done { setverdict(fail, "The any from done operation found stopped or killed component"); }
			[else] { setverdict(pass); } 
		}
    }

    control {
        execute(TC_Sem_210307_done_operation_007(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that any from alive index redirection works for multidimensional arrays
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction e:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module Sem_210305_alive_operation_011 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210305_alive_operation_011() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		const integer c_size := 3;
        var GeneralComp v_ptc[c_size][c_size];
		var integer v_index[2];
		for (var integer i := 0; i < c_size; i := i + 1) {
			for (var integer j := 0; j < c_size; j := j + 1) {				
				v_ptc[i][j] := GeneralComp.create; // created components are inactive
				if (i mod 2 == 0 or j mod 2 == 1) { v_ptc[i][j].kill; } // kill components on even i or odd j
				else { v_ptc[i][j].start(f());} // activate v_ptc
			}
		}
        v_isAlive := any from v_ptc.alive -> @index v_index;
        if(v_index[0] == 1 and v_index[1] == 0){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_Sem_210305_alive_operation_011(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Test all component alive operator with alive test components
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
//Test all component alive operator in case when two alive test components is already running

module Sem_210305_alive_operation_002 {

    type component GeneralComp {
	 var integer v_gc:=0; 
	 var integer v_res:=0;}
	function f1 ( ) runs on GeneralComp {}
	
    testcase TC_Sem_210305_alive_operation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
        var GeneralComp ptc2;
		ptc:=GeneralComp.create alive;
		ptc2:=GeneralComp.create alive;
		
		ptc.start(f1()); 
		ptc2.start(f1()); 
        ptc.done;
		
		if (all component.alive) { 
        setverdict(pass);
        }
        else
        {
        setverdict(fail);
        }
     
    }

    control {
        execute(TC_Sem_210305_alive_operation_002());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that any from alive doesn't assign index when no component is alive
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The index of the first component found alive can optionally be assigned to an integer 
// variable for  single-dimensional component arrays
module Sem_210305_alive_operation_008 {

    type component GeneralComp {}

    testcase TC_Sem_210305_alive_operation_008() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create;
			v_ptc[i].kill;
		}
        v_isAlive := any from v_ptc.alive -> @index v_index;
        if(not isbound(v_index)){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_Sem_210305_alive_operation_008(), 5000.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that any from alive can be used inside expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The index of the first component found alive can optionally be assigned to an integer 
// variable for  single-dimensional component arrays.
module Sem_210305_alive_operation_010 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210305_alive_operation_010() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate PTC
		}
        v_isAlive := any from v_ptc.alive -> @index v_index and v_index == 1;
        if(v_isAlive){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from alive operation didn't find alive components");
        }
    }

    control {
        execute(TC_Sem_210305_alive_operation_010(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that any from alive doesn't change index variable when no component is alive
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The index of the first component found alive can optionally be assigned to an integer 
// variable for  single-dimensional component arrays
module Sem_210305_alive_operation_012 {

    type component GeneralComp {}

    testcase TC_Sem_210305_alive_operation_012() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index := 99;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create;
			v_ptc[i].kill;
		}
        v_isAlive := any from v_ptc.alive -> @index v_index;
        if(v_index == 99){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_Sem_210305_alive_operation_012(), 5000.0);
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Ensure that alive operator gives a correct boolean result
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// Two alive test components.ptc killed, than the alive check.
module Sem_210305_alive_operation_003 {

    type component GeneralComp {
	 var integer v_gc:=0; 
	 var integer v_res:=0;}
	function f1 ( ) runs on GeneralComp {}
	
    testcase TC_Sem_210305_alive_operation_003() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
        var GeneralComp ptc2;
		ptc:=GeneralComp.create alive;
		ptc2:=GeneralComp.create alive;
		
		ptc.start(f1()); 
		ptc2.start(f1()); 
        ptc.kill;
		
		if (match(ptc.alive, false) and match(ptc2.alive, true)) { 
        setverdict(pass);
        }
        else
        {
        setverdict(fail);
        }
     
    }

    control {
        execute(TC_Sem_210305_alive_operation_003());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify any from alive index redirection to lazy variable
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction f
// If a variable referenced in the @index clause is a lazy or fuzzy variable, the expression 
// assigned to this variable is equal to the result produced by the alive operation. Later 
// evaluation of the lazy or fuzzy variable does not lead to repeated invocation of the alive 
// operation.
module Sem_210305_alive_operation_013 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210305_alive_operation_013() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var @lazy integer v_index;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate v_ptc
		}
        v_isAlive := any from v_ptc.alive -> @index v_index;
		v_ptc[1].kill; // component at position 1 is killed after the redirect assignment
        if(v_index == 1) { // no alive call during evaluation, v_index remains equal to 1
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_Sem_210305_alive_operation_013(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that any from alive returns true if at least one component is inactive
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// When the any from component array notation is used, the components from the referenced array 
// are iterated over and individually checked for being inactive or running a function from 
// innermost to outermost dimension from lowest to highest index for each dimension. The first 
// component to be found being inactive or running a function causes the alive operation to 
// return the true value.
module Sem_210305_alive_operation_006 {

    type component GeneralComp {}

    testcase TC_Sem_210305_alive_operation_006() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
		}
        v_isAlive := any from v_ptc.alive;
        if(v_isAlive){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from alive operation didn't find alive components");
        }
    }

    control {
        execute(TC_Sem_210305_alive_operation_006(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify any from alive index redirection to fuzzy variable
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction f
// If a variable referenced in the @index clause is a lazy or fuzzy variable, the expression 
// assigned to this variable is equal to the result produced by the alive operation. Later 
// evaluation of the lazy or fuzzy variable does not lead to repeated invocation of the alive 
// operation.
module Sem_210305_alive_operation_014 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210305_alive_operation_014() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var @fuzzy integer v_index;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate v_ptc
		}
        v_isAlive := any from v_ptc.alive -> @index v_index;
		v_ptc[1].kill; // component at position 1 is killed after the redirect assignment
        if(v_index == 1) { // no alive call during evaluation, v_index remains equal to 1
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_Sem_210305_alive_operation_014(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that any from alive returns true if at least one component is running
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// When the any from component array notation is used, the components from the referenced array 
// are iterated over and individually checked for being inactive or running a function from 
// innermost to outermost dimension from lowest to highest index for each dimension. The first 
// component to be found being inactive or running a function causes the alive operation to 
// return the true value.
module Sem_210305_alive_operation_007 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210305_alive_operation_007() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate v_ptc
		}
        v_isAlive := any from v_ptc.alive;
        if(v_isAlive){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from alive operation didn't find alive components");
        }
    }

    control {
        execute(TC_Sem_210305_alive_operation_007(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Testing alive operator with an alive test component
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// Alive test component calls a function f1. Afterwards calls f2 function

module Sem_210305_alive_operation_001 {

    type component GeneralComp {
	 var integer v_gc:=0; 
	 var integer v_res:=0;}
	function f1 ( ) runs on GeneralComp {}

	function f2 ( integer p_integer ) runs on GeneralComp return integer {
		v_gc:=p_integer*p_integer;
 		return v_gc;
	}
    testcase TC_Sem_210305_alive_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
		ptc:=GeneralComp.create alive;
		
		ptc.start(f1()); 
	
        ptc.done;
		
		if (ptc.alive) { 
		ptc.start(f2(3));
		v_res:=f2(3);
}

		if(v_res==9)
		{
        setverdict(pass);
        }
        else
        {
        setverdict(fail);
        }
     
    }

    control {
        execute(TC_Sem_210305_alive_operation_001());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that any from alive returns false if no component is alive
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// When the any from component array notation is used, the components from the referenced array 
// are iterated over and individually checked for being inactive or running a function from 
// innermost to outermost dimension from lowest to highest index for each dimension. The first 
// component to be found being inactive or running a function causes the alive operation to 
// return the true value.
module Sem_210305_alive_operation_005 {

    type component GeneralComp {}

    testcase TC_Sem_210305_alive_operation_005() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create;
			v_ptc[i].kill;
		}
        v_isAlive := any from v_ptc.alive;
        if(not v_isAlive){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from alive operation incorrectly detected an alive component");
        }
    }

    control {
        execute(TC_Sem_210305_alive_operation_005(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Test any component alive operator with multiple test components
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// Any component alive test with two test components.

module Sem_210305_alive_operation_004 {

    type component GeneralComp {
	 var integer v_gc:=0; 
	 var integer v_res:=0;}
	function f1 ( ) runs on GeneralComp {}
	
    testcase TC_Sem_210305_alive_operation_004() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
        var GeneralComp ptc2;
		ptc:=GeneralComp.create alive;
		ptc2:=GeneralComp.create alive;
		
		ptc.start(f1()); 
		ptc2.start(f1()); 
        ptc.kill;
		
		if (any component.alive) { 
        setverdict(pass);
        }
        else
        {
        setverdict(fail);
        }
     
    }

    control {
        execute(TC_Sem_210305_alive_operation_004());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.5, Verify that any from alive assigns index
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The index of the first component found alive can optionally be assigned to an integer 
// variable for  single-dimensional component arrays.
module Sem_210305_alive_operation_009 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210305_alive_operation_009() runs on GeneralComp system GeneralComp {
		var boolean v_isAlive;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate v_ptc
		}
        v_isAlive := any from v_ptc.alive -> @index v_index;
        if(v_index == 1){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_Sem_210305_alive_operation_009(), 5.0);
    }
}/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.2, timer reuse in alive component
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// If a function is started on an alive-type PTC after termination of a previous 
// function, it uses variable values, timers, ports, and the local verdict as they 
// were left after termination of the previous function.

module Sem_210302_Start_test_component_008 { 

	type component GeneralComp {
        timer tc_tmr := 30.0;
	}
    
    function f_ptcBehaviour() runs on GeneralComp {
        tc_tmr.start;
    }

    function f_ptcSecondBehaviour() runs on GeneralComp {
        if (tc_tmr.running) { setverdict(pass); }
        else { setverdict(fail); }
    }

    
	testcase TC_Sem_210302_Start_test_component_008() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC") alive;
        v_ptc.start(f_ptcBehaviour());
        v_ptc.done;
        v_ptc.start(f_ptcSecondBehaviour());
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_Sem_210302_Start_test_component_008());
	}
}

/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.2, component variable reference in start operation
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// The start operation shall bind the required behaviour to the test component. This 
// behaviour is defined by reference to an already defined function.

module Sem_210302_Start_test_component_002 { 

	type component GeneralComp {
	}
    
    function f_ptcBehaviour() runs on GeneralComp {
        setverdict(pass, "Executing PTC behaviour...");
    }
    
	testcase TC_Sem_210302_Start_test_component_002() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC");
        v_ptc.start(f_ptcBehaviour());
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_Sem_210302_Start_test_component_002());
	}
}
/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.2, verdict value reuse in alive component
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// If a function is started on an alive-type PTC after termination of a previous 
// function, it uses variable values, timers, ports, and the local verdict as they 
// were left after termination of the previous function.

module Sem_210302_Start_test_component_007 { 

	type component GeneralComp {
	}
    
    function f_ptcBehaviour() runs on GeneralComp {
        setverdict(pass);
    }

    function f_ptcSecondBehaviour() runs on GeneralComp {
        if (getverdict != pass) { setverdict(fail); }
    }

    
	testcase TC_Sem_210302_Start_test_component_007() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC") alive;
        v_ptc.start(f_ptcBehaviour());
        v_ptc.done;
        v_ptc.start(f_ptcSecondBehaviour());
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_Sem_210302_Start_test_component_007());
	}
}
/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.2, timer reuse in alive component
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// If a function is started on an alive-type PTC after termination of a previous 
// function, it uses variable values, timers, ports, and the local verdict as they 
// were left after termination of the previous function.

module Sem_210302_Start_test_component_005 { 

	type component GeneralComp {
        timer tc_tmr := 30.0;
	}
    
    function f_ptcBehaviour() runs on GeneralComp {
        tc_tmr.start;
    }

    function f_ptcSecondBehaviour() runs on GeneralComp {
        if (tc_tmr.running) { setverdict(pass); }
        else { setverdict(fail); }
    }

    
	testcase TC_Sem_210302_Start_test_component_005() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC") alive;
        v_ptc.start(f_ptcBehaviour());
        v_ptc.done;
        v_ptc.start(f_ptcSecondBehaviour());
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_Sem_210302_Start_test_component_005());
	}
}
/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.2, deactivation of defaults in alive components
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// In contrast to that, all active defaults are deactivated when the behaviour of 
// an alive-type PTC is stopped. This means no default is activated when a new 
// behaviour is started on an alive-type PTC.

module Sem_210302_Start_test_component_009 { 

    type port P message {
        inout integer;
    }
    
	type component GeneralComp {
        timer tc_tmr := 1.0;
        port P p;
	}
    
    altstep a_receive() runs on GeneralComp {
        [] p.receive(integer:?) { setverdict(fail); }
    }
    
    function f_ptcBehaviour() runs on GeneralComp {
        activate(a_receive());
    }

    function f_ptcSecondBehaviour() runs on GeneralComp {
        tc_tmr.start;
        alt {
            [] tc_tmr.timeout { setverdict(pass); }
        }
    }

    
	testcase TC_Sem_210302_Start_test_component_009() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC") alive;
        connect(self:p, v_ptc:p);
        v_ptc.start(f_ptcBehaviour());
        v_ptc.done;
        p.send(2);
        v_ptc.start(f_ptcSecondBehaviour());
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_Sem_210302_Start_test_component_009());
	}
}/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.2, port reuse in alive component
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// If a function is started on an alive-type PTC after termination of a previous 
// function, it uses variable values, timers, ports, and the local verdict as they 
// were left after termination of the previous function.

module Sem_210302_Start_test_component_006 { 

    type port P message {
        inout integer;
    }
    
	type component GeneralComp {
        port P p;
	}
    
    function f_ptcBehaviour() runs on GeneralComp {
        connect(self:p, self:p); // loopback
        p.send(1);
    }

    function f_ptcSecondBehaviour() runs on GeneralComp {
        p.receive(integer:?);
    }

    
	testcase TC_Sem_210302_Start_test_component_006() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC") alive;        
        v_ptc.start(f_ptcBehaviour());        
        v_ptc.done;
        v_ptc.start(f_ptcSecondBehaviour());
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_Sem_210302_Start_test_component_006());
	}
}
/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.2, test component as a result of function invocation in start operation
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// The start operation shall bind the required behaviour to the test component. This 
// behaviour is defined by reference to an already defined function.

module Sem_210302_Start_test_component_003 { 

	type component GeneralComp {
	}
    
    function f_ptcBehaviour() runs on GeneralComp {
        setverdict(pass, "Executing PTC behaviour...");
    }
    
    function f_create() return GeneralComp {
        return GeneralComp.create("PTC");
    }
    
	testcase TC_Sem_210302_Start_test_component_003() runs on GeneralComp system GeneralComp {
        f_create().start(f_ptcBehaviour());
        all component.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_Sem_210302_Start_test_component_003());
	}
}
/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.2, component variable value reuse in alive component
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// If a function is started on an alive-type PTC after termination of a previous 
// function, it uses variable values, timers, ports, and the local verdict as they 
// were left after termination of the previous function.

module Sem_210302_Start_test_component_004 { 

	type component GeneralComp {
        var integer vc_val := 0;
	}
    
    function f_ptcBehaviour() runs on GeneralComp {
        vc_val := 1;
    }

    function f_ptcSecondBehaviour() runs on GeneralComp {
        if (vc_val == 1) { setverdict(pass); }
        else { setverdict(fail); }
    }

    
	testcase TC_Sem_210302_Start_test_component_004() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create("PTC") alive;
        v_ptc.start(f_ptcBehaviour());
        v_ptc.done;
        v_ptc.start(f_ptcSecondBehaviour());
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_Sem_210302_Start_test_component_004());
	}
}
/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:21.3.2, Ensure that alive test components are allowed to start another function
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// Alive test component starts another function
module Sem_210302_Start_test_component_001 {

    type component GeneralComp { }
	function f() runs on GeneralComp {}
	function f2() runs on GeneralComp {}
	
    testcase TC_Sem_210302_Start_test_component_001() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
		ptc:=GeneralComp.create alive;
		
		ptc.start(f()); 
		ptc.done; 
		ptc.start(f2()); // allowed since ptc is alive
	
        setverdict(pass);
    }

    control {
        execute(TC_Sem_210302_Start_test_component_001());
    }
}/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:21.3.2, starting function with compatible "runs on" clause
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// The function invoked in a start test component operation shall have a runs on 
// definition referencing a component type that is compatible with the newly 
// created component (see clause 6.3.3).

module Sem_210302_Start_test_component_010 { 

	type component GeneralComp {
	}

  	type component GeneralCompEx extends GeneralComp {
          var integer vc_int := 0;
	}

    
    function f_ptcBehaviour() runs on GeneralComp {
        setverdict(pass, "Executing PTC behaviour...");
    }
    
	testcase TC_Sem_210302_Start_test_component_010() runs on GeneralComp system GeneralComp {
        var GeneralCompEx v_ptc := GeneralCompEx.create("PTC") alive;
        v_ptc.start(f_ptcBehaviour());
        v_ptc.done;
		setverdict(pass);
	}
	
	control{
	    execute(TC_Sem_210302_Start_test_component_010());
	}
}
/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that any from running assigns index
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The index of the matched component can optionally be assigned to an integer variable 
// for single-dimensional component arrays...
module Sem_210306_running_operation_007 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210306_running_operation_007() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate v_ptc
		}
        v_isRunning := any from v_ptc.running -> @index v_index;
        if(v_index == 1){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_Sem_210306_running_operation_007(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that any from running can be used inside expressions
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The index of the matched component can optionally be assigned to an integer variable 
// for single-dimensional component arrays...
module Sem_210306_running_operation_008 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210306_running_operation_008() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate PTC
		}
        v_isRunning := any from v_ptc.running -> @index v_index and v_index == 1;
        if(v_isRunning){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from running operation didn't find running components");
        }
    }

    control {
        execute(TC_Sem_210306_running_operation_008(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that any from running index redirection works for multidimensional arrays
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction e:
// If the index redirection is used for multi-dimensional component arrays, the size 
// of the integer array or record of integer type shall exactly be the same as the dimension 
// of the respective array, and its type shall allow storing the highest index (from all 
// dimensions) of the array.
module Sem_210306_running_operation_009 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210306_running_operation_009() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 3;
        var GeneralComp v_ptc[c_size][c_size];
		var integer v_index[2];
		for (var integer i := 0; i < c_size; i := i + 1) {
			for (var integer j := 0; j < c_size; j := j + 1) {				
				v_ptc[i][j] := GeneralComp.create; // created components are inactive
				if (i mod 2 == 0 or j mod 2 == 1) { v_ptc[i][j].kill; } // kill components on even i or odd j
				else { v_ptc[i][j].start(f());} // activate v_ptc
			}
		}
        v_isRunning := any from v_ptc.running -> @index v_index;
        if(v_index[0] == 1 and v_index[1] == 0){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_Sem_210306_running_operation_009(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify any from running index redirection to fuzzy variable
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction f
// If a variable referenced in the @index clause is a lazy or fuzzy variable, the expression 
// assigned to this variable is equal to the result produced by the running operation. Later 
// evaluation of the lazy or fuzzy variable does not lead to repeated invocation of the 
// running operation.
module Sem_210306_running_operation_011 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210306_running_operation_011() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var @fuzzy integer v_index;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate v_ptc
		}
        v_isRunning := any from v_ptc.running -> @index v_index;
		v_ptc[1].kill; // component at position 1 is killed after the redirect assignment
        if(v_index == 1) { // no running call during evaluation, v_index remains equal to 1
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_Sem_210306_running_operation_011(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify any from running index redirection to lazy variable
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// Restriction f
// If a variable referenced in the @index clause is a lazy or fuzzy variable, the expression 
// assigned to this variable is equal to the result produced by the running operation. Later 
// evaluation of the lazy or fuzzy variable does not lead to repeated invocation of the
// running operation.
module Sem_210306_running_operation_010 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210306_running_operation_010() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var @lazy integer v_index;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate v_ptc
		}
        v_isRunning := any from v_ptc.running -> @index v_index;
		v_ptc[1].kill; // component at position 1 is killed after the redirect assignment
        if(v_index == 1) { // no running call during evaluation, v_index remains equal to 1
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_Sem_210306_running_operation_010(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that any from running doesn't assign index when no component is running
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The index of the matched component can optionally be assigned to an integer variable 
// for single-dimensional component arrays...
module Sem_210306_running_operation_005 {

    type component GeneralComp {}

    testcase TC_Sem_210306_running_operation_005() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create;
			v_ptc[i].kill;
		}
        v_isRunning := any from v_ptc.running -> @index v_index;
        if(not isbound(v_index)){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_Sem_210306_running_operation_005(), 5000.0);
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Check that running operator provides information about test components.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_210306_running_operation_001 {

    type component GeneralComp {}

    function f1 ( ) runs on GeneralComp {
        while (true) {} // block forever
    }
	
    testcase TC_Sem_210306_running_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
        var GeneralComp ptc2;
        ptc:=GeneralComp.create alive;
        ptc2:=GeneralComp.create alive;
		
        ptc.start(f1());
        ptc2.start(f1());
        ptc.stop;

		// Check that ptc is not running, and ptc2 component is running
        if (match(ptc.running, false) and match(ptc2.running, true)) {
            setverdict(pass);
        } else {
            setverdict(fail, "either stopped ptc is running or not stopped ptc2 is not running");
        }
    }

    control {
        execute(TC_Sem_210306_running_operation_001(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that any from running doesn't change index variable when no component is running
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// The index of the matched component can optionally be assigned to an integer variable 
// for single-dimensional component arrays...
module Sem_210306_running_operation_006 {

    type component GeneralComp {}

    testcase TC_Sem_210306_running_operation_006() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		var integer v_index := 99;
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create;
			v_ptc[i].kill;
		}
        v_isRunning := any from v_ptc.running -> @index v_index;
        if(v_index == 99){
            setverdict(pass);
        } else {
            setverdict(fail, "Index incorrectly assigned");
        }
    }

    control {
        execute(TC_Sem_210306_running_operation_006(), 5000.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that any from running returns false if no component is running
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// When the any from component array notation is used, the components from the referenced array 
// are iterated over and individually checked for executing currently from innermost to outermost 
// dimension from lowest to highest index for each dimension. The first component to be found 
// executing causes the running operation to succeed.
module Sem_210306_running_operation_003 {

    type component GeneralComp {}

    testcase TC_Sem_210306_running_operation_003() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create;
			v_ptc[i].kill;
		}
        v_isRunning := any from v_ptc.running;
        if(not v_isRunning){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from running operation incorrectly detected an running component");
        }
    }

    control {
        execute(TC_Sem_210306_running_operation_003(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that any from running returns true if at least one component is running
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// When the any from component array notation is used, the components from the referenced array 
// are iterated over and individually checked for executing currently from innermost to outermost 
// dimension from lowest to highest index for each dimension. The first component to be found 
// executing causes the running operation to succeed.
module Sem_210306_running_operation_004 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210306_running_operation_004() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 0) { v_ptc[i].kill; } // kill components on even indices			
			else { v_ptc[i].start(f());} // activate v_ptc
		}
        v_isRunning := any from v_ptc.running;
        if(v_isRunning){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from running operation didn't find running components");
        }
    }

    control {
        execute(TC_Sem_210306_running_operation_004(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Verify that all component.running produces true if some components haven't been started
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
// The following requirements are tested:
// When the all keyword is used with the running operation, it will return true if all PTCs started 
// but not stopped explicitly by another component are executing their behaviour. Otherwise it 
// returns false.
// Interpretation according to the following note:
// The difference between the running operation applied to a single ptc and the usage of the all 
// keyword leads to the situation that ptc.running is false if the ptc has never been started but 
// all component.running is true at the same time as it considers only those components that ever 
// have been started.
module Sem_210306_running_operation_012 {

    type component GeneralComp {}

	function f() runs on GeneralComp {
		timer t := 100.0;
		t.start;
		t.timeout;
	}
	
    testcase TC_Sem_210306_running_operation_012() runs on GeneralComp system GeneralComp {
		var boolean v_isRunning;
		const integer c_size := 4;
        var GeneralComp v_ptc[c_size];
		for (var integer i := 0; i < c_size; i := i + 1) {
			v_ptc[i] := GeneralComp.create; // created components are inactive
			if (i mod 2 == 1) { v_ptc[i].start(f());} // start only components with odd index
		}
        v_isRunning := all component.running; // only once started components shall be considered
        if(v_isRunning){
            setverdict(pass);
        } else {
            setverdict(fail, "The any from running operation didn't find running components");
        }
    }

    control {
        execute(TC_Sem_210306_running_operation_012(), 5.0);
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:21.3.6, Any component with running can check the status of the test components
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_210306_running_operation_002 {

    type component GeneralComp {}
    
    function f1 ( ) runs on GeneralComp {
        while (true) {} // block forever
    }
	
    testcase TC_Sem_210306_running_operation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp ptc;
        var GeneralComp ptc2;
        ptc:=GeneralComp.create;
        ptc2:=GeneralComp.create;
		
        ptc.start(f1());
        ptc2.start(f1());
		
        ptc.kill;

		// Any component running test that from two test components at least one is running or not
        if (any component.running == true) { //ptc2 running
            setverdict(pass);
        } else {
            setverdict(fail, "ptc2 should still be running");
        }
    }

    control {
        execute(TC_Sem_210306_running_operation_002(), 5.0);
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.1.2, Ensure that disconnect operation with no argument works correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// The usage of a disconnect ... operation without any parameters is a shorthand 
// form for using the operation with the parameter self:all port. It disconnects 
// ... all ports of the component that calls the operation.

module Sem_210102_disconnect_and_unmap_operations_004{
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p1, p2;
    }
    
	function checkSecondConnected() runs on GeneralComp
	{
		if(not p1.checkstate("Connected") and p2.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	
    testcase TC_Sem_210102_disconnect_and_unmap_operations_004() runs on GeneralComp system GeneralComp {
        // components are created alive so that their connections are not destroyed when behaviour stops
		var GeneralComp v_ptc1 := GeneralComp.create alive, 
			v_ptc2 := GeneralComp.create alive;

		connect(self:p1, v_ptc1:p1);
		connect(self:p2, v_ptc2:p1);		
		connect(v_ptc1:p2, v_ptc2:p2);

		disconnect;

		// verity that ports are really disconnected
        v_ptc1.start(checkSecondConnected());
        v_ptc2.start(checkSecondConnected());
		if(not p1.checkstate("Connected") and not p2.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
		all component.done;
    }
    control{
        execute(TC_Sem_210102_disconnect_and_unmap_operations_004());
    }
}

/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.1.2, Verify that no error is generated when unmapping ports that are not mapped
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// An ... unmap operation has only an effect if the ... mapping to be removed 
// has been created beforehand.

module Sem_210102_disconnect_and_unmap_operations_010 {
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p;
    }

    testcase TC_Sem_210102_disconnect_and_unmap_operations_010() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc1 := GeneralComp.create;

		connect(self:p, v_ptc1:p);
		unmap( v_ptc1:p, system:p); //no effect, ports not mapped
		setverdict(pass);
    }
    control{
        execute(TC_Sem_210102_disconnect_and_unmap_operations_010());
    }
}

/***************************************************
 ** @author   STF 451, STF 470
 ** @version  0.0.2
 ** @purpose  1:21.1.2, Ensure that all component notation work correctly in disconnect operation
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// The all component keyword shall only be used in combination with the all port 
// keyword, i.e. all component:all port, and shall only be used by the MTC. Furthermore, 
// the all component:all port argument shall be used as the one and only argument of a 
// disconnect or unmap operation and it allows to release all connections and mappings 
// of the test configuration.

module Sem_210102_disconnect_operation_001{
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p;
    }
    
	function f() runs on GeneralComp
	{
		timer t := 1.0;
		t.start;
		if(not p.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
		t.timeout; // keep alive for 1 second
	}
	
    testcase TC_Sem_210102_disconnect_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc1 := GeneralComp.create, 
			v_ptc2 := GeneralComp.create,
			v_ptc3 := GeneralComp.create;

		connect(v_ptc1:p, v_ptc2:p);
		connect(v_ptc1:p, v_ptc3:p);
		connect(v_ptc2:p, v_ptc3:p);

		disconnect(all component:all port);

		// verity that ports are really disconnected
        v_ptc1.start(f());
        v_ptc2.start(f());
		v_ptc3.start(f());
		all component.done;
    }
    control{
        execute(TC_Sem_210102_disconnect_operation_001());
    }
}

/***************************************************
 ** @author   STF 451, STF 470
 ** @version  0.0.2
 ** @purpose  1:21.1.1, Ensure that disconnect has no effect on components that are not connected
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_210102_disconnect_operation_002{
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p;
    }
    
	function f() runs on GeneralComp
	{
		if(p.checkstate("Mapped")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	
    testcase TC_Sem_210102_disconnect_operation_002() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc1 := GeneralComp.create, 
			v_ptc2 := GeneralComp.create;

		map(v_ptc1:p, system:p);

		disconnect(v_ptc1:p, v_ptc2:p); // acceptable even when not connected
		
        v_ptc1.start(f());
		all component.done;
    }
    control{
        execute(TC_Sem_210102_disconnect_operation_002());
    }
}

/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:21.1.2, Verify that the param part can be skipped in unmap operations
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// Restriction b:
// In unmap operations, param clauses are optional.

module Sem_210102_disconnect_and_unmap_operations_012 { 

	type port P message {
		inout integer;
		unmap param (integer p_par1);
	}

	type component GeneralComp {
		port P p
	}

	testcase TC_Sem_210102_disconnect_and_unmap_operations_012() runs on GeneralComp system GeneralComp {
		map(system:p, self:p);
		unmap(self:p, system:p);
		if(not p.checkstate("Mapped")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}

	}
	
	control{
	    execute(TC_Sem_210102_disconnect_and_unmap_operations_012());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.1.2, Ensure that all component notation works correctly in unmap operations
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// The all component keyword shall only be used in combination with the all port 
// keyword, i.e. all component:all port, and shall only be used by the MTC. Furthermore, 
// the all component:all port argument shall be used as the one and only argument of a 
// disconnect or unmap operation and it allows to release all connections and mappings 
// of the test configuration.

module Sem_210102_disconnect_and_unmap_operations_009 {
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p1, p2;
    }

	function checkUnmapped() runs on GeneralComp
	{
		if(not p1.checkstate("Mapped") and not p2.checkstate("Mapped")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	
    testcase TC_Sem_210102_disconnect_and_unmap_operations_009() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc1 := GeneralComp.create;

		map(self:p1, system:p1);
		map(self:p2, system:p2);
		map(v_ptc1:p1, system:p1);
		map(v_ptc1:p2, system:p2);

		unmap(all component:all port);

		// verity that ports are really unmapped
        checkUnmapped();
        v_ptc1.start(checkUnmapped());
		all component.done;
    }
    control{
        execute(TC_Sem_210102_disconnect_and_unmap_operations_009());
    }
}

/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.1.2, Ensure that unmap operation with one system port as a parameter works correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// To ease ... map operations related to all ... mappings of ... a port, it is
// allowed to use ... unmap operations with one argument only. This one argument 
// specifies one side of the connections to be ... unmapped.

module Sem_210102_disconnect_and_unmap_operations_005 {
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p;
    }
    
	function checkUnmapped() runs on GeneralComp
	{
		if(not p.checkstate("Mapped")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	
    testcase TC_Sem_210102_disconnect_and_unmap_operations_005() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc1 := GeneralComp.create;

		map(self:p, system:p);
		map(v_ptc1:p, system:p);		

		unmap(system:p);

		// verity that ports are really unmapped
        checkUnmapped();
        v_ptc1.start(checkUnmapped());
		all component.done;
    }
    control{
        execute(TC_Sem_210102_disconnect_and_unmap_operations_005());
    }
}

/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.1.2, Ensure that disconnect operation with one parameter works correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// To ease disconnect ... operations related to all connections ... of ... a port, it is
// allowed to use disconnect ... operations with one argument only. This one argument 
// specifies one side of the connections to be disconnected...

module Sem_210102_disconnect_and_unmap_operations_002{
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p;
    }
    
	function checkDisconnected() runs on GeneralComp
	{
		if(not p.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	
    testcase TC_Sem_210102_disconnect_and_unmap_operations_002() runs on GeneralComp system GeneralComp {
        // components are created alive so that their connections are not destroyed when behaviour stops
		var GeneralComp v_ptc1 := GeneralComp.create alive, 
			v_ptc2 := GeneralComp.create alive,
			v_ptc3 := GeneralComp.create alive;

		connect(v_ptc1:p, v_ptc2:p);
		connect(v_ptc1:p, v_ptc3:p);		

		disconnect(v_ptc1:p);

		// verity that ports are really disconnected
        v_ptc2.start(checkDisconnected());
        v_ptc3.start(checkDisconnected());
		all component.done;
    }
    control{
        execute(TC_Sem_210102_disconnect_and_unmap_operations_002());
    }
}

/***************************************************
 ** @author   STF 451, STF 470
 ** @version  0.0.2
 ** @purpose  1:21.1.2, Ensure that umnap operation of a component and system port works correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// The ... unmap operations perform ... the unmapping of (previously mapped) ports of 
// test components and ports in the test system interface.

module Sem_210102_unmap_operation_002 {
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p;
    }
    
	function checkMapped(boolean p_stateActive) runs on GeneralComp
	{
		if(p.checkstate("Mapped") xor not p_stateActive) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	
    testcase TC_Sem_210102_unmap_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc1 := GeneralComp.create;

		map(self:p, system:p);
		map(v_ptc1:p, system:p);

		unmap(v_ptc1:p, system:p);

		// verity that ports are really unmapped
        checkMapped(true); // still mapped to system:p
        v_ptc1.start(checkMapped(false)); // no active mapping
		v_ptc1.done;		
    }
	
    control{
        execute(TC_Sem_210102_unmap_operation_001());
    }
}

/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.1.2, Ensure that disconnect operation with all ports of a component works correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// To ease disconnect ... operations related to all connections ... of a component ..., 
// it is allowed to use disconnect ... operations with one argument only. This one argument
// specifies one side of the connections to be disconnected... The all port keyword can be 
// used to denote all ports of a component.

module Sem_210102_disconnect_and_unmap_operations_003{
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p1, p2;
    }
    
	function checkAllDisconnected() runs on GeneralComp
	{
		timer t := 1.0;
		t.start;
		if(not p1.checkstate("Connected") and not p2.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
		t.timeout; // keep alive for 1 second
	}
	
	function checkSecondConnected() runs on GeneralComp
	{
		if(not p1.checkstate("Connected") and p2.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	
    testcase TC_Sem_210102_disconnect_and_unmap_operations_003() runs on GeneralComp system GeneralComp {
        // components are created alive so that their connections are not destroyed when behaviour stops
		var GeneralComp v_ptc1 := GeneralComp.create alive, 
			v_ptc2 := GeneralComp.create alive,
			v_ptc3 := GeneralComp.create alive;

		connect(v_ptc1:p1, v_ptc2:p1);
		connect(v_ptc1:p2, v_ptc3:p1);		
		connect(v_ptc2:p2, v_ptc3:p2);

		disconnect(v_ptc1:all port);

		// verity that ports are really disconnected
		v_ptc1.start(checkAllDisconnected());
        v_ptc2.start(checkSecondConnected());
        v_ptc3.start(checkSecondConnected());
		all component.done;
    }
    control{
        execute(TC_Sem_210102_disconnect_and_unmap_operations_003());
    }
}

/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:21.1.2, Verify that the param clause can be used when unmap contains a single system port parameter
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// Restriction a:
// In an unmap operation, a param clause shall only be present if the system port to 
// which the param clause belongs to is explicitly referenced.

module Sem_210102_disconnect_and_unmap_operations_013 { 

	type port P message {
		inout integer;
		unmap param (integer p_par1);
	}

	type component GeneralComp {
		port P p
	}

	testcase TC_Sem_210102_disconnect_and_unmap_operations_013() runs on GeneralComp system GeneralComp {
		map(system:p, self:p);
		unmap(system:p) param(1);
		if(not p.checkstate("Mapped")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}

	}
	
	control{
	    execute(TC_Sem_210102_disconnect_and_unmap_operations_013());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.1.2, Ensure that unmap operation with no parameters works correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// The usage of an ... unmap operation without any parameters is a shorthand 
// form for using the operation with the parameter self:all port. It ...
// unmaps all ports of the component that calls the operation.

module Sem_210102_disconnect_and_unmap_operations_008 {
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p1, p2;
    }
    
	function checkPortMapped(boolean p_stateActive, P p_port)
	{
		if(p_port.checkstate("Mapped") xor not p_stateActive) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	function checkMapped(boolean p_stateActive) runs on GeneralComp
	{
		checkPortMapped(p_stateActive, p1);
		checkPortMapped(p_stateActive, p2);
	}
	
    testcase TC_Sem_210102_disconnect_and_unmap_operations_008() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc1 := GeneralComp.create;

		map(self:p1, system:p1);
		map(self:p2, system:p2);
		map(v_ptc1:p1, system:p1);
		map(v_ptc1:p2, system:p2);

		unmap;

		// verity that ports are really unmapped
        checkMapped(false); // no active mapping
        v_ptc1.start(checkMapped(true)); // still mapped to system:p1 and system:p2
		all component.done;
    }
    control{
        execute(TC_Sem_210102_disconnect_and_unmap_operations_008());
    }
}

/*****************************************************************
 ** @author   STF 433, STF 470
 ** @version  0.0.2
 ** @purpose  1:21.1.2, Ensure that unmap param statements are allowed in testcase block
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_210102_disconnect_and_unmap_operations_011 {

    type component GeneralComp {
        port MyMessagePortType pt_myPort;
    }

    type record MyMessageType1 {
        boolean h1,
        MyMessageType1 h2 optional
    }

    type record MyMessageType2 {
        integer g1,
        charstring g2
    }

    type port MyMessagePortType message {
        inout all;
        unmap param (in MyMessageType1 p1, inout MyMessageType2 p2);
    }

    const MyMessageType1 c_myTemplate1 := {
        h1 := false,
        h2 := {
            h1:= true,
            h2 := omit
        }
    }

    const MyMessageType2 c_myTemplate2 := {
        g1 := 2,
        g2 := "foo"
    }

    testcase TC_Sem_210102_disconnect_and_unmap_operations_011() runs on GeneralComp system GeneralComp {
        var MyMessageType2 v_myTemplate2 := c_myTemplate2;

        map(mtc:pt_myPort, system:pt_myPort);
        
        pt_myPort.send(13);
        
        unmap(mtc:pt_myPort, system:pt_myPort) param(c_myTemplate1, v_myTemplate2);
        log("Unmap inout parameter", v_myTemplate2);

        setverdict(pass);
    }

    control{
        execute(TC_Sem_210102_disconnect_and_unmap_operations_011());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.1.2, Ensure that unmap operation with one component port as a parameter works correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// To ease ... map operations related to all ... mappings of ... a port, it is
// allowed to use ... unmap operations with one argument only. This one argument 
// specifies one side of the connections to be ... unmapped.

module Sem_210102_disconnect_and_unmap_operations_006 {
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p;
    }
    
	function checkMapped(boolean p_stateActive) runs on GeneralComp
	{
		if(p.checkstate("Mapped") xor not p_stateActive) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	
    testcase TC_Sem_210102_disconnect_and_unmap_operations_006() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc1 := GeneralComp.create;

		map(self:p, system:p);
		map(v_ptc1:p, system:p);		

		unmap(v_ptc1:p);

		// verity that ports are really unmapped
        checkMapped(true); // still mapped to system:p
        v_ptc1.start(checkMapped(false)); // no active mapping
		all component.done;
    }
    control{
        execute(TC_Sem_210102_disconnect_and_unmap_operations_006());
    }
}

/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.1.2, Ensure that unmap operation with all ports of a component works correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// To ease ... map operations related to all ... mappings of a component ..., it is
// allowed to use ... unmap operations with one argument only. This one argument 
// specifies one side of the connections to be ... unmapped. The all port keyword 
// can be used to denote all ports of a component.

module Sem_210102_disconnect_and_unmap_operations_007 {
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p1, p2;
    }
    
	function checkPortMapped(boolean p_stateActive, P p_port)
	{
		if(p_port.checkstate("Mapped") xor not p_stateActive) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	function checkMapped(boolean p_stateActive) runs on GeneralComp
	{
		checkPortMapped(p_stateActive, p1);
		checkPortMapped(p_stateActive, p2);
	}
	
    testcase TC_Sem_210102_disconnect_and_unmap_operations_007() runs on GeneralComp system GeneralComp {
		var GeneralComp v_ptc1 := GeneralComp.create;

		map(self:p1, system:p1);
		map(self:p2, system:p2);
		map(v_ptc1:p1, system:p1);
		map(v_ptc1:p2, system:p2);

		unmap(v_ptc1:all port);

		// verity that ports are really unmapped
        checkMapped(true); // still mapped to system:p1 and system:p2
        v_ptc1.start(checkMapped(false)); // no active mapping
		all component.done;
    }
    control{
        execute(TC_Sem_210102_disconnect_and_unmap_operations_007());
    }
}

/***************************************************
 ** @author   STF 451, STF 470
 ** @version  0.0.2
 ** @purpose  1:21.1.2, Ensure that umnap operation of a system and component port works correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// The ... unmap operations perform ... the unmapping of (previously mapped) ports of 
// test components and ports in the test system interface.

module Sem_210102_unmap_operation_001 {
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p;
    }
    
	function checkMapped(boolean p_stateActive) runs on GeneralComp
	{
		if(p.checkstate("Mapped") xor not p_stateActive) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	
    testcase TC_Sem_210102_unmap_operation_001() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc1 := GeneralComp.create;

		map(self:p, system:p);
		map(v_ptc1:p, system:p);

		unmap(system:p, v_ptc1:p);

		// verity that ports are really unmapped
        checkMapped(true); // still mapped to system:p
        v_ptc1.start(checkMapped(false)); // no active mapping
		v_ptc1.done;		
    }
	
    control{
        execute(TC_Sem_210102_unmap_operation_001());
    }
}

/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:21.1.2, Ensure that disconnect operation with two parameters works correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// The disconnect ... operations perform the disconnection (of previously connected) 
// ports of test components...

module Sem_210102_disconnect_and_unmap_operations_001{
  
    type port P message {
        inout integer
    }

    type component GeneralComp
    {
        port P p;
    }
    
	function checkConnected(boolean p_stateActive) runs on GeneralComp
	{
		if(p.checkstate("Connected") xor not p_stateActive) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	
    testcase TC_Sem_210102_disconnect_and_unmap_operations_001() runs on GeneralComp system GeneralComp {
        // components are created alive so that their connections are not destroyed when behaviour stops
		var GeneralComp v_ptc1 := GeneralComp.create alive, 
			v_ptc2 := GeneralComp.create alive,
			v_ptc3 := GeneralComp.create alive;

		connect(v_ptc1:p, v_ptc2:p);
		connect(v_ptc1:p, v_ptc3:p);

		disconnect(v_ptc1:p, v_ptc2:p);

		// verity that ports are really disconnected
        v_ptc1.start(checkConnected(true)); // still connectected to v_ptc3:p
        v_ptc2.start(checkConnected(false)); // no active connection
		all component.done;
    }
    control{
        execute(TC_Sem_210102_disconnect_and_unmap_operations_001());
    }
}

/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Verify that the param part can be skipped in map operations
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// Restriction g:
// In map operations, param clauses are optional.

module Sem_210101_connect_and_map_operations_010 { 

	type port P message {
		inout integer;
		map param (integer p_par1);
	}

	type component GeneralComp {
		port P p
	}

	testcase TC_Sem_210101_connect_and_map_operations_010() runs on GeneralComp system GeneralComp {
		map(system:p, self:p);
		if(p.checkstate("Mapped")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}

	}
	
	control{
	    execute(TC_Sem_210101_connect_and_map_operations_010());
	}
}
/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Map operation accepts ports with compatible message type list containing several types
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// For the connect operations, only consistent connections are allowed.
// a) Assuming the following:
//   1) ports PORT1 and PORT2 are the ports to be connected;
//   2) inlist-PORT1 defines the messages or procedures of the in-direction of PORT1;
//   3) outlist-PORT1defines the messages or procedures of the out-direction of PORT1;
//   4) inlist-PORT2 defines the messages or procedures of the in-direction of PORT2; and
//   5) outlist-PORT2 defines the messages or procedures of the out-direction of PORT2.
// c) The map operation (assuming PORT2 is the test system interface port) is allowed if 
// and only if:
// outlist-PORT1  outlist-PORT2 and inlist-PORT2  inlist-PORT1.
//
// In this test, outlist-PORT1 == outlist-PORT2 and inlist-PORT2 == inlist-PORT1

module Sem_210101_connect_and_map_operations_005 { 
	type record R {
		integer field1,
		charstring field2
	}
	
	type port P1 message {
		inout integer;
		out R, charstring;
	}
	
	type port P2 message {
	  out charstring, R, integer;
	  in integer;
	}
		
	type component GeneralComp {
		port P1 p
	}

	type component SystemComp {
		port P2 p;
	}

	testcase TC_Sem_210101_connect_and_map_operations_005() runs on GeneralComp system SystemComp {
		map(self:p, system:p); // compatible, 1:1 mapping
		if(p.checkstate("Mapped")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	
	control{
	    execute(TC_Sem_210101_connect_and_map_operations_005());
	}
}
/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Connect operation accepts ports where outlist of both ports are subsets of inlist of the counterpart ports
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// For the connect operations, only consistent connections are allowed.
// a) Assuming the following:
//   1) ports PORT1 and PORT2 are the ports to be connected;
//   2) inlist-PORT1 defines the messages or procedures of the in-direction of PORT1;
//   3) outlist-PORT1defines the messages or procedures of the out-direction of PORT1;
//   4) inlist-PORT2 defines the messages or procedures of the in-direction of PORT2; and
//   5) outlist-PORT2 defines the messages or procedures of the out-direction of PORT2.
// b) The connect operation is allowed if and only if:
// outlist-PORT1  inlist-PORT2 and outlist-PORT2  inlist-PORT1.
//
// In this test, outlist-PORT1 inlist-PORT2 and outlist-PORT2  inlist-PORT1

module Sem_210101_connect_and_map_operations_004 { 
	type record R {
		integer field1,
		charstring field2
	}
	
	type port P1 message {
		inout integer, R;
		in bitstring;
	}
	
	type port P2 message {
	  in charstring, boolean, R, integer;
	  out integer;
	}
		
	type component GeneralComp {
	}

	type component C1 {
		port P1 p;
	}

	type component C2 {
		port P2 p;
	}

		function f1() runs on C1
	{
		timer t := 1.0;
		t.start;
		if(p.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
		t.timeout; // keep alive for 1 second
	}

	function f2() runs on C2
	{
		timer t := 1.0;
		t.start;
		if(p.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
		t.timeout; // keep alive for 1 second
	}

	testcase TC_Sem_210101_connect_and_map_operations_004() runs on GeneralComp system GeneralComp {
		var C1 v_ptc1 := C1.create;
		var C2 v_ptc2 := C2.create;
		// v_ptc1:p outlist is (integer, R) and v_ptc2:p inlist is (charstring, boolean, R, integer)
		// v_ptc2:p outlist is (integer) and v_ptc2:p inlist is (R, integer, bitstring)
		connect(v_ptc1:p, v_ptc2:p); 
		v_ptc1.start(f1());
		v_ptc2.start(f2());
		all component.done;
	}
	
	control{
	    execute(TC_Sem_210101_connect_and_map_operations_004());
	}
}
/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Connect operation accepts ports where outlist of the 2nd port is a subset of inlist of the 1st port
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// For the connect operations, only consistent connections are allowed.
// a) Assuming the following:
//   1) ports PORT1 and PORT2 are the ports to be connected;
//   2) inlist-PORT1 defines the messages or procedures of the in-direction of PORT1;
//   3) outlist-PORT1defines the messages or procedures of the out-direction of PORT1;
//   4) inlist-PORT2 defines the messages or procedures of the in-direction of PORT2; and
//   5) outlist-PORT2 defines the messages or procedures of the out-direction of PORT2.
// b) The connect operation is allowed if and only if:
// outlist-PORT1  inlist-PORT2 and outlist-PORT2  inlist-PORT1.
//
// In this test, outlist-PORT1 == inlist-PORT2 and outlist-PORT2  inlist-PORT1

module Sem_210101_connect_and_map_operations_003 { 
	type record R {
		integer field1,
		charstring field2
	}
	
	type port P1 message {
		inout integer;
		out R;
	}
	
	type port P2 message {
	  in charstring, boolean, R, integer;
	  out integer;
	}
		
	type component GeneralComp {
	}

	type component C1 {
		port P1 p;
	}

	type component C2 {
		port P2 p;
	}
	
		function f1() runs on C1
	{
		timer t := 1.0;
		t.start;
		if(p.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
		t.timeout; // keep alive for 1 second
	}

	function f2() runs on C2
	{
		timer t := 1.0;
		t.start;
		if(p.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
		t.timeout; // keep alive for 1 second
	}


	testcase TC_Sem_210101_connect_and_map_operations_003() runs on GeneralComp system GeneralComp {
		var C1 v_ptc1 := C1.create;
		var C2 v_ptc2 := C2.create;
		// v_ptc2:p inlist is (charstring, boolean, R, integer) and v_ptc1:p outlist is (integer, R)
		connect(v_ptc2:p, v_ptc1:p); 
		v_ptc1.start(f1());
		v_ptc2.start(f2());
		all component.done;
	}
	
	control{
	    execute(TC_Sem_210101_connect_and_map_operations_003());
	}
}
/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Connect operation accepts ports with compatible message type list containing several types
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// For the connect operations, only consistent connections are allowed.
// a) Assuming the following:
//   1) ports PORT1 and PORT2 are the ports to be connected;
//   2) inlist-PORT1 defines the messages or procedures of the in-direction of PORT1;
//   3) outlist-PORT1defines the messages or procedures of the out-direction of PORT1;
//   4) inlist-PORT2 defines the messages or procedures of the in-direction of PORT2; and
//   5) outlist-PORT2 defines the messages or procedures of the out-direction of PORT2.
// b) The connect operation is allowed if and only if:
// outlist-PORT1  inlist-PORT2 and outlist-PORT2  inlist-PORT1.
//
// In this test, outlist-PORT1 == inlist-PORT2 and outlist-PORT2 == inlist-PORT1

module Sem_210101_connect_and_map_operations_001 { 
	type record R {
		integer field1,
		charstring field2
	}
	
	type port P1 message {
		inout integer;
		out R, charstring;
	}
	
	type port P2 message {
	  in charstring, R, integer;
	  out integer;
	}
		
	type component GeneralComp {
	}

	type component C1 {
		port P1 p;
	}

	type component C2 {
		port P2 p;
	}

	function f1() runs on C1
	{
		timer t := 1.0;
		t.start;
		if(p.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
		t.timeout; // keep alive for 1 second
	}

	function f2() runs on C2
	{
		timer t := 1.0;
		t.start;
		if(p.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
		t.timeout; // keep alive for 1 second
	}

	testcase TC_Sem_210101_connect_and_map_operations_001() runs on GeneralComp system GeneralComp {
		var C1 v_ptc1 := C1.create;
		var C2 v_ptc2 := C2.create;
		connect(v_ptc1:p, v_ptc2:p); // compatible, 1:1 mapping
		v_ptc1.start(f1());
		v_ptc2.start(f2());
		all component.done;
	}
	
	control{
	    execute(TC_Sem_210101_connect_and_map_operations_001());
	}
}
/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Map operation accepts ports with compatible message type list containing several types
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// For the connect operations, only consistent connections are allowed.
// a) Assuming the following:
//   1) ports PORT1 and PORT2 are the ports to be connected;
//   2) inlist-PORT1 defines the messages or procedures of the in-direction of PORT1;
//   3) outlist-PORT1defines the messages or procedures of the out-direction of PORT1;
//   4) inlist-PORT2 defines the messages or procedures of the in-direction of PORT2; and
//   5) outlist-PORT2 defines the messages or procedures of the out-direction of PORT2.
// c) The map operation (assuming PORT2 is the test system interface port) is allowed if 
// and only if:
// outlist-PORT1  outlist-PORT2 and inlist-PORT2  inlist-PORT1.
//
// In this test, outlist-PORT1  outlist-PORT2 and inlist-PORT2  inlist-PORT1

module Sem_210101_connect_and_map_operations_008 { 
	type record R {
		integer field1,
		charstring field2
	}
	
	type port P1 message {
		in charstring, bitstring;
		inout integer;
		out R;
	}
	
	type port P2 message {
	  out R, integer, boolean;
	  in integer;
	}
		
	type component GeneralComp {
		port P1 p
	}

	type component SystemComp {
		port P2 p;
	}

	testcase TC_Sem_210101_connect_and_map_operations_008() runs on GeneralComp system SystemComp {
		// self:p inlist is (integer, charstring, bitstring) and system:p inlist is (integer)
		// self:p outlist is (integer, R) and system:p outlist is (integer, R, boolean)
		map(system:p, self:p);
		if(p.checkstate("Mapped")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	
	control{
	    execute(TC_Sem_210101_connect_and_map_operations_008());
	}
}
/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Connect operation accepts ports where outlist of the 1st port is a subset of inlist of the 2nd port
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// For the connect operations, only consistent connections are allowed.
// a) Assuming the following:
//   1) ports PORT1 and PORT2 are the ports to be connected;
//   2) inlist-PORT1 defines the messages or procedures of the in-direction of PORT1;
//   3) outlist-PORT1defines the messages or procedures of the out-direction of PORT1;
//   4) inlist-PORT2 defines the messages or procedures of the in-direction of PORT2; and
//   5) outlist-PORT2 defines the messages or procedures of the out-direction of PORT2.
// b) The connect operation is allowed if and only if:
// outlist-PORT1  inlist-PORT2 and outlist-PORT2  inlist-PORT1.
//
// In this test, outlist-PORT1  inlist-PORT2 and outlist-PORT2 == inlist-PORT1

module Sem_210101_connect_and_map_operations_002 { 
	type record R {
		integer field1,
		charstring field2
	}
	
	type port P1 message {
		inout integer;
		out R;
	}
	
	type port P2 message {
	  in charstring, boolean, R, integer;
	  out integer;
	}
		
	type component GeneralComp {
	}

	type component C1 {
		port P1 p;
	}

	type component C2 {
		port P2 p;
	}
	
		function f1() runs on C1
	{
		timer t := 1.0;
		t.start;
		if(p.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
		t.timeout; // keep alive for 1 second
	}

	function f2() runs on C2
	{
		timer t := 1.0;
		t.start;
		if(p.checkstate("Connected")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
		t.timeout; // keep alive for 1 second
	}


	testcase TC_Sem_210101_connect_and_map_operations_002() runs on GeneralComp system GeneralComp {
		var C1 v_ptc1 := C1.create;
		var C2 v_ptc2 := C2.create;
		// v_ptc1:p outlist is (integer, R) and v_ptc2:p inlist is (charstring, boolean, R, integer)
		connect(v_ptc1:p, v_ptc2:p); 
		v_ptc1.start(f1());
		v_ptc2.start(f2());
		all component.done;
	}
	
	control{
	    execute(TC_Sem_210101_connect_and_map_operations_002());
	}
}
/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Map operation accepts ports with compatible message type list containing several types
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// For the connect operations, only consistent connections are allowed.
// a) Assuming the following:
//   1) ports PORT1 and PORT2 are the ports to be connected;
//   2) inlist-PORT1 defines the messages or procedures of the in-direction of PORT1;
//   3) outlist-PORT1defines the messages or procedures of the out-direction of PORT1;
//   4) inlist-PORT2 defines the messages or procedures of the in-direction of PORT2; and
//   5) outlist-PORT2 defines the messages or procedures of the out-direction of PORT2.
// c) The map operation (assuming PORT2 is the test system interface port) is allowed if 
// and only if:
// outlist-PORT1  outlist-PORT2 and inlist-PORT2  inlist-PORT1.
//
// In this test, outlist-PORT1  outlist-PORT2 and inlist-PORT2 == inlist-PORT1

module Sem_210101_connect_and_map_operations_006 { 
	type record R {
		integer field1,
		charstring field2
	}
	
	type port P1 message {
		inout integer;
		out R;
	}
	
	type port P2 message {
	  out charstring, R, integer, bitstring;
	  in integer;
	}
		
	type component GeneralComp {
		port P1 p
	}

	type component SystemComp {
		port P2 p;
	}

	testcase TC_Sem_210101_connect_and_map_operations_006() runs on GeneralComp system SystemComp {
		// self:p outlist is (integer, R) and system:p outlist is (charstring, boolean, R, integer)
		map(self:p, system:p);
		if(p.checkstate("Mapped")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}
	}
	
	control{
	    execute(TC_Sem_210101_connect_and_map_operations_006());
	}
}
/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:21.1.1, Map operation accepts ports with compatible message type list containing several types
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// For the connect operations, only consistent connections are allowed.
// a) Assuming the following:
//   1) ports PORT1 and PORT2 are the ports to be connected;
//   2) inlist-PORT1 defines the messages or procedures of the in-direction of PORT1;
//   3) outlist-PORT1defines the messages or procedures of the out-direction of PORT1;
//   4) inlist-PORT2 defines the messages or procedures of the in-direction of PORT2; and
//   5) outlist-PORT2 defines the messages or procedures of the out-direction of PORT2.
// c) The map operation (assuming PORT2 is the test system interface port) is allowed if 
// and only if:
// outlist-PORT1  outlist-PORT2 and inlist-PORT2  inlist-PORT1.
//
// In this test, outlist-PORT1 == outlist-PORT2 and inlist-PORT2  inlist-PORT1

module Sem_210101_connect_and_map_operations_007 { 
	type record R {
		integer field1,
		charstring field2
	}
	
	type port P1 message {
		in charstring, bitstring;
		inout integer;
		out R;
	}
	
	type port P2 message {
	  out R, integer;
	  in integer;
	}
		
	type component GeneralComp {
		port P1 p
	}

	type component SystemComp {
		port P2 p;
	}

	testcase TC_Sem_210101_connect_and_map_operations_007() runs on GeneralComp system SystemComp {
		// self:p inlist is (integer, charstring, bitstring) and system:p inlist is (integer)
		map(system:p, self:p);
		if(p.checkstate("Mapped")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}

	}
	
	control{
	    execute(TC_Sem_210101_connect_and_map_operations_007());
	}
}
/*****************************************************************
 ** @author   STF 433, STF 470
 ** @version  0.0.2
 ** @purpose  1:21.1.1, Ensure that map param statements are allowed in testcase block
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_210101_connect_and_map_operations_009 {

    type component GeneralComp {
        port MyMessagePortType pt_myPort;
    }

    type record MyMessageType1 {
        integer field1,
        charstring field2,
        boolean field3
    }

    type port MyMessagePortType message {
        inout integer;
        map param (in MyMessageType1 p1, inout charstring p2);
    }

    const MyMessageType1 c_myTemplate1 := {
        field1 := 2,
        field2 := "foobar",
        field3 := true
    }

    testcase TC_Sem_210101_connect_and_map_operations_009() runs on GeneralComp system GeneralComp {
        var charstring v_varString := "foobar";

        map(mtc:pt_myPort, system:pt_myPort) param(c_myTemplate1, v_varString);
        
        pt_myPort.send(13);
        log("Map inout parameter: ", v_varString);
        
		if(pt_myPort.checkstate("Mapped")) {
			setverdict(pass);			
		} else {
			setverdict(fail);
		}

        unmap(mtc:pt_myPort, system:pt_myPort);

        setverdict(pass);
    }

    control{
        execute(TC_Sem_210101_connect_and_map_operations_009());
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure setverdict and getverdict are allowed in test cases
 ** @verdict  pass accept, noexecution
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/Getverdict and setverdict operations shall only be used in test cases, altsteps and functions./Setverdict locations/Setverdict allowed in test cases
 **/

module Syn_24_toplevel_002 {
	type component GeneralComp {};
	
	testcase TC_Syn_24_toplevel_002_setverdict() runs on GeneralComp {
		setverdict(none);
		setverdict(pass);
		setverdict(inconc);
		setverdict(fail);
	}

	testcase TC_Syn_24_toplevel_002_getverdict() runs on GeneralComp {
		var verdicttype v_verdict;
		
		v_verdict := getverdict;
	}

	testcase TC_Syn_24_toplevel_002_return_getverdict() runs on GeneralComp {
		const verdicttype c_v := getverdict;
	} 
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure setverdict and getverdict are allowed in functions
 ** @verdict  pass accept, noexecution
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/Getverdict and setverdict operations shall only be used in test cases, altsteps and functions./Setverdict locations/Setverdict in functions allowed
 **/

module Syn_24_toplevel_001 {
	function f_test_setverdict()  {
		setverdict(none);
		setverdict(pass);
		setverdict(inconc);
		setverdict(fail);
	}

	function f_test_variable_assignment()  {
		var verdicttype v_verdict;
		
		v_verdict := getverdict;
	}

	function f_test_return_getverdict() return verdicttype {
		return getverdict;
	}
	
	function f_test_const_init() {
		const verdicttype c_v := getverdict;
	} 
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure setverdict and getverdict are allowed in atsteps
 ** @verdict  pass accept, noexecution
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/Getverdict and setverdict operations shall only be used in test cases, altsteps and functions./Setverdict locations/Setverdict allowed in altsteps
 **/

module Syn_24_toplevel_003 {
	type record MessageType {
  		integer  		field
	}

    type port MessagePort message {
		inout MessageType;
	}

	type component GeneralComp {	    	    
		port MessagePort PCO1;
		port MessagePort PCO2;
		port MessagePort PCO3;
	}	

	altstep a_test_get_set_verdict() runs on GeneralComp { 
		var verdicttype v_verdict := getverdict;
  
		[] PCO1.receive {
			setverdict(pass);
		}
		[] PCO2.receive {
			setverdict(inconc);
		}
		[] PCO3.receive {
			setverdict(fail);
		}
	}
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure logging constraints
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/Optional setverdict parameters
 **/

module Sem_2402_setverdict_params_003 {
    type component TComp {}
    
    testcase TC_Sem_2402_setverdict_params_003() runs on TComp {
        var template verdicttype v_pass := pass;
        setverdict(valueof(v_pass));
    }
    
    control {
        execute(TC_Sem_2402_setverdict_params_003())
    } 
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure logging constraints
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/For FreeText and TemplateInstance, the same rules and restrictions apply as for the parameters of the log statement.
 **/

module Sem_2402_setverdict_logging_001 {
    type component TComp {}
    
    testcase TC_Sem_2402_setverdict_logging_001() runs on TComp {
        var integer v_uninitialized ;
        setverdict(pass, "Uninitialized variable", v_uninitialized);
    }
    
    control {
        execute(TC_Sem_2402_setverdict_logging_001())
    } 
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure setverdict accepts values only as the parameter
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/Optional setverdict parameters
 **/

module Sem_2402_setverdict_params_002 {
    type component TComp {}
    
    testcase TC_Sem_2402_setverdict_params_002() runs on TComp {
        var template verdicttype v_pass := pass;
        setverdict(valueof(v_pass));
    }
    
    control {
        execute(TC_Sem_2402_setverdict_params_002())
    } 
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24, Ensure setverdict accepts values only as the parameter
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/Optional setverdict parameters
 **/

module Sem_2402_setverdict_params_001 {
    type component TComp {}
    
    testcase TC_Sem_2402_setverdict_params_001() runs on TComp {
        var  anytype v_var := { verdicttype := pass };
        setverdict(v_var.verdicttype);
    }
    
    control {
        execute(TC_Sem_2402_setverdict_params_001())
    } 
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for global verdict: fail can overwrite inconc.
 ** @verdict  pass accept, ttcn3verdict:fail
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/


module Sem_2401_GlobalVerdict_009 {
	type component GeneralComp {}
    
	function set_PTC_verdict_inconc() runs on GeneralComp {
		setverdict(inconc);
	}
	
	function set_PTC_verdict_fail() runs on GeneralComp {
		setverdict(fail);
	}
	
    testcase TC_Sem_2401_GlobalVerdict_009() runs on GeneralComp system GeneralComp {
    	var GeneralComp PTC1, PTC2;
    	
    	PTC1 :=  GeneralComp.create;
    	PTC2 :=  GeneralComp.create;
    	PTC1.start(set_PTC_verdict_inconc());
    	PTC2.start(set_PTC_verdict_fail());
    	all component.done;
    	// Verdict fail can overwrite inconc
    }
    
    control{
        execute(TC_Sem_2401_GlobalVerdict_009());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for local verdict: inconc can't overwrite fail.
 ** @verdict  pass accept, ttcn3verdict:fail
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/The value of the local verdict is changed with the setverdict operation.
 **/


module Sem_2401_LocalVerdict_012 {
	type component GeneralComp {}
    
    testcase TC_Sem_2401_LocalVerdict_012() runs on GeneralComp {
		setverdict(fail);
		setverdict(inconc);
		
		// The verdict is evaluated by the validation tool according to @verdict header
    }
    
    control{
        execute(TC_Sem_2401_LocalVerdict_012());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for local verdict: fail can overwrite inconc.
 ** @verdict  pass accept, ttcn3verdict:fail
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/The value of the local verdict is changed with the setverdict operation.
 **/


module Sem_2401_LocalVerdict_009 {
	type component GeneralComp {}
    
    testcase TC_Sem_2401_LocalVerdict_009() runs on GeneralComp {
		setverdict(inconc);
		setverdict(fail);
		
		// The verdict is evaluated by the validation tool according to @verdict header
    }
    
    control{
        execute(TC_Sem_2401_LocalVerdict_009());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for global verdict: inconc can't overwrite fail.
 ** @verdict  pass accept, ttcn3verdict:fail
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/


module Sem_2401_GlobalVerdict_012 {
	type component GeneralComp {}
    
	function set_PTC_verdict_fail() runs on GeneralComp {
		setverdict(fail);
	}
	
	function set_PTC_verdict_inconc() runs on GeneralComp {
		setverdict(inconc);
	}
	
    testcase TC_Sem_2401_GlobalVerdict_012() runs on GeneralComp system GeneralComp {
    	var GeneralComp PTC1, PTC2;
    	
    	PTC1 :=  GeneralComp.create;
    	PTC2 :=  GeneralComp.create;
    	PTC1.start(set_PTC_verdict_fail());
    	PTC2.start(set_PTC_verdict_inconc());
    	all component.done;
    	// Verdict inconc can't overwrite fail
    }
    
    control{
        execute(TC_Sem_2401_GlobalVerdict_012());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for global verdict: none can't overwrite inconc.
 ** @verdict  pass accept, ttcn3verdict:inconc
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/


module Sem_2401_GlobalVerdict_007 {
	type component GeneralComp {}
    
	function set_PTC_verdict_inconc() runs on GeneralComp {
		setverdict(inconc);
	}
	
	function set_PTC_verdict_none() runs on GeneralComp {
		setverdict(none);
	}
	
    testcase TC_Sem_2401_GlobalVerdict_007() runs on GeneralComp system GeneralComp {
    	var GeneralComp PTC1, PTC2;
    	
    	PTC1 :=  GeneralComp.create;
    	PTC2 :=  GeneralComp.create;
    	PTC1.start(set_PTC_verdict_inconc());
    	PTC2.start(set_PTC_verdict_none());
    	all component.done;
    	// Verdict none can't overwrite inconc
    }
    
    control{
        execute(TC_Sem_2401_GlobalVerdict_007());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24.1, Ensure that there are five values of verdicttype
 ** @verdict  pass accept, noexecution
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Five different values of verdict
 **/


module Syn_2401_FiveValues_001 {
    control {
		var verdicttype v_v;
		
		v_v := none;
		v_v := pass;
		v_v := inconc;
		v_v := fail;
		v_v := error;
    }	
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for global verdict: inconc can overwrite none.
 ** @verdict  pass accept, ttcn3verdict:inconc
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/


module Sem_2401_GlobalVerdict_002 {
	type component GeneralComp {}
    
	function set_PTC_verdict_none() runs on GeneralComp {
		setverdict(none);
	}
	
	function set_PTC_verdict_inconc() runs on GeneralComp {
		setverdict(inconc);
	}
	
    testcase TC_Sem_2401_GlobalVerdict_002() runs on GeneralComp system GeneralComp {
    	var GeneralComp PTC1, PTC2;
    	
    	PTC1 :=  GeneralComp.create;
    	PTC2 :=  GeneralComp.create;
    	PTC1.start(set_PTC_verdict_none());
    	PTC2.start(set_PTC_verdict_inconc());
    	all component.done;
    	// Verdict inconc can overwrite none
    }
    
    control{
        execute(TC_Sem_2401_GlobalVerdict_002());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for local verdict: none can't overwrite fail.
 ** @verdict  pass accept, ttcn3verdict:fail
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/The value of the local verdict is changed with the setverdict operation.
 **/


module Sem_2401_LocalVerdict_010 {
	type component GeneralComp {}
    
    testcase TC_Sem_2401_LocalVerdict_010() runs on GeneralComp {
		setverdict(fail);
		setverdict(none);
		
		// The verdict is evaluated by the validation tool according to @verdict header
    }
    
    control{
        execute(TC_Sem_2401_LocalVerdict_010());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for local verdict: pass can overwrite none.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/The value of the local verdict is changed with the setverdict operation.
 **/


module Sem_2401_LocalVerdict_001 {
	type component GeneralComp {}
    
    testcase TC_Sem_2401_LocalVerdict_001() runs on GeneralComp {
		setverdict(none);
		setverdict(pass);
		
		// The verdict is evaluated by the validation tool according to @verdict header
    }
    
    control{
        execute(TC_Sem_2401_LocalVerdict_001());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for global verdict: inconc can overwrite pass.
 ** @verdict  pass accept, ttcn3verdict:inconc
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/


module Sem_2401_GlobalVerdict_005 {
	type component GeneralComp {}
    
	function set_PTC_verdict_pass() runs on GeneralComp {
		setverdict(pass);
	}
	
	function set_PTC_verdict_inconc() runs on GeneralComp {
		setverdict(inconc);
	}
	
    testcase TC_Sem_2401_GlobalVerdict_005() runs on GeneralComp system GeneralComp {
    	var GeneralComp PTC1, PTC2;
    	
    	PTC1 :=  GeneralComp.create;
    	PTC2 :=  GeneralComp.create;
    	PTC1.start(set_PTC_verdict_pass());
    	PTC2.start(set_PTC_verdict_inconc());
    	all component.done;
    	// Verdict inconc can overwrite pass
    }
    
    control{
        execute(TC_Sem_2401_GlobalVerdict_005());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for local verdict: pass can't overwrite fail.
 ** @verdict  pass accept, ttcn3verdict:fail
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/The value of the local verdict is changed with the setverdict operation.
 **/


module Sem_2401_LocalVerdict_011 {
	type component GeneralComp {}
    
    testcase TC_Sem_2401_LocalVerdict_011() runs on GeneralComp {
		setverdict(fail);
		setverdict(pass);
		
		// The verdict is evaluated by the validation tool according to @verdict header
    }
    
    control{
        execute(TC_Sem_2401_LocalVerdict_011());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for local verdict: none can't overwrite inconc.
 ** @verdict  pass accept, ttcn3verdict:inconc
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/The value of the local verdict is changed with the setverdict operation.
 **/


module Sem_2401_LocalVerdict_007 {
	type component GeneralComp {}
    
    testcase TC_Sem_2401_LocalVerdict_007() runs on GeneralComp {
		setverdict(inconc);
		setverdict(none);
		
		// The verdict is evaluated by the validation tool according to @verdict header
    }
    
    control{
        execute(TC_Sem_2401_LocalVerdict_007());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for global verdict: pass can't overwrite inconc.
 ** @verdict  pass accept, ttcn3verdict:inconc
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/


module Sem_2401_GlobalVerdict_008 {
	type component GeneralComp {}
    
	function set_PTC_verdict_inconc() runs on GeneralComp {
		setverdict(inconc);
	}
	
	function set_PTC_verdict_pass() runs on GeneralComp {
		setverdict(pass);
	}
	
    testcase TC_Sem_2401_GlobalVerdict_008() runs on GeneralComp system GeneralComp {
    	var GeneralComp PTC1, PTC2;
    	
    	PTC1 :=  GeneralComp.create;
    	PTC2 :=  GeneralComp.create;
    	PTC1.start(set_PTC_verdict_inconc());
    	PTC2.start(set_PTC_verdict_pass());
    	all component.done;
    	// Verdict pass can't overwrite inconc
    }
    
    control{
        execute(TC_Sem_2401_GlobalVerdict_008());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for local verdict: inconc can overwrite none.
 ** @verdict  pass accept, ttcn3verdict:inconc
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/The value of the local verdict is changed with the setverdict operation.
 **/


module Sem_2401_LocalVerdict_002 {
	type component GeneralComp {}
    
    testcase TC_Sem_2401_LocalVerdict_002() runs on GeneralComp {
		setverdict(none);
		setverdict(inconc);
		
		// The verdict is evaluated by the validation tool according to @verdict header
    }
    
    control{
        execute(TC_Sem_2401_LocalVerdict_002());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for global verdict: pass can overwrite none.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/


module Sem_2401_GlobalVerdict_001 {
	type component GeneralComp {}
    
	function set_PTC_verdict_none() runs on GeneralComp {
		setverdict(none);
	}
	
	function set_PTC_verdict_pass() runs on GeneralComp {
		setverdict(pass);
	}
	
    testcase TC_Sem_2401_GlobalVerdict_001() runs on GeneralComp system GeneralComp {
    	var GeneralComp PTC1, PTC2;
    	
    	PTC1 :=  GeneralComp.create;
    	PTC2 :=  GeneralComp.create;
    	PTC1.start(set_PTC_verdict_none());
    	PTC2.start(set_PTC_verdict_pass());
    	all component.done;
    	// Verdict pass can overwrite none
    }
    
    control{
        execute(TC_Sem_2401_GlobalVerdict_001());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for local verdict: inconc can overwrite pass.
 ** @verdict  pass accept, ttcn3verdict:inconc
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/The value of the local verdict is changed with the setverdict operation.
 **/


module Sem_2401_LocalVerdict_005 {
	type component GeneralComp {}
    
    testcase TC_Sem_2401_LocalVerdict_005() runs on GeneralComp {
		setverdict(pass);
		setverdict(inconc);
		
		// The verdict is evaluated by the validation tool according to @verdict header
    }
    
    control{
        execute(TC_Sem_2401_LocalVerdict_005());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for local verdict: fail can overwrite pass.
 ** @verdict  pass accept, ttcn3verdict:fail
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/The value of the local verdict is changed with the setverdict operation.
 **/


module Sem_2401_LocalVerdict_006 {
	type component GeneralComp {}
    
    testcase TC_Sem_2401_LocalVerdict_006() runs on GeneralComp {
		setverdict(pass);
		setverdict(fail);
		
		// The verdict is evaluated by the validation tool according to @verdict header
    }
    
    control{
        execute(TC_Sem_2401_LocalVerdict_006());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for global verdict: pass can't overwrite fail.
 ** @verdict  pass accept, ttcn3verdict:fail
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/


module Sem_2401_GlobalVerdict_011 {
	type component GeneralComp {}
    
	function set_PTC_verdict_fail() runs on GeneralComp {
		setverdict(fail);
	}
	
	function set_PTC_verdict_pass() runs on GeneralComp {
		setverdict(pass);
	}
	
    testcase TC_Sem_2401_GlobalVerdict_011() runs on GeneralComp system GeneralComp {
    	var GeneralComp PTC1, PTC2;
    	
    	PTC1 :=  GeneralComp.create;
    	PTC2 :=  GeneralComp.create;
    	PTC1.start(set_PTC_verdict_fail());
    	PTC2.start(set_PTC_verdict_pass());
    	all component.done;
    	// Verdict pass can't overwrite fail
    }
    
    control{
        execute(TC_Sem_2401_GlobalVerdict_011());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for global verdict: none can't overwrite pass.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/


module Sem_2401_GlobalVerdict_004 {
	type component GeneralComp {}
    
	function set_PTC_verdict_pass() runs on GeneralComp {
		setverdict(pass);
	}
	
	function set_PTC_verdict_none() runs on GeneralComp {
		setverdict(none);
	}
	
    testcase TC_Sem_2401_GlobalVerdict_004() runs on GeneralComp system GeneralComp {
    	var GeneralComp PTC1, PTC2;
    	
    	PTC1 :=  GeneralComp.create;
    	PTC2 :=  GeneralComp.create;
    	PTC1.start(set_PTC_verdict_pass());
    	PTC2.start(set_PTC_verdict_none());
    	all component.done;
    	// Verdict none can't overwrite pass
    }
    
    control{
        execute(TC_Sem_2401_GlobalVerdict_004());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for local verdict: pass can't overwrite inconc.
 ** @verdict  pass accept, ttcn3verdict:inconc
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/The value of the local verdict is changed with the setverdict operation.
 **/


module Sem_2401_LocalVerdict_008 {
	type component GeneralComp {}
    
    testcase TC_Sem_2401_LocalVerdict_008() runs on GeneralComp {
		setverdict(inconc);
		setverdict(pass);
		
		// The verdict is evaluated by the validation tool according to @verdict header
    }
    
    control{
        execute(TC_Sem_2401_LocalVerdict_008());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for global verdict: fail can overwrite none.
 ** @verdict  pass accept, ttcn3verdict:fail
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/


module Sem_2401_GlobalVerdict_003 {
	type component GeneralComp {}
    
	function set_PTC_verdict_none() runs on GeneralComp {
		setverdict(none);
	}
	
	function set_PTC_verdict_fail() runs on GeneralComp {
		setverdict(fail);
	}
	
    testcase TC_Sem_2401_GlobalVerdict_003() runs on GeneralComp system GeneralComp {
    	var GeneralComp PTC1, PTC2;
    	
    	PTC1 :=  GeneralComp.create;
    	PTC2 :=  GeneralComp.create;
    	PTC1.start(set_PTC_verdict_none());
    	PTC2.start(set_PTC_verdict_fail());
    	all component.done;
    	// Verdict fail can overwrite none
    }
    
    control{
        execute(TC_Sem_2401_GlobalVerdict_003());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for local verdict: none can't overwrite pass.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/The value of the local verdict is changed with the setverdict operation.
 **/


module Sem_2401_LocalVerdict_004 {
	type component GeneralComp {}
    
    testcase TC_Sem_2401_LocalVerdict_004() runs on GeneralComp {
		setverdict(pass);
		setverdict(none);
		
		// The verdict is evaluated by the validation tool according to @verdict header
    }
    
    control{
        execute(TC_Sem_2401_LocalVerdict_004());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for local verdict: fail can overwrite none.
 ** @verdict  pass accept, ttcn3verdict:fail
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.2 The Setverdict operation/The value of the local verdict is changed with the setverdict operation.
 **/


module Sem_2401_LocalVerdict_003 {
	type component GeneralComp {}
    
    testcase TC_Sem_2401_LocalVerdict_003() runs on GeneralComp {
		setverdict(none);
		setverdict(fail);
		
		// The verdict is evaluated by the validation tool according to @verdict header
    }
    
    control{
        execute(TC_Sem_2401_LocalVerdict_003());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for global verdict: fail can overwrite pass.
 ** @verdict  pass accept, ttcn3verdict:fail
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/


module Sem_2401_GlobalVerdict_006 {
	type component GeneralComp {}
    
	function set_PTC_verdict_pass() runs on GeneralComp {
		setverdict(pass);
	}
	
	function set_PTC_verdict_fail() runs on GeneralComp {
		setverdict(fail);
	}
	
    testcase TC_Sem_2401_GlobalVerdict_006() runs on GeneralComp system GeneralComp {
    	var GeneralComp PTC1, PTC2;
    	
    	PTC1 :=  GeneralComp.create;
    	PTC2 :=  GeneralComp.create;
    	PTC1.start(set_PTC_verdict_pass());
    	PTC2.start(set_PTC_verdict_fail());
    	all component.done;
    	// Verdict fail can overwrite pass
    }
    
    control{
        execute(TC_Sem_2401_GlobalVerdict_006());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24.1, Ensure that local verdicts initializes with none
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Local verdict is initialized with none
 **/


module Sem_2401_InitiallyNone_001 {
    type component GeneralComp {}
    
    testcase TC_Sem_2401_InitiallyNone_001() runs on GeneralComp {
        var verdicttype b_verdict := getverdict;
        if (b_verdict == none) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_2401_InitiallyNone_001());
    }	
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.1, Ensure overwriting rules for global verdict: none can't overwrite fail.
 ** @verdict  pass accept, ttcn3verdict:fail
 *****************************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.1 The Verdict mechanism/Overwriting rules for setverdict
 **/


module Sem_2401_GlobalVerdict_010 {
	type component GeneralComp {}
    
	function set_PTC_verdict_fail() runs on GeneralComp {
		setverdict(fail);
	}
	
	function set_PTC_verdict_none() runs on GeneralComp {
		setverdict(none);
	}
	
    testcase TC_Sem_2401_GlobalVerdict_010() runs on GeneralComp system GeneralComp {
    	var GeneralComp PTC1, PTC2;
    	
    	PTC1 :=  GeneralComp.create;
    	PTC2 :=  GeneralComp.create;
    	PTC1.start(set_PTC_verdict_fail());
    	PTC2.start(set_PTC_verdict_none());
    	all component.done;
    	// Verdict none can't overwrite fail
    }
    
    control{
        execute(TC_Sem_2401_GlobalVerdict_010());
    }	
}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24.3, Ensure getverdict returns the actual verdict none
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// #reqname  /Requirements/24 Test verdict operations/24.3  The Getverdict operation/Getverdict returns local verdict value

module Sem_2403_getverdict_001 {
    type component TComp {}
    
    testcase TC_Sem_2403_getverdict_001() runs on TComp {
        var verdicttype v_verdict;
        setverdict(none);
        v_verdict := getverdict;
        if (v_verdict == none)
        {
            setverdict(pass)
        }
        else
        {
            setverdict(fail);
        } 
    }
    
    control {
        execute(TC_Sem_2403_getverdict_001())
    } 
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24.3, Ensure getverdict none for uninitialized verdict
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.3  The Getverdict operation/Getverdict returns local verdict value/Getverdict returns none for uninitialized verdict
 **/

module Sem_2403_getverdict_005 {
    type component TComp {}
    
    testcase TC_Sem_2403_getverdict_005() runs on TComp {
        var verdicttype v_verdict;
        v_verdict := getverdict;
        if (v_verdict != none)
        {
        	// Set error verdict
            testcase.stop;
        }
        else
        {
            setverdict(pass);
        } 
    }
    
    control {
        execute(TC_Sem_2403_getverdict_005())
    } 
}/***************************************************
 ** @author   STF 433 
 ** @version  0.0.1
 ** @purpose  1:24.3, Ensure getverdict returns the actual verdict pass
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.3  The Getverdict operation/Getverdict returns local verdict value
 **/

module Sem_2403_getverdict_003 {
    type component TComp {}
    
    testcase TC_Sem_2403_getverdict_003() runs on TComp {
        var verdicttype v_verdict;
        setverdict(pass);
        v_verdict := getverdict;
        if (v_verdict == pass)
        {
            setverdict(pass)
        }
        else
        {
            setverdict(fail);
        } 
    }
    
    control {
        execute(TC_Sem_2403_getverdict_003())
    } 
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:24.3, Ensure getverdict returns the actual verdict fail
 ** @verdict  pass accept, ttcn3verdict:error
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.3  The Getverdict operation/Getverdict returns local verdict value
 **/

module Sem_2403_getverdict_004 {
    type component TComp {}
    
    testcase TC_Sem_2403_getverdict_004() runs on TComp {
        var verdicttype v_verdict;
        setverdict(fail);
        v_verdict := getverdict;
        if (v_verdict == fail)
        {
        	// Set error verdict
            testcase.stop;
        }        
    }
    
    control {
        execute(TC_Sem_2403_getverdict_004())
    } 
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:24.3, Ensure getverdict returns the actual verdict inconc
 ** @verdict  pass accept, ttcn3verdict:inconc
 ***************************************************/
/*
 * #reqname  /Requirements/24 Test verdict operations/24.3  The Getverdict operation/Getverdict returns local verdict value
 **/

module Sem_2403_getverdict_002 {
    type component TComp {}
    
    testcase TC_Sem_2403_getverdict_002() runs on TComp {
        var verdicttype v_verdict;
        setverdict(inconc);
        v_verdict := getverdict;
        if (v_verdict != inconc)
        {
            setverdict(fail);
        }
        
    }
    
    control {
        execute(TC_Sem_2403_getverdict_002())
    } 
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:27.1.1, Ensure that attributes for language elements are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_270101_ScopeOfAttributes_001 {

    type record of integer IntegerList 
    with {
     display "colour red";
     extension "MyRule"
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:27.1.1, Ensure that attributes for individual fields are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_270101_ScopeOfAttributes_004 {

    type record MyRecord { 
     integer field1,
     record {
	  integer innerField1,
	  boolean innerField2
     } field2 
    }
    with {
     display "colour red";
     extension "MyRule"
    }

   const MyRecord c_record := {0,{1,true}}
    with {
     display (field2.innerField1) "colour green"
    }
    
   
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:27.1.1, Ensure that attributes for individual fields are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_270101_ScopeOfAttributes_003 {

    type record of integer IntegerList 
    with {
     display "colour red";
     extension "MyRule"
    }

   const IntegerList c_MyIntegers1 := {0,1,2,3}
    with {
     display ([-]) "colour green"
    }
    
   const IntegerList c_MyIntegers2 := {0,1,2,3}
    with {
     display ([0]) "colour black";
    }
   
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:27.1.1, Ensure that attributes for language elements are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_270101_ScopeOfAttributes_002 {

    type record MyRecord { 
     integer field1,
     record {
	  integer innerField1,
	  boolean innerField2
     } field2 
    }
    with {
     display "colour red";
     extension "MyRule"
    }

}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:27.7, Ensure that the IUT correctly handles attribute definitions and their scoping rules 
 ** @verdict  pass reject
 ***************************************************/

module Sem_2707_OptionalAttributes_008 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

    type port loopbackPort message {
	  inout MessageType
	} with { optional "implicit omit"}
	// the optional keyword is not forbidden here, has just no effect
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}

testcase TC_Sem_2707_OptionalAttributes_008() runs on GeneralComp {

    var MessageType v_testMessage;

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=omit,b:=omit,c:=true}, 
  field7 := {a:=omit,b:=omit,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 }
 
}

control{
    execute(TC_Sem_2707_OptionalAttributes_008());
}

}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:27.7, Ensure that the IUT correctly handles attribute definitions and their scoping rules 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_2707_OptionalAttributes_004 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=omit,b:=omit,c:=true}, 	//a and b fields are specifically defined
  field7 := {a:=omit,b:=omit,c:=true}, 	//a and b fields are specifically defined
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } with { optional "explicit omit"}

 const MessageType c_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=omit,b:=omit,c:=true}, 
  field7 := {a:=omit,b:=omit,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_2707_OptionalAttributes_004() runs on GeneralComp {

    var MessageType v_testMessage:=c_testMessage;
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_2707_OptionalAttributes_004());
}

}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:27.7, Ensure that the IUT correctly handles attribute definitions and their scoping rules 
 ** @verdict  pass accept, noexecution
 ***************************************************/

module Syn_2707_OptionalAttributes_001 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

    type port loopbackPort message {
	  inout MessageType
	}
	
 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

 const MessageType c_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=omit,b:=omit,c:=true}, 
  field7 := {a:=omit,b:=omit,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } with { optional "implicit omit"}  //optional attribute can be accepted on constants

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Syn_2707_OptionalAttributes_001() runs on GeneralComp {

    var MessageType v_testMessage:=c_testMessage;
 
}

control{

    execute(TC_Syn_2707_OptionalAttributes_001());
}

}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:27.7, Ensure that the IUT correctly handles attribute definitions and their scoping rules 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_2707_OptionalAttributes_001 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {c:=true}, 	//a and b fields are omitted
  field7 := {c:=true}, 	//a and b fields are omitted
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } with { optional "implicit omit"}

 const MessageType c_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=omit,c:=true}, 
  field7 := {a:=omit,b:=1,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 


    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_2707_OptionalAttributes_001() runs on GeneralComp {

    var MessageType v_testMessage:=c_testMessage;
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_2707_OptionalAttributes_001());
}

}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:27.7, Ensure that the IUT correctly handles attribute definitions and their scoping rules 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_2707_OptionalAttributes_007 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {c:=true}, 	//a and b fields are omitted
  field7 := {c:=true}, 	//a and b fields are omitted
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } with { optional "implicit omit"}

 const MessageType c_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=omit,b:=omit,c:=true}, 
  field7 := {a:=omit,b:=omit,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_2707_OptionalAttributes_007() runs on GeneralComp {

    var MessageType v_testMessage:=c_testMessage;
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_2707_OptionalAttributes_007());
}

}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:27.7, Ensure that the IUT correctly handles attribute definitions and their scoping rules 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_2707_OptionalAttributes_006 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {c:=true}, 	//a and b fields are omitted
  field7 := {c:=true}, 	//a and b fields are omitted
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

 const MessageType c_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=omit,c:=true}, 
  field7 := {a:=omit,b:=1,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_2707_OptionalAttributes_006() runs on GeneralComp {

    var MessageType v_testMessage:=c_testMessage;
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_2707_OptionalAttributes_006());
}

} with { optional "implicit omit"}  //this attribute has an effect only on the template definition in the module
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:27.7, Ensure that the IUT correctly handles attribute definitions and their scoping rules 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_2707_OptionalAttributes_002 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 	//a and b fields are specifically defined
  field7 := {a:=1,b:=2,c:=true}, 	//a and b fields are specifically defined
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } with { optional "implicit omit"}

 const MessageType c_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 
  field7 := {a:=1,b:=2,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_2707_OptionalAttributes_002() runs on GeneralComp {

    var MessageType v_testMessage:=c_testMessage;
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }
}

control{
    execute(TC_Sem_2707_OptionalAttributes_002());
}

}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:27.7, Ensure that the IUT correctly handles attribute definitions and their scoping rules 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_2707_OptionalAttributes_003 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=1,b:=2,c:=true}, 	//a and b fields are specifically defined
  field7 := {a:=1,b:=2,c:=true}, 	//a and b fields are specifically defined
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } with { optional "explicit omit"}

 const MessageType c_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=omit,b:=omit,c:=true}, 
  field7 := {a:=omit,b:=omit,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_2707_OptionalAttributes_003() runs on GeneralComp {

    var MessageType v_testMessage:=c_testMessage;
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_2707_OptionalAttributes_003());
}

}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:27.7, Ensure that the IUT correctly handles attribute definitions and their scoping rules 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_2707_OptionalAttributes_005 { 

	type enumerated EnumeratedType {e_black, e_white};

	type record RecordType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a optional, 
 	 integer  b optional, 
 	 boolean  c 
	} 

	type record length (1..2) of integer IntegerList;

	type set length (1..2) of integer IntegerUList;

	type union UnionType { 
 	 integer  a, 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2, 
  	 boolean  		field3, 
  	 integer  		field4[4],
  	 EnumeratedType field5,
  	 RecordType		field6,
  	 SetType		field7,
  	 UnionType		field8,
  	 IntegerList	field9,
  	 IntegerUList	field10
	}

 template MessageType mw_matchingTemplate:= 
 {  
  field1 := 1,
  field2 := "test string",	 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {b:=3,c:=true}, 	//a is omitted
  field7 := {a:=3,c:=true}, 	//b is omitted
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } with { optional (field6, field7) "implicit omit"}


 const MessageType c_testMessage:=  {  
  field1 := 1,
  field2 := "test string", 
  field3 := true, 
  field4 := {1,2,3,4},
  field5 := e_black,
  field6 := {a:=3,b:=3,c:=true}, 
  field7 := {a:=3,b:=3,c:=true}, 
  field8 := {a:=1},
  field9 := {1},
  field10 := {1,2}
 } 

    type port loopbackPort message {
	  inout MessageType
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_2707_OptionalAttributes_005() runs on GeneralComp {

    var MessageType v_testMessage:=c_testMessage;
 
 messagePort.send(v_testMessage);

    alt {
     [] messagePort.receive(mw_matchingTemplate) {
        setverdict(fail);
     }
     [] messagePort.receive {
        setverdict(pass);
     }
    }
}

control{
    execute(TC_Sem_2707_OptionalAttributes_005());
}

} with { optional "explicit omit"}
/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:10, Assign and read constants values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_10_Constants_002 {

    const integer c_ai[3] := {1, 3, 5};
    
    type component GeneralComp {}
    
    testcase TC_Sem_10_Constants_002() runs on GeneralComp {
        const integer c_j := 5;
    
    	if (c_ai[2] == c_j){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_10_Constants_002());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:10, Single expression and constant values 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_10_Constants_003 {

    const float c_p :=3.0;
    const float c_i :=0.14;
    
    type component GeneralComp {
    }
    
    testcase TC_Sem_10_Constants_003() runs on GeneralComp {

        const float c_pi := (c_p+c_i);

        if (c_pi == 3.14){
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }//end testcase
    
    control{
        execute(TC_Sem_10_Constants_003());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:10, Record type used as a constant with optional fields
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_10_Constants_007 {

    type record MyRecordType
    {
        bitstring field1,
        boolean field2 optional,
        charstring field3 optional
     
    };
    
    type component GeneralComp {
    }
    
    testcase TC_Sem_10_Constants_007() runs on GeneralComp {
        const MyRecordType c_mRT3 := {field1 := '1010'B,
                                      field2 := -,
                                      field3 := -};

        if (not isbound(c_mRT3.field2) and
            not isbound(c_mRT3.field3) and
            match(c_mRT3.field1, '1010'B)) 
            {
                setverdict(pass);
            }
            else {
                setverdict(fail);
            }
    }
    
    control{
        execute(TC_Sem_10_Constants_007());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:10, Assign component constants values
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_10_Constants_003 {
    type component GeneralComp {}
    
    const GeneralComp c_c := null;
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:10, Record type used as a constant
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_10_Constants_006 {

    type record MyRecordType
    {
        bitstring field1,
        boolean field2,
        charstring field3
    };
    
    type component GeneralComp {
    }
    
    testcase TC_Sem_10_Constants_006() runs on GeneralComp {
        const MyRecordType c_mRT1 := {'1010'B,true,"string"};
        const MyRecordType c_mRT2 := {field1 := '1010'B,
                                     field2 := true,
                                     field3 := "string"};

        if (c_mRT1==c_mRT2) 
            {
                setverdict(pass);
            }
            else {
                setverdict(fail);
            }
    }// end testcase
    
    control{
        execute(TC_Sem_10_Constants_006());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:10, Constant used within invoke function with return 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_10_Constants_004 {
    
    type component GeneralComp {
    }
    //2
    function f_Sem_10_Constants_004(integer p_int) runs on GeneralComp return integer{
        const integer c_i := 2;
        if(p_int==0)
        {
            return c_i;
        }
        else
        {
            return 0;
        }
    }
    
    testcase TC_Sem_10_Constants_004() runs on GeneralComp {
        const integer c_int := 2;
        if (f_Sem_10_Constants_004(0)==c_int)
        {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    } //end testcase
    
    control{
        execute(TC_Sem_10_Constants_004());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:10, Assign default constants values
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_10_Constants_002 {
    const default c_d := null;
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:10, Assign and read constants
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_10_Constants_001 {

    const integer c_i := 5;
    
    type component GeneralComp {}
    
    testcase TC_Sem_10_Constants_001() runs on GeneralComp {
        const integer c_j := 5;
    
    	if (c_i == c_j){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_10_Constants_001());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:10, Define constants in different scopes
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_10_Constants_004 {
    type component GeneralComp {
        timer t;
        const integer cv_i1 := 10;
    }
    
    const integer c_i1 := 5;
    
    altstep a_Syn_10_Constants_004() runs on GeneralComp {
      const integer cl_j := 12;
      [] t.timeout {
          const integer cl_k := 13;
      }
    }

	function f_Syn_10_Constants_004() runs on GeneralComp {
  		const integer cl_i := 2;
	}

	testcase TC_Syn_10_Constants_004() runs on GeneralComp {
  		const integer cl_i := 3;
	}
    
    control {
        const integer cl_i := 1;
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:10, Set type used as a constant with optional fields
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_10_Constants_009 {

    type record MySetType
    {
        bitstring field1,
        boolean field2 optional,
        charstring field3 optional
     
    };
    
    type component GeneralComp {
    }
    
    testcase TC_Sem_10_Constants_009() runs on GeneralComp {
        const MySetType c_mST3 := {field1 := '1010'B,
                                   field2 := -,
                                   field3 := -};

        if (not isbound(c_mST3.field2) and
            not isbound(c_mST3.field3) and
            match(c_mST3.field1, '1010'B)) 
            {
                setverdict(pass);
            }
            else {
                setverdict(fail);
            }
    }
    
    control{
        execute(TC_Sem_10_Constants_009());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:10, Constant used within predefined function
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_10_Constants_005 {

    type component GeneralComp {
    }
    
    testcase TC_Sem_10_Constants_005() runs on GeneralComp {

        const integer c_j := 5;
        const charstring c_str_j := int2str(c_j); 

        if (c_str_j=="5"){
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }//end testcase
    
    control{
        execute(TC_Sem_10_Constants_005());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:10, Create constants
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_10_Constants_001 {
    const integer c_i1 := 5, c_i2 := 3;
    const float c_f := 3.14E-4;
    const boolean c_b := true, c_b2 := false;
    const bitstring c_bs := '1011'B;
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:10, Set type used as a constant
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_10_Constants_008 {

    type set MySetType
    {
        bitstring field1,
        boolean field2,
        charstring field3
    };
    
    type component GeneralComp {
    }
    
    testcase TC_Sem_10_Constants_008() runs on GeneralComp {
        const MySetType c_mST1 := {'1010'B,true,"string"};
        const MySetType c_mST2 := {field1 := '1010'B,
                                     field2 := true,
                                     field3 := "string"};

        if (c_mST1==c_mST2) 
            {
                setverdict(pass);
            }
            else {
                setverdict(fail);
            }
    }// end testcase
    
    control{
        execute(TC_Sem_10_Constants_008());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:11.1, Define variables in different scopes
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_1101_ValueVars_001 {
    type component GeneralComp {
        var integer vc_i1 := 10;
    }
    
    altstep a_Syn_1101_ValueVars_001() runs on GeneralComp {
      var integer v_j := 12;
      [] any timer.timeout {
          var integer v_k := 13;
      }
    }

	function f_Syn_1101_ValueVars_001() runs on GeneralComp {
  		var integer v_i := 2;
	}

	testcase TC_Syn_1101_ValueVars_001() runs on GeneralComp {
  		var integer v_i := 3;
	}
    
    control {
        var integer v_i := 1;
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:11.1, Define variables in different scopes
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1101_ValueVars_001 {
    type component GeneralComp {
        timer t;
        var integer vc_i1 := 10;
    }
    
    altstep a_Sem_1101_ValueVars_001() runs on GeneralComp {
      var integer v_j := 12;
      [] t.timeout {
          var integer v_k := 13;
      }
    }

	function f_Sem_1101_ValueVars_001() runs on GeneralComp {
  		var integer v_i := 2;
	}

	testcase TC_Sem_1101_ValueVars_001() runs on GeneralComp {
  		var integer v_i := 3;
        f_Sem_1101_ValueVars_001();
        
        t.start(1.0);
        alt {
	        [] a_Sem_1101_ValueVars_001();
        }

        setverdict(pass);
	}
    
    control {
        var integer v_i := 1;
        execute(TC_Sem_1101_ValueVars_001());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:11.1, Define variables in different scopes
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1101_ValueVars_002 {
    type component GeneralComp {}
    
	testcase TC_Sem_1101_ValueVars_002() runs on GeneralComp {
        var boolean v_b := true;
        if (v_b){
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
        v_b := false;
        if (not v_b){
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
	}
    
    control {
        execute(TC_Sem_1101_ValueVars_002());
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:11.1, Ensure that partially initialized variables are evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1101_ValueVars_005 {

type component GeneralComp {	    	    
}

 type set IntegerSet {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional
 };

function f_partial () runs on GeneralComp return IntegerSet {
 return {a1:=1,a2:=omit};
}

testcase TC_Sem_1101_ValueVars_005() runs on GeneralComp {
	var IntegerSet v_set := f_partial();
	v_set.a3 := 3;

	if ( match(v_set, {a1:=1,a2:=omit,a3:=3}) ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1101_ValueVars_005());
}

}
/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:11.1, Read and write variables
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1101_ValueVars_003 {
    type component GeneralComp {
        timer t;
        var integer vc_ai[3] := {1, 3, 5};
    }
    
	testcase TC_Sem_1101_ValueVars_003() runs on GeneralComp {
  		var integer v_i := 3;
        v_i := 5;
        vc_ai[1] := 5;
    
        if (vc_ai[1] == v_i){
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
	}
    
    control {
        execute(TC_Sem_1101_ValueVars_003());
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:11.1, Ensure that partially initialized variables are evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1101_ValueVars_004 {

type component GeneralComp {	    	    
}

 type set IntegerSet {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional
 };

testcase TC_Sem_1101_ValueVars_004() runs on GeneralComp {
	var IntegerSet v_set := {a1:=1,a2:=omit};
	v_set.a3 := 3;

	if ( match(v_set, {a1:=1,a2:=omit,a3:=3}) ) {
		setverdict(pass);
	} else {
		setverdict(fail);
	}
}

control{
    execute(TC_Sem_1101_ValueVars_004());
}

}
/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:11.2, Ensure that partially initialized templates are evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1102_TemplateVars_003 {

 type set IntegerSet {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional
 };

    type port loopbackPort message {
	  inout IntegerSet
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

function f_partial () runs on GeneralComp return template IntegerSet {
 var template IntegerSet mw_return := {a1:=1,a2:=*};
 
 return mw_return;
}

testcase TC_Sem_1102_TemplateVars_003() runs on GeneralComp {
	var template IntegerSet mw_pattern := f_partial();
	var IntegerSet v_set := {a1:=1,a2:=2,a3:=3}
	mw_pattern.a3 := 3;

    messagePort.send(v_set);

    alt {
     [] messagePort.receive(mw_pattern) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }

}

control{
    execute(TC_Sem_1102_TemplateVars_003());
}

}
/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:11.2, Define template variables in different scopes
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_1102_TemplateVars_001 {
    type component GeneralComp {
        var template integer vc_i1 := omit;
    }

    altstep a_Syn_1102_TemplateVars_001() runs on GeneralComp {
      var integer v_j := 12;
      [] any timer.timeout {
          var template integer v_k := ?;
      }
    }

    function f_Syn_1102_TemplateVars_001() runs on GeneralComp {
        var template integer v_i := *;
    }

    testcase TC_Syn_1102_TemplateVars_001() runs on GeneralComp {
        var template integer v_i := (1, 2, 3);
    }

    control {
        var template integer v_i := (1..2);
    }
}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:11.2, Ensure that partially initialized templates are evaluated correctly.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_1102_TemplateVars_002 {

 type set IntegerSet {
  integer a1 optional,
  integer a2 optional,
  integer a3 optional
 };

    type port loopbackPort message {
	  inout IntegerSet
	}
	

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

testcase TC_Sem_1102_TemplateVars_002() runs on GeneralComp {
	var template IntegerSet mw_pattern := {a1:=1,a2:=*};
	var IntegerSet v_set := {a1:=1,a2:=2,a3:=3}
	mw_pattern.a3 := 3;

 messagePort.send(v_set);

    alt {
     [] messagePort.receive(mw_pattern) {
        setverdict(pass);
     }
     [] messagePort.receive {
        setverdict(fail);
     }
    }

}

control{
    execute(TC_Sem_1102_TemplateVars_002());
}

}
/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:11.2, Define variables in different scopes
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1102_TemplateVars_001 {
    type component GeneralComp {
        timer t;
        var template integer vc_i1 := omit;
    }
    
    altstep a_Sem_1102_TemplateVars_001() runs on GeneralComp {
      var integer v_j := 12;
      [] t.timeout {
          var template integer v_k := ?;
      }
    }

	function f_Sem_1102_TemplateVars_001() runs on GeneralComp {
  		var template integer v_i := *;
	}

	testcase TC_Sem_1102_TemplateVars_001() runs on GeneralComp {
  		var template integer v_i := (1, 2, 3);
        f_Sem_1102_TemplateVars_001();
        
        t.start(1.0);
        alt {
	        [] a_Sem_1102_TemplateVars_001();
        }

        setverdict(pass);
	}
    
    control {
        var template integer v_i := (1..2);
        execute(TC_Sem_1102_TemplateVars_001());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, array as a record-of value index on right hand side (dimensions match)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_023 {

	type component GeneralComp {	    	    
	}
 
	type record of record of integer RoRoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_023() runs on GeneralComp {

		var RoRoI v_rec := {{0, 1}, {2, 3}};
        var integer v_index[2] := { 1, 0 }
		if (v_rec[v_index] == 2) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_023());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, array as a set-of value index on left hand side (less items than record-of dimension)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_034 {

	type component GeneralComp {	    	    
	}
 
	type set of set of set of integer SoSoSoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_034() runs on GeneralComp {

		var SoSoSoI v_set := {{{0, 1}, {2, 3}}, {{4, 5, 6}, {7, 8}}};
        var integer v_index[2] := { 1, 0 }
        v_set[v_index] := { 100, - };
		if (v_set == {{{0, 1}, {2, 3}}, {{100, 5}, {7, 8}}}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_034());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, fixed-size set-of as a record-of value index on right hand side (less items than record-of dimension)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_037 {

	type component GeneralComp {	    	    
	}
 
    type record length(2) of integer Indexer;
	type set of set of set of integer SoSoSoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_037() runs on GeneralComp {

		var SoSoSoI v_set := {{{0, 1}, {2, 3}}, {{4, 5, 6}, {7, 8}}};
        var Indexer v_index := { 1, 0 }
		if (v_set[v_index] == {4, 5, 6}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_037());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify handling of value list assignment used for update of set of values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Elements to be left out of the assignment shall be explicitly skipped in the list 
// by use of the not-used-symbol "-". Already initialized elements left without 
// a corresponding list member in a value list notation (i.e. at the end of a list) 
// are becoming uninitialized. In this way, a value with initialized elements can be 
// made empty by using the empty value list notation ("{}").
module Sem_060203_records_and_sets_of_single_types_011 {

	type component GeneralComp {	    	    
	}
 
	type set of integer SoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_011() runs on GeneralComp {

		var SoI v_set := { 0, 1, 2 }; 
		v_set := { 10, - };
		if (v_set == { 10, 1 } ) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
		v_set := {};
		if (lengthof(v_set) == 0 ) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_011());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify handling of value list assignment used for initialization of record of values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When using the value list notation, all elements in the structure shall 
// be specified either with a value or the not used symbol "-". The first 
// member of the list is assigned to the first element, the second list 
// member is assigned to the second element, etc.
module Sem_060203_records_and_sets_of_single_types_008 {

	type component GeneralComp {	    	    
	}
 
	type record of integer RoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_008() runs on GeneralComp {

		var RoI v_rec := { 0, 1, - }; 
		if (match(v_rec[0], 0) and match(v_rec[1], 1) and not isbound(v_rec[2])
			and lengthof (v_rec & {2}) == 4) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_008());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, array as a set-of value index on left hand side (dimensions match)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_032 {

	type component GeneralComp {	    	    
	}
 
	type set of set of integer SoSoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_032() runs on GeneralComp {

		var SoSoI v_set := {{0, 1}, {2, 3}};
        var integer v_index[2] := { 1, 0 }
        v_set[v_index] := 10;
		if (v_set == {{0, 1}, {10, 3}}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_032());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify the first element of a set of value is accessible by an index notation
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The index of the first element shall be zero.
module Sem_060203_records_and_sets_of_single_types_017 {

	type component GeneralComp {	    	    
	}
 
	type set of integer SoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_017() runs on GeneralComp {

		var SoI v_set := { 0, 1, 2 };
		v_set[0] := 10; // first index on the left hand side
		v_set[1] := v_set[0]; // first index on the right hand side
		if (v_set == { 10, 10, 2} ) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_017());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, array as a set-of value index on right hand side (dimensions match)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_031 {

	type component GeneralComp {	    	    
	}
 
	type set of set of integer SoSoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_031() runs on GeneralComp {

		var SoSoI v_set := {{0, 1}, {2, 3}};
        var integer v_index[2] := { 1, 0 }
		if (v_set[v_index] == 2) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_031());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, fixed-size record-of as a record-of value index on right hand side (less items than record-of dimension)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_029 {

	type component GeneralComp {	    	    
	}
 
    type record length(2) of integer Indexer;
	type record of record of record of integer RoRoRoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_029() runs on GeneralComp {

		var RoRoRoI v_rec := {{{0, 1}, {2, 3}}, {{4, 5, 6}, {7, 8}}};
        var Indexer v_index := { 1, 0 }
		if (v_rec[v_index] == {4, 5, 6}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_029());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify handling of index notation applied to record of values on right-hand side
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Indexed value notations can be used on the right-hand side of assignments. 
// The index notation, when used on the right hand side, refers to the value of 
// the identified element of a record of. 
module Sem_060203_records_and_sets_of_single_types_012 {

	type component GeneralComp {	    	    
	}
 
	type record of integer RoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_012() runs on GeneralComp {

		var RoI v_rec := { 0, 1, 2 };
		var integer i := v_rec[1];
		if (i == 1 ) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_012());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify handling of missing and ignored elements during record of value re-assignment
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When re-assigning a previously initialized value, using the not used symbol 
// or just skipping a field or element in an assignment notation, will cause 
// that field or element to remain unchanged.
module Sem_060203_records_and_sets_of_single_types_007 {

	type component GeneralComp {	    	    
	}
 
	type set of integer SoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_007() runs on GeneralComp {

		var SoI v_set := { 
			[0] := 0,
			[1] := -,
			[2] := 2
		};
		v_set := { 
			[1] := 1
		};
		if (v_set == { 0, 1, 2 }) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_007());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3, referencing element of uninitialized record of value (left-hand side)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// If an indexing operator at the left-hand side of an assignment refers to 
// a non-existent element, the value at the right-hand side is assigned to 
// the element and all elements with an index smaller than the actual index 
// and without assigned value are created with an undefined value.
module Sem_060203_records_and_sets_of_single_types_021 {

	type component GeneralComp {	    	    
	}
 
	type record of integer RoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_021() runs on GeneralComp {

		var RoI v_rec;
		v_rec[2] := 2; // {-, -, 2}
		if (not isbound(v_rec[0]) and
			not isbound(v_rec[1]) and
			match(v_rec[2], 2)) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_021());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify assignment of explicitly identified elements to set of values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When the assignment notation is used for set of s, elements 
// wished to be changed are identified explicitly and either a value 
// or the not used symbol "-" can be assigned to them...
// At initialization, only the elements to be assigned values shall be 
// specified... It is also possible to leave fields explicitly unspecified 
// using the not used symbol "-". 
module Sem_060203_records_and_sets_of_single_types_003 {

	type component GeneralComp {	    	    
	}

	type set of integer SoI;
 
	testcase TC_Sem_060203_records_and_sets_of_single_types_003() runs on GeneralComp {

		var SoI v_set := { 
			[0] := 0,
			[1] := 1,
			[2] := - 
		};
 
		if (match(v_set[0], 0) and match(v_set[1], 1) and not isbound(v_set[2])
			and lengthof (v_set & {2}) == 4) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}

	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_003());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, fixed-size record-of as a record-of value index on right hand side (dimensions match)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_027 {

	type component GeneralComp {	    	    
	}
 
    type record length(2) of integer Indexer;
	type record of record of integer RoRoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_027() runs on GeneralComp {

		var RoRoI v_rec := {{0, 1}, {2, 3}};
        var Indexer v_index := { 1, 0 }
		if (v_rec[v_index] == 2) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_027());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify handling of index notation applied to set of values on left-hand side
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Indexed value notations can be used on the left-hand side of assignments. 
// When it is used at the left hand side, only the value of the identified 
// single element is changed, values assigned to other elements already remain 
// unchanged.
module Sem_060203_records_and_sets_of_single_types_015 {

	type component GeneralComp {	    	    
	}
 
	type set of integer SoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_015() runs on GeneralComp {

		var SoI v_set := { 0, 1, 2 };
		v_set[1] := 10;
		if (v_set == { 0, 10, 2} ) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_015());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, array as a set-of value index on right hand side (less items than record-of dimension)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_033 {

	type component GeneralComp {	    	    
	}
 
	type set of set of set of integer SoSoSoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_033() runs on GeneralComp {

		var SoSoSoI v_set := {{{0, 1}, {2, 3}}, {{4, 5, 6}, {7, 8}}};
        var integer v_index[2] := { 1, 0 }
		if (v_set[v_index] == {4, 5, 6}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_033());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify handling of missing elements in assignment notation for set of values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When the assignment notation is used for record of s, ...
// fields, not referred to in the notation, shall remain unchanged.... 
// At initialization ... elements not mentioned are implicitly left 
// uninitialized. 
module Sem_060203_records_and_sets_of_single_types_005 {

	type component GeneralComp {	    	    
	}

	type set of integer SoI;
 
	testcase TC_Sem_060203_records_and_sets_of_single_types_005() runs on GeneralComp {

		var SoI v_set := { 
			[1] := 1
		};
 
		if (not isbound(v_set[0]) and match(v_set[1], 1)) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
		
	}
		
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_005());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, fixed-size set-of as a record-of value index on left hand side (dimensions match)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_036 {

	type component GeneralComp {	    	    
	}
 
    type record length(2) of integer Indexer;
	type set of set of integer SoSoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_036() runs on GeneralComp {

		var SoSoI v_set := {{0, 1}, {2, 3}};
        var Indexer v_index := { 1, 0 }
        v_set[v_index] := 10;
		if (v_set == {{0, 1}, {10, 3}}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_036());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify handling of index notation applied to record of values on left-hand side
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Indexed value notations can be used on the left-hand side of assignments. 
// When it is used at the left hand side, only the value of the identified 
// single element is changed, values assigned to other elements already remain 
// unchanged.
module Sem_060203_records_and_sets_of_single_types_014 {

	type component GeneralComp {	    	    
	}
 
	type record of integer RoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_014() runs on GeneralComp {

		var RoI v_rec := { 0, 1, 2 };
		v_rec[1] := 10;
		if (v_rec == { 0, 10, 2} ) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_014());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify the first element of a record of value is accessible by an index notation
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The index of the first element shall be zero.
module Sem_060203_records_and_sets_of_single_types_016 {

	type component GeneralComp {	    	    
	}
 
	type record of integer RoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_016() runs on GeneralComp {

		var RoI v_rec := { 0, 1, 2 };
		v_rec[0] := 10; // first index on the left hand side
		v_rec[1] := v_rec[0]; // first index on the right hand side
		if (v_rec == { 10, 10, 2} ) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_016());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, referencing non-existent element of record of value (left-hand side)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// If an indexing operator at the left-hand side of an assignment refers to 
// a non-existent element, the value at the right-hand side is assigned to 
// the element and all elements with an index smaller than the actual index 
// and without assigned value are created with an undefined value.
module Sem_060203_records_and_sets_of_single_types_019 {

	type component GeneralComp {	    	    
	}
 
	type record of integer RoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_019() runs on GeneralComp {

		var RoI v_rec := { 0, 1 };
		v_rec[3] := 3; // {0, 1, -, 3}
		if (match(v_rec[0], 0) and
			match(v_rec[1], 1) and
			not isbound(v_rec[2]) and
			match(v_rec[3], 3)) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_019());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify assignment of explicitly identified elements to record of values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When the assignment notation is used for record of s, elements 
// wished to be changed are identified explicitly and either a value 
// or the not used symbol "-" can be assigned to them... 
// At initialization, only the elements to be assigned values shall be 
// specified... It is also possible to leave fields explicitly unspecified 
// using the not used symbol "-". 
module Sem_060203_records_and_sets_of_single_types_002 {

	type component GeneralComp {	    	    
	}

	type record of integer RoI;
 
	testcase TC_Sem_060203_records_and_sets_of_single_types_002() runs on GeneralComp {

		var RoI v_rec := { 
			[0] := 0,
			[1] := 1,
			[2] := - 
		};
 
		if (match(v_rec[0], 0) and match(v_rec[1], 1) and not isbound(v_rec[2])
			and lengthof (v_rec & {2}) == 4) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}

	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_002());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, fixed-size record-of as a record-of value index on left hand side (dimensions match)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_028 {

	type component GeneralComp {	    	    
	}
 
    type record length(2) of integer Indexer;
	type record of record of integer RoRoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_028() runs on GeneralComp {

		var RoRoI v_rec := {{0, 1}, {2, 3}};
        var Indexer v_index := { 1, 0 }
        v_rec[v_index] := 10;
		if (v_rec == {{0, 1}, {10, 3}}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_028());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, fixed-size set-of as a record-of value index on right hand side (dimensions match)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_035 {

	type component GeneralComp {	    	    
	}
 
    type record length(2) of integer Indexer;
	type set of set of integer SoSoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_035() runs on GeneralComp {

		var SoSoI v_set := {{0, 1}, {2, 3}};
        var Indexer v_index := { 1, 0 }
		if (v_set[v_index] == 2) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_035());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify handling of missing elements in assignment notation for record of values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When the assignment notation is used for record of s, ...
// fields, not referred to in the notation, shall remain unchanged.... 
// At initialization ... elements not mentioned are implicitly left 
// uninitialized. 
module Sem_060203_records_and_sets_of_single_types_004 {

	type component GeneralComp {	    	    
	}

	type record of integer RoI;
 
	testcase TC_Sem_060203_records_and_sets_of_single_types_004() runs on GeneralComp {

		var RoI v_rec := { 
			[1] := 1
		};

		if (not isbound(v_rec[0]) and match(v_rec[1], 1)) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}

	}

	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_004());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify handling of value list assignment used for initialization of set of values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When using the value list notation, all elements in the structure shall 
// be specified either with a value or the not used symbol "-". The first 
// member of the list is assigned to the first element, the second list 
// member is assigned to the second element, etc.
module Sem_060203_records_and_sets_of_single_types_009 {

	type component GeneralComp {	    	    
	}
 
	type record of integer SoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_009() runs on GeneralComp {

		var SoI v_set := { 0, 1, - }; 
		if (match(v_set[0], 0) and match(v_set[1], 1) and not isbound(v_set[2])
			and lengthof (v_set & {2}) == 4) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_009());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify handling of index notation applied to set of values on right-hand side
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Indexed value notations can be used on the right-hand side of assignments. 
// The index notation, when used on the right hand side, refers to the value of 
// the identified element of a record of. 
module Sem_060203_records_and_sets_of_single_types_013 {

	type component GeneralComp {	    	    
	}
 
	type set of integer SoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_013() runs on GeneralComp {

		var SoI v_set := { 0, 1, 2 };
		var integer i := v_set[1];
		if (i == 1 ) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_013());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify handling of value list assignment used for update of record of values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Elements to be left out of the assignment shall be explicitly skipped in the list 
// by use of the not-used-symbol "-". Already initialized elements left without 
// a corresponding list member in a value list notation (i.e. at the end of a list) 
// are becoming uninitialized. In this way, a value with initialized elements can be 
// made empty by using the empty value list notation ("{}").
module Sem_060203_records_and_sets_of_single_types_010 {

	type component GeneralComp {	    	    
	}
 
	type record of integer RoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_010() runs on GeneralComp {

		var RoI v_rec := { 0, 1, 2 }; 
		v_rec := { 10, - };
		if (v_rec == { 10, 1 } ) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
		v_rec := {};
		if (lengthof(v_rec) == 0 ) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_010());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3, referencing non-existent element of set of value (left-hand side)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// If an indexing operator at the left-hand side of an assignment refers to 
// a non-existent element, the value at the right-hand side is assigned to 
// the element and all elements with an index smaller than the actual index 
// and without assigned value are created with an undefined value.
module Sem_060203_records_and_sets_of_single_types_020 {

	type component GeneralComp {	    	    
	}
 
	type set of integer SoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_020() runs on GeneralComp {

		var SoI v_set := { 0, 1 };
		v_set[3] := 3; // {0, 1, -, 3}
		if (match(v_set[0], 0) and
			match(v_set[1], 1) and
			not isbound(v_set[2]) and
			match(v_set[3], 3)) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_020());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, array as a record-of value index on right hand side (less items than record-of dimension)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_025 {

	type component GeneralComp {	    	    
	}
 
	type record of record of record of integer RoRoRoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_025() runs on GeneralComp {

		var RoRoRoI v_rec := {{{0, 1}, {2, 3}}, {{4, 5, 6}, {7, 8}}};
        var integer v_index[2] := { 1, 0 }
		if (v_rec[v_index] == {4, 5, 6}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_025());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, fixed-size record-of as a set-of value index on left hand side (less items than record-of dimension)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_038 {

	type component GeneralComp {	    	    
	}
 
    type record length(2) of integer Indexer;
	type set of set of set of integer SoSoSoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_038() runs on GeneralComp {

		var SoSoSoI v_set := {{{0, 1}, {2, 3}}, {{4, 5, 6}, {7, 8}}};
        var Indexer v_index := { 1, 0 }
        v_set[v_index] := { 100, - };
		if (v_set == {{{0, 1}, {2, 3}}, {{100, 5}, {7, 8}}}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_038());
	}

}
/***************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, ensure that the inner type referencing is correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060203_records_and_sets_of_single_types_001 {

 type component GeneralComp {	    	    
 }

 type record length (5) of record of integer ConstrainedStructure (1 .. 10);
 type ConstrainedStructure[-] RecordOfInt; //references the inner record of integer(1..10)
 
testcase TC_Sem_060203_records_and_sets_of_single_types_001() runs on GeneralComp {

 var RecordOfInt v_rec := { 8, 1, 2, 3, 4, 5, 6, 7, 9 };  // any record length is allowed
 
      if (v_rec[7]==7) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060203_records_and_sets_of_single_types_001());
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, array as a record-of value index on left hand side (less items than record-of dimension)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_026 {

	type component GeneralComp {	    	    
	}
 
	type record of record of record of integer RoRoRoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_026() runs on GeneralComp {

		var RoRoRoI v_rec := {{{0, 1}, {2, 3}}, {{4, 5, 6}, {7, 8}}};
        var integer v_index[2] := { 1, 0 }
        v_rec[v_index] := { 100, - };
		if (v_rec == {{{0, 1}, {2, 3}}, {{100, 5}, {7, 8}}}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_026());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, fixed-size record-of as a record-of value index on left hand side (less items than record-of dimension)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_030 {

	type component GeneralComp {	    	    
	}
 
    type record length(2) of integer Indexer;
	type record of record of record of integer RoRoRoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_030() runs on GeneralComp {

		var RoRoRoI v_rec := {{{0, 1}, {2, 3}}, {{4, 5, 6}, {7, 8}}};
        var Indexer v_index := { 1, 0 }
        v_rec[v_index] := { 100, - };
		if (v_rec == {{{0, 1}, {2, 3}}, {{100, 5}, {7, 8}}}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_030());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.3, array as a record-of value index on left hand side (dimensions match)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For nested record of or set of types, an array or record of integer restricted 
// to a single size can be used as a short-hand notation for a nested index
// notation.

module Sem_060203_records_and_sets_of_single_types_024 {

	type component GeneralComp {	    	    
	}
 
	type record of record of integer RoRoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_024() runs on GeneralComp {

		var RoRoI v_rec := {{0, 1}, {2, 3}};
        var integer v_index[2] := { 1, 0 }
        v_rec[v_index] := 10;
		if (v_rec == {{0, 1}, {10, 3}}) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_024());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify handling of missing and ignored elements during record of value re-assignment
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When re-assigning a previously initialized value, using the not used symbol 
// or just skipping a field or element in an assignment notation, will cause 
// that field or element to remain unchanged.
module Sem_060203_records_and_sets_of_single_types_006 {

	type component GeneralComp {	    	    
	}
 
	type record of integer RoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_006() runs on GeneralComp {

		var RoI v_rec := { 
			[0] := 0,
			[1] := -,
			[2] := 2
		};
		v_rec := { 
			[1] := 1
		};
      if (v_rec == { 0, 1, 2 }) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060203_records_and_sets_of_single_types_006());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3, referencing element of uninitialized set of value (left-hand side)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// If an indexing operator at the left-hand side of an assignment refers to 
// a non-existent element, the value at the right-hand side is assigned to 
// the element and all elements with an index smaller than the actual index 
// and without assigned value are created with an undefined value.
module Sem_060203_records_and_sets_of_single_types_022 {

	type component GeneralComp {	    	    
	}
 
	type set of integer SoI;
	
	testcase TC_Sem_060203_records_and_sets_of_single_types_022() runs on GeneralComp {

		var SoI v_set;
		v_set[2] := 2; // {-, -, 2}
		if (not isbound(v_set[0]) and
			not isbound(v_set[1]) and
			match(v_set[2], 2)) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060203_records_and_sets_of_single_types_022());
	}

}
/***************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:6.2.13.2, ensure that list subtyping check for record types is properly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06021302_ListSubtyping_003 {

 type component GeneralComp {	    	    
 }

 type record MyRecord {
  integer f1 optional,
  charstring f2,
  charstring f3
 }
 
 type MyRecord MyRecordSub1 (
  { f1 := *, f2 := "user", f3 := pattern "password|Password" },
  { f1 := (1 .. 10), f2 := "User", f3 := ? }
  ); // a valid subtype 
  
 
testcase TC_Sem_06021302_ListSubtyping_003() runs on GeneralComp {
 var MyRecordSub1 v_record := { f1 := omit, f2 := "user", f3 := "Password" };
 var template MyRecordSub1 m_match := { *, "user", "Password" };
 
      if ( match(v_record,m_match) ) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_06021302_ListSubtyping_003());
}

}
/***************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:6.2.13.2, ensure that list subtyping check for record types is properly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06021302_ListSubtyping_002 {

 type component GeneralComp {	    	    
 }

 type record MyRecord {
  integer f1 optional,
  charstring f2,
  charstring f3
 }
 
 type MyRecord MyRecordSub1 (
  { f1 := *, f2 := "user", f3 := "password" },
  { f1 := *, f2 := "User", f3 := "Password" }
  ); // a valid subtype, f1 may contain any values
  
 
testcase TC_Sem_06021302_ListSubtyping_002() runs on GeneralComp {
 var MyRecordSub1 v_record := { f1 := 8, f2 := "User", f3 := "Password" };
 
      if ( match(v_record,{ 8, "User", "Password" }) ) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_06021302_ListSubtyping_002());
}

}
/***************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:6.2.13.2, ensure that list subtyping check for record types is properly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06021302_ListSubtyping_001 {

 type component GeneralComp {	    	    
 }

 type record MyRecord {
  integer f1 optional,
  charstring f2,
  charstring f3
 }
 
 type MyRecord MyRecordSub1 (
  { f1 := omit, f2 := "user", f3 := "password" },
  { f1 := 1, f2 := "User", f3 := "Password" }
  ); // a valid subtype of MyRecord containing 2 values
  
 
testcase TC_Sem_06021302_ListSubtyping_001() runs on GeneralComp {
 var MyRecordSub1 v_record := { f1 := 1, f2 := "User", f3 := "Password" };
 
      if ( match(v_record,{ 1, "User", "Password" }) ) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_06021302_ListSubtyping_001());
}

}
/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.2.13.1, The length subtyping check for 'record of' or 'set of' types
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_06021301_LengthSubtyping_001 {
   type record length(10) of integer RecordOfLength10;					//direct subtyping
   type record length(0..10) of integer RecordOfLengthLessThan10;		//direct subtyping

   type RecordOfLengthLessThan10 RecordOfLength6 length(6);				//referenced subtyping
   type RecordOfLengthLessThan10 RecordOfLength4To5 length(4..5);		//referenced subtyping

}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.2.13.1, The length subtyping check for 'record of' or 'set of' types
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_06021301_LengthSubtyping_002 {
   type set length(10) of integer SetOfLength10;					//direct subtyping
   type set length(0..10) of integer SetOfLengthLessThan10;		//direct subtyping

   type SetOfLengthLessThan10 SetOfLength6 length(6);				//referenced subtyping
   type SetOfLengthLessThan10 SetOfLength4To5 length(4..5);		//referenced subtyping

}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.2.12, Ensure that the right port address is used
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060212_AddressingEntitiesInsideSut_002 {
    type integer address;

    type port PortType1 message {
        address charstring;
        inout all;
    }

    type port PortType2 message {
        inout all;
    }
	
    type component TestCaseComp {
        port PortType1 p1;
        port PortType2 p2;
    }
	
    testcase TC_Sem_060212_AddressingEntitiesInsideSut_002() runs on TestCaseComp system TestCaseComp {
		
        var address v_int := 1;
        var PortType1.address v_char := "test";
        
        map(mtc:p1, system:p1);
        map(mtc:p2, system:p2);
        
        // port 1 has charstring address
        p1.send(5) to v_char;

		// port 2 has integer address
        p2.send(5) to v_int;
        p2.send(5) to 5;
        
        setverdict(pass);
    }

    control {
        execute(TC_Sem_060212_AddressingEntitiesInsideSut_002());
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.2.12, Ensure null assignment is accepted for addresses
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060212_AddressingEntitiesInsideSut_001 {
    type integer address;
	
    type component TestCaseComp {
    }
	
    testcase TC_Sem_060212_AddressingEntitiesInsideSut_001() runs on TestCaseComp system TestCaseComp {
		
        var address v_int := null; // valid value for an address
        
        setverdict(pass);
    }

    control {
        execute(TC_Sem_060212_AddressingEntitiesInsideSut_001());
    }
}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.9, Ensure that procedure-base port type definition can contain unmap parameter definition
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_060209_CommunicationPortTypes_009 {

	signature S1();
	
	type record MyType {
	    integer f1
	}

    type port MyMessagePortTypeOne procedure {
        inout S1;
        unmap param (in MyType p1, out integer p2);
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.2.9, Ensure that message-based ports with address are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_060209_CommunicationPortTypes_002 {

    type port MyMessagePortTypeTwo message {
        // if addressing is used on ports of type MyMessagePortTypeTwo
        // the addresses have to be of type integer
        address integer;
        inout integer;
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.2.9, Ensure that message-based ports are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_060209_CommunicationPortTypes_001 {

    type record MsgType1 {
        integer f1,
        octetstring f2
    }

	type boolean MsgType2;

	type charstring MsgType3;

    // Message-based port which allows types MsgType1 and MsgType2 to be received at, MsgType3 to be
    // sent via and any integer value to be send and received over the port
    type port MyMessagePortTypeOne message {
        in MsgType1, MsgType2;
        out MsgType3;
        inout integer
    }

}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.9, Verify that it is possible to define procedute-based port types
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_060209_CommunicationPortTypes_003 {

    signature S1();
	signature S2(in integer p_par1);
	signature S3(in charstring p_par1);
	signature S4(in integer p_par1) return bitstring;
	signature S5(in charstring p_par1, out charstring p_par2) return boolean;

    // Procedure-based port which allows to accept calls to procedures S1, S2 and S4, call
	// procedure S3. S5 calls can be both accepted or dispatched.
    type port MyMessagePortTypeOne procedure {
        in S1, S2;
        out S3;
		in S4;
        inout S5;
    }

}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.9, Ensure that complex procedure-based port type definition are accepted
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_060209_CommunicationPortTypes_010 {

    type record MyType1 {
        integer f1,
        charstring f2
    }

	type record MyType2 {
	    integer g1,
	    charstring g2
	}

	type record MyType3 {
	    boolean h1,
        MyType3 h2 optional
	}
	
	signature S1();
	signature S2(in integer p_par1);
	signature S3(in charstring p_par1);

    type port MyMessagePortTypeOne procedure {
        inout S1, S2, S3;
        map param (in integer p1, inout MyType2 p2);
        unmap param (in MyType3 p1, out integer p2);
        address MyType1;
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.2.9, Ensure that map param is accepted by the port definition.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_060209_CommunicationPortTypes_005 {

	type record MyType {
	    integer f1
	}

    type port MyMessagePortTypeOne message {
        inout integer;
        map param (in MyType p1, out integer p2);
    }

}/*****************************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.9, Ensure that procedure-based ports with address are accepted
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_060209_CommunicationPortTypes_004 {
	
	signature S1();
	
    type port MyMessagePortType procedure {
        inout S1;
        // if addressing is used on ports of type MyMessagePortType
        // the addresses have to be of type integer
        address integer;
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.2.9, Ensure that procedure-base port type definition can contain map parameter definition
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_060209_CommunicationPortTypes_008 {

	signature S1();
	
	type record MyType {
	    integer f1
	}

    type port MyMessagePortTypeOne procedure {
        inout S1;
        map param (in MyType p1, out integer p2);
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.2.9, Ensure that complex port definition are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_060209_CommunicationPortTypes_007 {

    type record MyType1 {
        integer f1,
        charstring f2
    }

	type record MyType2 {
	    integer g1,
	    charstring g2
	}

	type record MyType3 {
	    boolean h1,
        MyType3 h2 optional
	}

    type port MyMessagePortTypeOne message {
        address MyType1;
        inout integer, charstring;
        map param (in integer p1, inout MyType2 p2);
        unmap param (in MyType3 p1, out integer p2);
    }

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.2.9, Ensure that unmap param is accepted by the port definition.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_060209_CommunicationPortTypes_006 {

	type record MyType {
	    integer f1
	}

    type port MyMessagePortTypeOne message {
        inout integer;
        unmap param (in MyType p1, out integer p2);
    }

}/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:6.2.9, Ensure that map and unmap param and local port address are allowed in a testcase block
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_060209_CommunicationPortTypes_004 {

    type component GeneralComp {
        port MyMessagePortType pt_myPort;
    }

    type record MyMessageType1 {
        integer field1,
        charstring field2,
        boolean field3
    }

    type record MyMessageType2 {
        integer g1,
        charstring g2
    }

    type record MyMessageType3 {
        boolean h1,
        MyMessageType3 h2 optional
    }

    type port MyMessagePortType message {
        address MyMessageType1;
        inout all;
        map param (in integer p1, inout charstring p2);
        unmap param (in MyMessageType3 p1, inout MyMessageType2 p2);
    }

    const MyMessageType1 c_myTemplate1 := {
        field1 := 2,
        field2 := "foobar",
        field3 := true
    }

    const MyMessageType2 c_myTemplate2 := {
        g1 := 2,
        g2 := "foo"
    }

    const MyMessageType3 c_myTemplate3 := {
        h1 := false,
        h2 := {
            h1:= true,
            h2 := omit
        }
    }

    testcase TC_Sem_060209_CommunicationPortTypes_004() runs on GeneralComp system GeneralComp {
        var charstring v_varString := "foobar";
        var MyMessageType2 v_myTemplate2 := c_myTemplate2;

        map(mtc:pt_myPort, system:pt_myPort) param(5, v_varString);
        
        pt_myPort.send(13) to c_myTemplate1;
        log("Map inout parameter", v_varString);
        
        unmap(mtc:pt_myPort, system:pt_myPort) param(c_myTemplate3, v_myTemplate2);
        log("Unmap inout parameter", v_myTemplate2);

        setverdict(pass);
    }

    control{
        execute(TC_Sem_060209_CommunicationPortTypes_004());
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.9, Ensure that parameter MessageType of the port shall be data type
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

/* The following requirements are tested:
 * 6.2.9 Communication port types - Restriction e. MessageType shall be a data type as defined in clause 3.1.
 */

module Sem_060209_CommunicationPortTypes_005 {

    type component GeneralComp {
        port loopbackPort pt_myPort;
    }
    
   type record MyRec{float field1};
   type set MySet{};
   type record of integer MyRoI;
   type set of integer MySoI; 
   type enumerated MyEnumType {a,b,c};
   type union MyUnionType 
	{	
		integer 		number,
		charstring 		string
	};

    type port loopbackPort message {
        //allowed MessageTypes given in clause 3.1:
        inout integer;
        inout float;
        inout boolean;
        inout verdicttype;
        inout bitstring;
        inout octetstring;
        inout hexstring;
        inout charstring;
        inout universal charstring;
        inout anytype;
        inout MyRec;
        inout MyRoI;
        inout MySet;
        inout MySoI;
        inout MyEnumType;
        inout MyUnionType;
    }


    testcase TC_Sem_060209_CommunicationPortTypes_005() runs on GeneralComp {
   
      var anytype v_a;
      var integer j := 10;
      var boolean       v_2 := true;
      var verdicttype   v_3 := pass;
      var universal charstring    v_4 := "\q{0,0,1,113}";
      var MyRec MyR :={field1 := 1.0};
      var MySet MyS :={};
      var MyRoI RoI := {1,2,3};
      var MySoI SoI := {1,2,3};
      var MyEnumType enu :=a;
      var MyUnionType uni :={number:=1};
      v_a.integer :=1;
        
//send integer via port 
    pt_myPort.send(j); 
    alt {
     [] pt_myPort.receive(j) {
        setverdict(pass,"Send success, received:", j);
     }
     [] pt_myPort.receive {
        setverdict(fail,"integer sent failed",j);
     }
    }
//send float via port   
        pt_myPort.send(int2float(j)); 
            alt {
     [] pt_myPort.receive(int2float(j)) {
        setverdict(pass,"Send success,received:", int2float(j));
     }
     [] pt_myPort.receive {
        setverdict(fail,"float sent failed", int2float(j));
     }
    }
//send character via port
      pt_myPort.send(int2char(j));   
               alt {
     [] pt_myPort.receive(int2char(j)) {
        setverdict(pass,"Send success,received:", int2char(j));
     }
     [] pt_myPort.receive {
        setverdict(fail,"character sent failed", int2char(j));
     }
    }
 //send bitstring via port   
        pt_myPort.send(int2bit(j,4));  
             alt {
     [] pt_myPort.receive(int2bit(j,4)) {
        setverdict(pass,"Send success,received:", int2bit(j,4));
     }
     [] pt_myPort.receive {
        setverdict(fail,"bitstring sent failed", int2bit(j,4));
     }
    }
//send octetstring via port  
        pt_myPort.send(int2oct(j,4));  
          alt {
     [] pt_myPort.receive(int2oct(j,4)) {
        setverdict(pass,"Send success,received:", int2oct(j,4));
     }
     [] pt_myPort.receive {
        setverdict(fail,"octetstring sent failed", int2oct(j,4));
     }
    }
//send hexstring via port
      pt_myPort.send(int2hex(j,4));   
         alt {
     [] pt_myPort.receive(int2hex(j,4)) {
        setverdict(pass,"Send success,received:",int2hex(j,4));
     }
     [] pt_myPort.receive {
        setverdict(fail,"octetstring sent failed",int2hex(j,4));
     }
    }
//send charstring via port
      pt_myPort.send(int2str(j));     
          alt {
     [] pt_myPort.receive(int2str(j)) {
        setverdict(pass,"Send success,received:",int2str(j));
     }
     [] pt_myPort.receive {
        setverdict(fail,"charstring sent failed",int2str(j));
     }
    }
//send boolean via port
      pt_myPort.send(v_2);          
                      alt {
     [] pt_myPort.receive(v_2) {
        setverdict(pass,"Send success,received:",v_2);
     }
     [] pt_myPort.receive {
        setverdict(fail,"charstring sent failed", v_2);
     }
    }
//send verdicttype via port
      pt_myPort.send(v_3);   
                              alt {
     [] pt_myPort.receive(v_3) {
        setverdict(pass,"Send success,received:",v_3);
     }
     [] pt_myPort.receive {
        setverdict(fail,"verdict type sent failed", v_3);
     }
    }
//send universal charstring via port        
      pt_myPort.send(v_4);            
       alt {
     [] pt_myPort.receive(v_4) {
        setverdict(pass,"Send success,received:",v_4);
     }
     [] pt_myPort.receive {
        setverdict(fail,"universal charstring sent failed", v_4);
     }
    }
//send anytype via port
      pt_myPort.send(v_a.integer);    
        alt {
     [] pt_myPort.receive(v_a.integer) {
        setverdict(pass,"Send success,received:",v_a.integer);
     }
     [] pt_myPort.receive {
        setverdict(fail,"anytype sent failed", v_a.integer);
     }
    }
//send record via port
      pt_myPort.send(MyR);            
        alt {
     [] pt_myPort.receive(MyR) {
        setverdict(pass,"Send success,received:",MyR);
     }
     [] pt_myPort.receive {
        setverdict(fail,"Record sent failed", MyR);
     }
    }
//send set via port      
              pt_myPort.send(MyS);            
        alt {
     [] pt_myPort.receive(MyS) {
        setverdict(pass,"Send success,received:",MyS);
     }
     [] pt_myPort.receive {
        setverdict(fail,"Set sent failed", MyS);
     }
    }
//send record of integers via port     
      pt_myPort.send(RoI);           
        alt {
     [] pt_myPort.receive(RoI) {
        setverdict(pass,"Send success,received:",RoI);
     }
     [] pt_myPort.receive {
        setverdict(fail,"Record of integers sent failed", RoI);
     }
    }
//send set of integers via port
      pt_myPort.send(SoI);           
        alt {
     [] pt_myPort.receive(SoI) {
        setverdict(pass,"Send success,received:",SoI);
     }
     [] pt_myPort.receive {
        setverdict(fail,"Record of integers sent failed", SoI);
     }
    }
//send enum via port
      pt_myPort.send(enu);           
       alt {
     [] pt_myPort.receive(enu) {
        setverdict(pass,"Send success,received:",enu);
     }
     [] pt_myPort.receive {
        setverdict(fail,"Enum sent failed", enu);
     }
    }
//send union via port
      pt_myPort.send(uni);           
                 alt {
     [] pt_myPort.receive(uni) {
        setverdict(pass,"Send success,received:",uni);
     }
     [] pt_myPort.receive {
        setverdict(fail,"Union sent failed", uni);
     }
    }
            
  }

    control{
        execute(TC_Sem_060209_CommunicationPortTypes_005());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.2, The dot notation used in set type definitions is correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060202_SetTypeValues_003 {

type component GeneralComp {	    	    
}

 type set S {
  integer field1 (1 .. 10),
  charstring field2 optional
 }  
 
 type S.field1 MyInteger;
 
testcase TC_Sem_060202_SetTypeValues_003() runs on GeneralComp {

 var MyInteger v_int := 9;  // v_int is allowed in (1 .. 10) range
 
      if (v_int==9) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060202_SetTypeValues_003());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.2, The dot notation used in set type definitions is correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060202_SetTypeValues_004 {

type component GeneralComp {
}

 type set S {
  integer field1 (1 .. 10),
  charstring field2 optional
 }  

 
 type S.field2 MyChar;
 
testcase TC_Sem_060202_SetTypeValues_004() runs on GeneralComp {

 var MyChar v_char := "abc";  // any character string is allowed
 
      if (v_char=="abc") {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060202_SetTypeValues_004());
}

}
/***************************************************
 ** @author   STF470 
 ** @version  0.0.1
 ** @desc     Test cases for clause 6.2                     
 ** @purpose  1:6.2, Ensure that assignments with "implicit omit" attribute are correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060202_SetTypeValues_006 {

type component GeneralComp {
}

 type set S {
  integer f1,
  integer f2 optional,
  integer f3,
  integer f4 optional,
  integer f5 optional
 }  

 const S c_assigned := { 1, -, 2 } with { optional "implicit omit" }
 
testcase TC_Sem_060202_SetTypeValues_006() runs on GeneralComp {

 template S m_check := { 1, omit, 2, omit, omit }
 
      if (match(c_assigned,m_check)) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060202_SetTypeValues_006());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.2, Ensure that the IUT correctly handles empty set definitions.
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_060202_SetTypeValues_002 {
    type set MySetType {
	}
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.2, The dot notation used in set type definitions is correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060202_SetTypeValues_002 {

type component GeneralComp {	    	    
}

 type set S {
  integer field1 (1 .. 10),
  charstring field2 optional
 }  
 
 type S ConstrainedSet ({1, omit}, {2, "xyz"}, {3, "zyx"});
 
 type ConstrainedSet.field2 MyChar;
 
testcase TC_Sem_060202_SetTypeValues_002() runs on GeneralComp {

 var MyChar v_char := "abc";  // any character string is allowed
 
      if (v_char=="abc") {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060202_SetTypeValues_002());
}

}
/***************************************************
 ** @author   STF470 
 ** @version  0.0.1
 ** @desc     Test cases for clause 6.2                     
 ** @purpose  1:6.2, Ensure that assignments with "implicit omit" attribute are correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060202_SetTypeValues_007 {

type component GeneralComp {	    	    
}

 type record S {
  integer f1,
  integer f2 optional,
  integer f3,
  integer f4 optional,
  integer f5 optional
 }  
 
testcase TC_Sem_060202_SetTypeValues_007() runs on GeneralComp {

 var S v_assigned := { 1, 2, 3 } with { optional "implicit omit" }
 
      if ( match(v_assigned.f1,1) 
           and match(v_assigned.f3,3) 
           and not ispresent(v_assigned.f4) 
           and not ispresent(v_assigned.f5) ) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060202_SetTypeValues_007());
}

}
/***************************************************
 ** @author   STF470
 ** @version  0.0.1
 ** @desc     Test cases for clause 6.2                     
 ** @purpose  1:6.2, Ensure that assignments with "implicit omit" attribute are correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060202_SetTypeValues_005  {

type component GeneralComp {
}

 type set S {
  integer f1,
  integer f2 optional,
  integer f3,
  integer f4 optional,
  integer f5 optional
 }  
 
testcase TC_Sem_060202_SetTypeValues_005() runs on GeneralComp {

 var S v_assigned := { 1, -, 2 } with { optional "implicit omit" }
 template S m_check := { 1, omit, 2, omit, omit }
 
      if (match(v_assigned,m_check)) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060202_SetTypeValues_005());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.2, The element identifiers are local to the set and shall be unique within the record (but do not have to be globally unique).
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_060202_SetTypeValues_001 {
    const integer field2 := 4; // do not edit the name
    
    type set MySetType {
		integer field1,
		MyOtherSetType field2 optional,
		charstring field3
	}
    type set MyOtherSetType {
    	bitstring field1,
    	boolean field2
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.2, The dot notation used in set type definitions is correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060202_SetTypeValues_001 {

type component GeneralComp {	    	    
}

 type set S {
  integer field1 (1 .. 10),
  charstring field2 optional
 }  
 
 type S ConstrainedSet ({1, omit}, {2, "xyz"}, {3, "zyx"}) ;
 
 type ConstrainedSet.field1 MyInteger;
 
testcase TC_Sem_060202_SetTypeValues_001() runs on GeneralComp {

 var MyInteger v_int := 9;  // v_int is allowed in (1 .. 10) range
 
      if (v_int==9) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060202_SetTypeValues_001());
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, fixed-size record of integer as multidimensional array index
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// An array or record of integer restricted to a single size can be used in the 
// index notation as a short-hand for the repeated index notation.

module Sem_060207_arrays_018 {

	type component GeneralComp {
	}
    
    type record length(2) of integer RI;
	
	testcase TC_Sem_060207_arrays_018() runs on GeneralComp {        
        var RI v_rhindexes := { 0, 1 }, v_lhindexes := { 1, 2 }
        var integer v_arr[2][3] := { { 1, 2, 3 }, { 4, 5, 6 } };
        // testing both RH and LH side:
        v_arr[v_lhindexes] := v_arr[v_rhindexes];        
        if (v_arr == { { 1, 2, 3 }, { 4, 5, 2} }) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {
		execute(TC_Sem_060207_arrays_018());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.7, referencing element of uninitialized array (left-hand side)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// All elements in an array value that are not set explicitly are undefined. When 
// referencing an element of an uninitialized array value or field or omitted field 
// on the left hand side of an assignment, the rules for record of values specified 
// in 6.2.3 apply.

module Sem_060207_arrays_012 {

	type component GeneralComp {
	}
 
    type integer MyArrayType1[3] (1 .. 10);
	
	testcase TC_Sem_060207_arrays_012() runs on GeneralComp {

        var MyArrayType1 v_array1;
        v_array1[2] := 2; // {-, -, 2}
        if (not isbound(v_array1[0]) and
            not isbound(v_array1[1]) and
            match(v_array1[2], 2)) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

	control {
		execute(TC_Sem_060207_arrays_012());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, index notation applied to omitted array field on left hand side of assignment
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// All elements in an array value that are not set explicitly are undefined. 
// When referencing an element of an uninitialized array value or field or 
// omitted field on the left hand side of an assignment, the rules for record 
// of values specified in 6.2.3 apply.

module Sem_060207_arrays_011 {

	type component GeneralComp {
	}
 
    type record R {
        integer field1[3] optional
    }
	
	testcase TC_Sem_060207_arrays_011() runs on GeneralComp {

        var R v_rec := { field1 := omit };
        v_rec.field1[2] := 3;
		
		if (not isbound(v_rec.field1[0]) and not isbound(v_rec.field1[1]) and
            v_rec.field1[2] == 3) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060207_arrays_011());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, integer array as multidimensional array index
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// An array or record of integer restricted to a single size can be used in the 
// index notation as a short-hand for the repeated index notation.

module Sem_060207_arrays_017 {

	type component GeneralComp {
	}
	
	testcase TC_Sem_060207_arrays_017() runs on GeneralComp {        
        var integer v_rhindexes[2] := { 0, 1 }, v_lhindexes[2] := { 1, 2 }
        var integer v_arr[2][3] := { { 1, 2, 3 }, { 4, 5, 6 } };
        // testing both RH and LH side:
        v_arr[v_lhindexes] := v_arr[v_rhindexes];        
        if (v_arr == { { 1, 2, 3 }, { 4, 5, 2} }) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {
		execute(TC_Sem_060207_arrays_017());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.4, verify handling of value list assignment used for update of arrays
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
 
// The following requirement is tested:
// When the value list notation is used, the first value of the list is assigned to 
// the first element of the array (the element with index 0 or the lower bound if 
// an index range has been given), the second value to the next element, etc.

module Sem_060207_arrays_006 {

	type component GeneralComp {
	}
 
    type integer MyArrayType1[3] (1 .. 10);
	
	testcase TC_Sem_060207_arrays_006() runs on GeneralComp {

        var MyArrayType1 v_array1 := {8, -, 2}
        v_array1 := {8, 1, 2};
		if (v_array1 == { 8, 1, 2} ) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060207_arrays_006());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.7, verify handling of missing elements in assignment notation for arrays
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For using the assignment notation for arrays, the rules described in 6.2.3 are 
// valid for arrays as well.

module Sem_060207_arrays_003 {

	type component GeneralComp {
	}

    type integer MyArrayType1[3] (1 .. 10);
 
	testcase TC_Sem_060207_arrays_003() runs on GeneralComp {

		var MyArrayType1 v_array1 := { 
			[1] := 1
		};

		if (not isbound(v_array1[0]) and match(v_array1[1], 1)) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}

	}

	control {
		execute(TC_Sem_060207_arrays_003());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, using less indexes than array dimensions on the right hand side of assignments
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The use of array slices of multi-dimensional arrays, i.e. when the number of 
// indexes of the array value is less than the number of dimensions in the 
// corresponding array definition, is allowed. Indexes of array slices shall 
// correspond to the dimensions of the array definition from left to right (i.e. 
// the first index of the slice corresponds to the first dimension of the definition). 
// Slice indexes shall conform to the related array definition dimensions.

module Sem_060207_arrays_022 {

	type component GeneralComp {
	}
	
	testcase TC_Sem_060207_arrays_022() runs on GeneralComp {        
        var integer v_arr[2][2][3] := { { { 1, 2, 3 }, { 4, 5, 6 } },  { { 7, 8, 9 }, { 10, 11, 12 } } };
        if (v_arr[0][1] == { 4, 5, 6 }) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {
		execute(TC_Sem_060207_arrays_022());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, using less indexes than array dimensions on the left hand side of assignments
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The use of array slices of multi-dimensional arrays, i.e. when the number of 
// indexes of the array value is less than the number of dimensions in the 
// corresponding array definition, is allowed. Indexes of array slices shall 
// correspond to the dimensions of the array definition from left to right (i.e. 
// the first index of the slice corresponds to the first dimension of the definition). 
// Slice indexes shall conform to the related array definition dimensions.

module Sem_060207_arrays_023 {

	type component GeneralComp {
	}
	
	testcase TC_Sem_060207_arrays_023() runs on GeneralComp {        
        var integer v_arr[2][2][3] := { { { 1, 2, 3 }, { 4, 5, 6 } },  { { 7, 8, 9 }, { 10, 11, 12 } } };
        v_arr[0][1] := { 400, 500, 600 };
        if (v_arr == { { { 1, 2, 3 }, { 400, 500, 600 } },  { { 7, 8, 9 }, { 10, 11, 12 } } }) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {
		execute(TC_Sem_060207_arrays_023());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.7, verify that value list notation can be used for an array
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060207_arrays_001 {

// The following requirement is tested:
// When the value list notation is used, the first value of the list is assigned to 
// the first element of the array (the element with index 0 or the lower bound if 
// an index range has been given), the second value to the next element, etc. 

 type component GeneralComp {
 }

 type integer MyArrayType1[3] (1 .. 10);
 
testcase TC_Sem_060207_arrays_001() runs on GeneralComp {

 var MyArrayType1 v_array1 := { 8, 1, 2 };
      if (v_array1[2]==2) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060207_arrays_001());
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, multidimensional array specified in variable declaration
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// Arrays may be declared as single or multi-dimensional. 

module Syn_060207_arrays_003 {

    const integer c_arr[2][3] := { { 0, 1, 2}, {3, 4, 5 }};
    modulepar integer PX_ARR[3][2][6];
    
	control {
		var integer v_arr[5][3], v_noarr, v_arr2[2][2][10];
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, multidimensional array type declaration
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// Arrays may be declared as single or multi-dimensional. 

module Syn_060207_arrays_002 {

    type integer MultiArray[3][4][2][5];

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.7, verify handling of index notation applied to array on right-hand side
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Indexed value notation can be used on both the right-hand side and left-hand side
// of assignments. The index of the first element shall be zero or the lower bound 
// if an index range has been given. 
 
module Sem_060207_arrays_007 {

	type component GeneralComp {
	}
 
    type integer MyArrayType1[3] (1 .. 10);
	
	testcase TC_Sem_060207_arrays_007() runs on GeneralComp {

        var MyArrayType1 v_array1 := {8, 1, 2}
		var integer i := v_array1[1];
		if (i == 1 ) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060207_arrays_007());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, array variable dimension specified as a range
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// Array dimensions may also be specified using ranges (with inclusive 
// boundaries only). In such cases, the lower and upper values of the range 
// define the lower and upper index values. Such an array is corresponding to 
// a record of with a fixed length restriction computed as the difference 
// between upper and lower index bound plus 1 and indexing starting from the 
// lower bound of the array definition.

module Syn_060207_arrays_006 {

    control {
        var integer v_arr[1..3];
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, using custom array index on the right hand side of assignments
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Indexed value notation can be used on both the right-hand side and left-hand 
// side of assignments. The index of the first element shall be zero or the lower 
// bound if an index range has been given.

module Sem_060207_arrays_020 {

	type component GeneralComp {
	}
	
	testcase TC_Sem_060207_arrays_020() runs on GeneralComp {        
        var integer v_arr[2..5] := { 2, 3, 4, 5 };
        if (v_arr[2] == 2) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {
		execute(TC_Sem_060207_arrays_020());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.7, verify handling of value list assignment used for initialization of arrays
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
 
// The following requirement is tested:
// Elements to be left out from the assignment shall be explicitly skipped in the 
// list by using dash.

module Sem_060207_arrays_005 {

	type component GeneralComp {
	}
 
    type integer MyArrayType1[3] (1 .. 10);
	
	testcase TC_Sem_060207_arrays_005() runs on GeneralComp {
        var MyArrayType1 v_array1 := {8, -, 2}
		if (match(v_array1[0], 8) and match(v_array1[2], 2) and not isbound(v_array1[1])
			and lengthof (v_array1 & {2}) == 4) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060207_arrays_005());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, multiple array type dimensions specified as a range
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// Array dimensions may also be specified using ranges (with inclusive 
// boundaries only). In such cases, the lower and upper values of the range 
// define the lower and upper index values. Such an array is corresponding to 
// a record of with a fixed length restriction computed as the difference 
// between upper and lower index bound plus 1 and indexing starting from the 
// lower bound of the array definition.

module Syn_060207_arrays_005 {

    type integer Arr[1..3][5][6 - 4 .. 2 * 3];

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, integer array as multidimensional array index (less items than dimension count)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// An array or record of integer restricted to a single size can be used in the 
// index notation as a short-hand for the repeated index notation.

module Sem_060207_arrays_019 {

	type component GeneralComp {
	}
	
	testcase TC_Sem_060207_arrays_019() runs on GeneralComp {        
        var integer v_rhindexes[2] := { 0, 1 }, v_lhindexes[2] := { 1, 0 }
        var integer v_arr[2][2][3] := { { { 1, 2, 3 }, { 4, 5, 6 } },  { { 7, 8, 9 }, { 10, 11, 12 } } };
        // testing both RH and LH side:
        v_arr[v_lhindexes] := v_arr[v_rhindexes];        
        if (v_arr == { { { 1, 2, 3 }, { 4, 5, 6 } },  { { 4, 5, 6 }, { 10, 11, 12 } } }) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {
		execute(TC_Sem_060207_arrays_019());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, constant expression in array dimension
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Array dimensions shall be specified using constant expressions, which shall 
// evaluate to a positive integer values. Constants used in the constant 
// expressions shall meet with the restrictions in clause 10.

module Sem_060207_arrays_015 {

	type component GeneralComp {
	}
	
	testcase TC_Sem_060207_arrays_015() runs on GeneralComp {        
        var integer v_arr[9 - 3 * 2] := { 0, 1, 2 };
		setverdict(pass);
	}
	
	control {
		execute(TC_Sem_060207_arrays_015());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, array type dimension specified as a range
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// Array dimensions may also be specified using ranges (with inclusive 
// boundaries only). In such cases, the lower and upper values of the range 
// define the lower and upper index values. Such an array is corresponding to 
// a record of with a fixed length restriction computed as the difference 
// between upper and lower index bound plus 1 and indexing starting from the 
// lower bound of the array definition.

module Syn_060207_arrays_004 {

    type integer Arr[1..5];

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.7, verify handling of index notation applied to array on left-hand side
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// Indexed value notation can be used on both the right-hand side and left-hand side
// of assignments. The index of the first element shall be zero or the lower bound 
// if an index range has been given. 
 
module Sem_060207_arrays_008 {

	type component GeneralComp {
	}
 
    type integer MyArrayType1[3] (1 .. 10);
	
	testcase TC_Sem_060207_arrays_008() runs on GeneralComp {

        var MyArrayType1 v_array1 := {8, 1, 2}
        v_array1[1] := 10;
		if (v_array1 == { 8, 10, 2} ) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060207_arrays_008());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, multiple array variable dimensions specified as a range
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// Array dimensions may also be specified using ranges (with inclusive 
// boundaries only). In such cases, the lower and upper values of the range 
// define the lower and upper index values. Such an array is corresponding to 
// a record of with a fixed length restriction computed as the difference 
// between upper and lower index bound plus 1 and indexing starting from the 
// lower bound of the array definition.

module Syn_060207_arrays_007 {

    control {
        var integer v_arr[1..3][2][6 - 4 .. 2 * 3];
    }
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.7, verify assignment of explicitly identified elements to two dimensional array
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When specifying values for multi-dimensional arrays, the leftmost dimension 
// corresponds to the outermost structure of the value, and the rightmost dimension to 
// the innermost structure. 
 
module Sem_060207_arrays_014 {

 type component GeneralComp {
 }

 
 type integer MyArrayType1[2][3] (1 .. 10);
 
 
testcase TC_Sem_060207_arrays_014() runs on GeneralComp {

  var MyArrayType1 v_array1;
  v_array1[0][0] := 8;
  v_array1[0][1] := 10;
  v_array1[0][2] := 9;
  v_array1[1][0] := 2;
  v_array1[1][1] := 3;
  v_array1[1][2] := -;

  if (match(v_array1[0][0], 8) and match(v_array1[1][0], 2) and not isbound(v_array1[1][2])
      and match(lengthof (v_array1), 2) and match(lengthof (v_array1[0]), 3)) 
  {
    setverdict(pass);
  }
  else {
    setverdict(fail);
  }

}

control {
    execute(TC_Sem_060207_arrays_014());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.7, verify handling of missing and ignored elements during an array re-assignment
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
 
// The following requirement is tested:
// Elements to be left out from the assignment shall be explicitly skipped in the 
// list by using dash.

module Sem_060207_arrays_004 {

	type component GeneralComp {
	}
 
    type integer MyArrayType1[3] (1 .. 10);
	
	testcase TC_Sem_060207_arrays_004() runs on GeneralComp {

        var MyArrayType1 v_array1 := { 
            [0] := 8,
            [1] := -,
            [2] := 2 
        }

        v_array1[1] := 1;
        
        if (v_array1 == { 8, 1, 2 }) {
	        setverdict(pass);
        }
        else {
	        setverdict(fail);
	    }

}

control {
    execute(TC_Sem_060207_arrays_004());
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, array specified in variable declaration
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// They [arrays] may be specified also at the point of a variable declaration.

module Syn_060207_arrays_001 {

    const integer c_arr[2] := {0, 1};
    modulepar integer PX_ARR[3];
    
	control {
		var integer v_arr[5], v_noarr, v_arr2[2];
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.3.2, verify the first element of an array is accessible by an index notation
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The index of the first element shall be zero.
module Sem_060207_arrays_009 {

	type component GeneralComp {
	}
 
    type integer MyArrayType1[3] (1 .. 10);
	
	testcase TC_Sem_060207_arrays_009() runs on GeneralComp {

        var MyArrayType1 v_array1 := {10, 1, 2};
        v_array1[0] := 10; // first index on the left hand side
        v_array1[1] := v_array1[0]; // first index on the right hand side
		if (v_array1 == { 10, 10, 2} ) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060207_arrays_009());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, using custom array index on the left hand side of assignments
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Indexed value notation can be used on both the right-hand side and left-hand 
// side of assignments. The index of the first element shall be zero or the lower 
// bound if an index range has been given.

module Sem_060207_arrays_021 {

	type component GeneralComp {
	}
	
	testcase TC_Sem_060207_arrays_021() runs on GeneralComp {        
        var integer v_arr[2..5] := { 2, 3, 4, 5 };
        v_arr[2] := 200;
        if (v_arr == { 200, 3, 4, 5 }) { setverdict(pass); }
        else { setverdict(fail); }
	}
	
	control {
		execute(TC_Sem_060207_arrays_021());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.7, verify that arrays can be used to specify record of type and they are compatible
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
 
// The following requirement is tested:
// Arrays can be used in TTCN-3 as a shorthand notation to specify record of types.

module Sem_060207_arrays_010 {

	type component GeneralComp {
	}
 
    type integer MyArrayType1[3];
    type record length (3) of integer MyRecordOfType1;
	
	testcase TC_Sem_060207_arrays_010() runs on GeneralComp {

        var MyArrayType1 a1 := {7, 8, 9};
        var MyRecordOfType1 r1 := {7, 8, 9};
		
		if (r1 == a1) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060207_arrays_010());
	}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.7, ensure that the two dimensional array type referencing is correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060207_arrays_013 {

// The following requirement is tested:
// Individual elements of multi-dimensional arrays can be accessed by repeated use of 
// the index notation. 
// For assigning values to multi-dimensional arrays, each dimension that is assigned 
// shall resolve to a set of values enclosed in curly braces. 

 type component GeneralComp {
 }

 
 type integer MyArrayType1[2][3] (1 .. 10);
 
 
testcase TC_Sem_060207_arrays_013() runs on GeneralComp {

  var MyArrayType1 v_array1 := {{8, 10, 9},
                                {2, 3, 4}};

  if (v_array1[1][1]==3) {
    setverdict(pass);
  }
  else {
    setverdict(fail);
  }

}

control {
    execute(TC_Sem_060207_arrays_013());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.7, verify assignment of explicitly identified elements to arrays
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
 
// The following requirement is tested:
// Values may be assigned individually by a value list notation or indexed notation 
// or more than one or all at once by a value list notation or index assignment 
// notation. 
// Elements to be left out from the assignment shall be explicitly skipped in the 
// list by using dash.
 
module Sem_060207_arrays_002 {

	type component GeneralComp {
	}

    type integer MyArrayType1[3] (1 .. 10);
 
	testcase TC_Sem_060207_arrays_002() runs on GeneralComp {

        var MyArrayType1 v_array1 := { 
            [0] := 8,
            [1] := 1,
            [2] := - 
        };

		if (match(v_array1[0], 8) and match(v_array1[1], 1) and not isbound(v_array1[2])
			and lengthof (v_array1 & {2}) == 4) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}

	control {
		execute(TC_Sem_060207_arrays_002());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.7, predefined function in array dimension 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Array dimensions shall be specified using constant expressions, which shall 
// evaluate to a positive integer values. Constants used in the constant 
// expressions shall meet with the restrictions in clause 10.

module Sem_060207_arrays_016 {

	type component GeneralComp {
	}
	
	testcase TC_Sem_060207_arrays_016() runs on GeneralComp {        
        var integer v_arr[float2int(3.14159265359)] := { 0, 1, 2};
        log(v_arr);
		setverdict(pass);
	}
	
	control {
		execute(TC_Sem_060207_arrays_016());
	}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.5, union type declaration with single item
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// TTCN-3 supports the union type. The union type is a collection of alternatives,
// each one identified by an identifier. Only one of the specified alternatives 
// will ever be present in an actual union value. Union types are useful to model 
// data which can take one of a finite number of known types.

module Syn_060205_top_level_002 {
    type union U {	
		integer option1
	}
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.5, union type declaration
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// TTCN-3 supports the union type. The union type is a collection of alternatives,
// each one identified by an identifier. Only one of the specified alternatives 
// will ever be present in an actual union value. Union types are useful to model 
// data which can take one of a finite number of known types.

module Syn_060205_top_level_001 {
    const integer number := 4; // to test rules on uniqueness of identifiers
    
    type union MyUnionType 
	{	
		integer 		number,
		charstring 		string
	}
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.5, assignment notation for union values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The assignment notation shall be used for union-s, and the notation shall assign
// a value to one field only. This field becomes the chosen field.

module Sem_060205_top_level_001 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1,
		charstring option2
	}
    
    testcase TC_Sem_060205_top_level_001() runs on GeneralComp {
		var U v_choice := { option1 := 1 };
        if (ischosen(v_choice.option1) and v_choice.option1 == 1) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_Sem_060205_top_level_001());
	}
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.5, union type declaration
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// TTCN-3 supports the definition of types for union alternatives nested within 
// the union definition, similar to the mechanism for record types described in 
// clause 6.2.1.3.

module Syn_06020503_nested_type_definition_for_field_types_001 {
    
    type union MyUnionType 
	{	
		record {
            integer field1,
            integer field2 optional
        } option1,
		record of integer option2,
        union {
            integer suboption1,
            charstring suboption2
        } option3
	}
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.5.1, union alternative in extended type reference
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Alternatives of a union type shall be referenced by the dot notation 
// TypeIdOrExpression.AlternativeId, where TypeIdOrExpression resolves to the name
// of a union type or an expression of a union type such as variable, formal 
// parameter, module parameter, constant, template, or function invocation. 
// AlternativeId shall resolve to the name of an alternative in the union type.

module Sem_06020501_referencing_fields_of_union_type_002 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1,
		charstring option2
	}
    
    type U.option1 UnionItem;
    
    testcase TC_Sem_06020501_referencing_fields_of_union_type_002() runs on GeneralComp {
		var UnionItem v_val := 1;
        if (v_val == 1) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_Sem_06020501_referencing_fields_of_union_type_002());
	}
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.5.1, union costraint not applied to extended type reference to its item
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// If an alternative in a union type or a subtype of a union type is referenced by 
// the dot notation, the resulting type is the set of values allowed for that 
// alternative imposed by the constraints of the alternative declaration itself 
// (i.e. any constraints applied to the union type itself are ignored).

module Sem_06020501_referencing_fields_of_union_type_003 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1,
		charstring option2
	}
    
    type U ConstrainedU ( {option1 := 1 }, { option1 := 2});
    type ConstrainedU.option1 UnionItem;
    
    testcase TC_Sem_06020501_referencing_fields_of_union_type_003() runs on GeneralComp {
		var UnionItem v_val := 100;
        if (v_val == 100) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_Sem_06020501_referencing_fields_of_union_type_003());
	}
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.5.1, referencing alternative on left hand side of assignment
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When referencing an alternative of a union type on the left hand side of 
// an assignment, the referenced alternative shall become the chosen one. This rule
// shall apply recursively if the reference contains alternatives of nested unions, 
// choosing all the referenced alternatives.

module Sem_06020501_referencing_fields_of_union_type_004 {  
    type component GeneralComp {
	}

    type union U {	
		integer option1,
		charstring option2
	}

    testcase TC_Sem_06020501_referencing_fields_of_union_type_004() runs on GeneralComp {
		var U v_union;
        v_union.option1 := 1;        
        if (v_union.option1 ==  1) { setverdict(pass); }
        else { setverdict(fail); }
        
        v_union.option2 := "test";
        if (v_union.option2 ==  "test") { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_Sem_06020501_referencing_fields_of_union_type_004());
	}
}/***************************************************
 ** @author STF 470
 ** @version  0.0.1
 ** @purpose 1:6.5.2, Ensure that union is initialized by dot notation
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
 
module Sem_06020501_referencing_fields_of_union_type_001 {
	type union MyUnionType 
	{	
		integer 		number,
		charstring 		string
	};	
	
	type component GeneralComp {	    	    
	};

	
	testcase TC_Sem_06020501_referencing_fields_of_union_type_001 () runs on GeneralComp {
		var MyUnionType v_mut ;
		v_mut.number := 0;
		
		if (v_mut.number == 0) {
			setverdict(pass);
		}
		else {
			setverdict(fail);
		}
	}
 
	control {
		execute(TC_Sem_06020501_referencing_fields_of_union_type_001());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.5.1, referencing nested alternative on left hand side of assignment
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When referencing an alternative of a union type on the left hand side of 
// an assignment, the referenced alternative shall become the chosen one. This rule
// shall apply recursively if the reference contains alternatives of nested unions, 
// choosing all the referenced alternatives.

module Sem_06020501_referencing_fields_of_union_type_005 {  
    type component GeneralComp {
	}

    type union SubU {	
		integer suboption1,
		charstring suboption2
	}
    
    type union U {	
		integer option1,
		SubU option2
	}

    testcase TC_Sem_06020501_referencing_fields_of_union_type_005() runs on GeneralComp {
		var U v_union;
        v_union.option1 := 1;        
        if (v_union.option1 ==  1) { setverdict(pass); }
        else { setverdict(fail); }
        
        v_union.option2.suboption2 := "test";
        if (v_union.option2.suboption2 ==  "test") { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_Sem_06020501_referencing_fields_of_union_type_005());
	}
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.5.1, referencing field of structured alternative on left hand side of assignment
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When referencing an alternative of an uninitialized union value or field or 
// omitted field (including omitting a field at a higher level of the embedding 
// hierarchy) on the left hand side of an assignment, the reference shall 
// recursively be expanded up to and including the depth of the referenced 
// alternative as follows:
// a) When expanding a value or value field of union type, the alternative 
// referenced in the dot notation becomes the chosen one.
// b) Expansion of record, record of, set, set of, and array values and intermediate 
// fields shall follow the rules of item a) in clauses 6.2.1.1and 6.2.3, and clause 
// 6.2.2.1 correspondingly.
// c) At the end of the expansion, the value at the right hand side of the assignment
// shall be assigned to the referenced alternative.

module Sem_06020501_referencing_fields_of_union_type_006 {  
    type component GeneralComp {
	}

    type record of integer RI;
    type record R {
        RI field1,
        integer field2
    }
    
    type union U {	
		integer option1,
		R option2
	}

    testcase TC_Sem_06020501_referencing_fields_of_union_type_006() runs on GeneralComp {
		var U v_union;
        v_union.option2.field1[1] := 10;        

        if (ischosen(v_union.option2) and isbound(v_union.option2.field1) and
           not isbound(v_union.option2.field2) and not isbound(v_union.option2.field1[0]) and
           v_union.option2.field1[1] == 10) { setverdict(pass); }
        else { setverdict(fail); }
	}

	control{
		execute(TC_Sem_06020501_referencing_fields_of_union_type_006());
	}
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.4, using enumerated value with implicit type reference
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For any instantiation or value reference of an enumerated type, the given 
// type shall be implicitly or explicitly referenced.

module Sem_060204_enumerated_type_and_values_005 {

    type component GeneralComp {
	}
    
    type enumerated EDays {
        Monday, Tuesday, Wednesday, Thursday, Friday
    };
    
    testcase TC_Sem_060204_enumerated_type_and_values_005() runs on GeneralComp {
        var EDays v_day := Monday;
        if (v_day == Monday) { //the type of variable v_day identifies the type context of EDays for the equality operator
		    setverdict(pass);
        } else {
            setverdict(fail);
        }
	}
	
	control {
		execute(TC_Sem_060204_enumerated_type_and_values_005());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.4, reusing enumerated value identifier in another enumerated type declaration
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// The identifiers of enumerated values shall only be reused within other structured 
// type definitions and shall not be used for identifiers of local or global 
// visibility at the same or a lower level of the same branch of the scope hierarchy 
// (see scope hierarchy in clause 5.2).

module Sem_060204_enumerated_type_and_values_001 {

    type enumerated MyFirstEnumType {
        Monday, Tuesday, Wednesday, Thursday, Friday
    };
    type enumerated MySecondEnumType {
        Saturday, Sunday, Monday
    };
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.4, mixed automatic and explicit numbering of enumerated items
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For each enumerated value without an assigned integer value, the system 
// successively associates an integer number in the textual order of the 
// enumerated values, starting at the left-hand side, beginning with zero, by 
// step 1 and skipping any number occupied by any of the enumerated values with 
// a manually assigned value. These values are only used by the system to allow 
// the use of relational operators. The user shall not directly use associated 
// integer values but can access them and convert integer values into enumerated 
// values by using the predefined functions enum2int and int2enum (see clauses 
// 16.1.2, C.1.29 C.1.30 and C.1.4 C.1.4).

module Sem_060204_enumerated_type_and_values_004 {

    type component GeneralComp {
	}
    
    type enumerated EDays {
        Monday(1), Tuesday, Wednesday, Thursday(10), Friday
    };
    
    testcase TC_Sem_060204_enumerated_type_and_values_004() runs on GeneralComp {
        var EDays v_day0 := Monday, v_day2 := Wednesday, v_day4 := Friday;
		
		if (enum2int(v_day0) == 1 and enum2int(v_day2) == 2 and enum2int(v_day4) == 3) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060204_enumerated_type_and_values_004());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.4, automatic numbering of enumerated items
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For each enumerated value without an assigned integer value, the system 
// successively associates an integer number in the textual order of the 
// enumerated values, starting at the left-hand side, beginning with zero, by 
// step 1 and skipping any number occupied by any of the enumerated values with 
// a manually assigned value. These values are only used by the system to allow 
// the use of relational operators. The user shall not directly use associated 
// integer values but can access them and convert integer values into enumerated 
// values by using the predefined functions enum2int and int2enum (see clauses 
// 16.1.2, C.1.29 C.1.30 and C.1.4 C.1.4).

module Sem_060204_enumerated_type_and_values_002 {

    type component GeneralComp {
	}
    
    type enumerated EDays {
        Monday, Tuesday, Wednesday, Thursday, Friday
    };
    
    testcase TC_Sem_060204_enumerated_type_and_values_002() runs on GeneralComp {
        var EDays v_day0 := Monday, v_day2 := Wednesday, v_day4 := Friday;
		
		if (enum2int(v_day0) == 0 and enum2int(v_day2) == 2 and enum2int(v_day4) == 4) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060204_enumerated_type_and_values_002());
	}
}
module Sem_060204_enumerated_type_and_values_006_import {
    type enumerated EDays {
        Monday, Tuesday, Wednesday, Thursday, Friday
    };
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.4, parameterized template without default parameters and with the same name as one of enumerated values of the imported parent type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When a TTCN-3 module parameter, formal parameter, constant, variable, 
// non-parameterized template or parameterized template with all formal 
// parameters having default values of an imported enumerated type is defined, 
// the name of that definition shall not be the same as any of the enumerated 
// values of that type.

module Sem_060204_enumerated_type_and_values_006 {

    import from Sem_060204_enumerated_type_and_values_006_import all;
    
    type component GeneralComp {
	}
    
    template EDays Monday(EDays p_par1) := ( Friday, p_par1 );
        
    testcase TC_Sem_060204_enumerated_type_and_values_006() runs on GeneralComp {        
        setverdict(pass);
	}
	
	control {
		execute(TC_Sem_060204_enumerated_type_and_values_006());
	}
}

/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.4, explicit numbering of enumerated items
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For each enumerated value without an assigned integer value, the system 
// successively associates an integer number in the textual order of the 
// enumerated values, starting at the left-hand side, beginning with zero, by 
// step 1 and skipping any number occupied by any of the enumerated values with 
// a manually assigned value. These values are only used by the system to allow 
// the use of relational operators. The user shall not directly use associated 
// integer values but can access them and convert integer values into enumerated 
// values by using the predefined functions enum2int and int2enum (see clauses 
// 16.1.2, C.1.29 C.1.30 and C.1.4 C.1.4).

module Sem_060204_enumerated_type_and_values_003 {

    type component GeneralComp {
	}
    
    type enumerated EDays {
        Monday(-1), Tuesday(4), Wednesday(0), Thursday(6), Friday(20)
    };
    
    testcase TC_Sem_060204_enumerated_type_and_values_003() runs on GeneralComp {
        var EDays v_day0 := Monday, v_day2 := Wednesday, v_day4 := Friday;
		
		if (enum2int(v_day0) == -1 and enum2int(v_day2) == 0 and enum2int(v_day4) == 20) {
			setverdict(pass);
		} else {
			setverdict(fail);
		}
	}
	
	control {
		execute(TC_Sem_060204_enumerated_type_and_values_003());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.4, enumerated type declaration
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// TTCN 3 supports enumerated types. Enumerated types are used to model types
// that take only a distinct named set of values. Such distinct values are called 
// enumerated values. Each enumerated value shall have an identifier. 

module Syn_060204_enumerated_type_and_values_001 {

    type enumerated MyFirstEnumType {
        Monday, Tuesday, Wednesday, Thursday, Friday
    };
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.4, enumerated type declaration with user-assigned values
 ** @verdict  pass accept, noexecution
 ***************************************************/

// The following requirement is tested:
// Each enumerated value may optionally have a user-assigned integer value, which 
// is defined after the name of the enumerated value in parenthesis. 

module Syn_060204_enumerated_type_and_values_002 {

    type enumerated MyFirstEnumType {
        Monday, Tuesday(2), Wednesday(-1), Thursday, Friday
    };
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype can have an set value and set value can be anytype
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_011 {
 type component GeneralComp {	    	    
}

type set MySet
{
integer First,
charstring	Second,
anytype Third			//3rd element of this type of set is anytype
}
 
testcase TC_Sem_060206_anytype_011() runs on GeneralComp {

var anytype c;
var MySet S; // Set S from type MySet

c.MySet.Second := "abc";	// anytype c becomes a charstring
S.Third.float:=15.5; // The 3rd element in set S is now becomes a float with value 15.5
	
 
      if ( match(c.MySet.Second, "abc") and match(S.Third.float, 15.5)) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_011());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype comprise bitstring and hexstring data type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_005 {
 type component GeneralComp {	    	    

var anytype Var1, Var2;
}
 
testcase TC_Sem_060206_anytype_005() runs on GeneralComp {

Var1.bitstring := '1010'B;
Var2.hexstring:='FE80'H;

 
      if (match(Var1.bitstring, '1010'B) and match(Var2.hexstring, 'FE80'H)) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_005());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that ensure that anytype comprise universal charstring
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_007{

 type component GeneralComp {	    	    
			var anytype MyVarOne;
			var universal charstring MyVarThree;
			    }
 
testcase TC_Sem_060206_anytype_007() runs on GeneralComp {


	MyVarOne.universal charstring := "FF80";		//a universal charstring in anytype

 	MyVarThree:=MyVarOne.universal charstring;
 
  	    if (MyVarThree=="FF80") {
	    setverdict(pass);
      		}
      	   else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_007());
}

}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype is a valid value inside an union
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_008 {
 type component GeneralComp {
	var anytype c;
}

type union R
	{
	anytype cs1	//Union type R element is an anytype data 
	}
	

testcase TC_Sem_060206_anytype_008() runs on GeneralComp {

c.R.cs1.charstring := "abc";		// The element of Uninon R becomes a charstring
	
      if (c.R.cs1.charstring =="abc") {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_008());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that ensure that anytype comprise octetstring and charstring
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_006 {

 type component GeneralComp {	    	    

var anytype MyVarOne, MyVarTwo;
var octetstring MyVarThree;
var charstring MyString1;
}
 
testcase TC_Sem_060206_anytype_006() runs on GeneralComp {

MyVarOne.octetstring := 'FF70'O;		//a float in anytype
MyVarTwo.charstring :="abc";	// a charstring in the same anytype

MyVarThree:=MyVarOne.octetstring;	
MyString1:=MyVarTwo.charstring&"def"; // "abc" & "def" =>"abcdef"
 
      if ( match(MyVarThree, 'FF70'O) and match(MyString1, "abcdef") ) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_006());
}

}/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype (as a user defined type) can be imported from another module
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_060206_anytype_019 {
import from Sem_060206_anytype_019_import all;		// this contains a type (anytype) MyAnyType

type component GeneralComp {
var MyAnyType x;	// MyAnyType is an anytype defined in module Sem_060206_anytype_017_import
var MyAnyType y;
}

	
testcase TC_Sem_060206_anytype_019() runs on GeneralComp {

x.float := 10.0E0;		//anytype x is now a float with value 10.0
y.bitstring := '1010'B; //anytype y is now a bitstring with value 1010
	
      if (match(x.float, 10.0E0) and match(y.bitstring, '1010'B)) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_019());
}

}


module Sem_060206_anytype_019_import
{

	type anytype MyAnyType;
	
	

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype comprise verdicttype data type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_004 {
 type component GeneralComp {	    	    

var anytype Var1, Var2;
var verdicttype c;

}
 
testcase TC_Sem_060206_anytype_004() runs on GeneralComp {

Var1.verdicttype := pass;
Var2.verdicttype:=fail;

c :=Var1.verdicttype;
 
      if (match(c, pass) and match(Var2.verdicttype, fail)) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_004());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype comprise integer data type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_001 {
	
	
 type component GeneralComp {	    	    

var anytype Var1, Var2;
var integer Var3;
}

 
testcase TC_Sem_060206_anytype_001() runs on GeneralComp {

Var1.integer := 10;
Var2:= {integer := Var1.integer + 3};
Var3 := Var2.integer * 2;
 
      if (Var3==26) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_001());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype can act as an union
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_016 {
	
type union MyUnion1 {
integer number,
charstring string
};
	
		
type component GeneralComp {	    	    

	var anytype x;	// anytype x variable
	var MyUnion1 y;

}

 
testcase TC_Sem_060206_anytype_0016() runs on GeneralComp {
	
y.number:=11;
y.string := "abc";	// Union y contains field1=abc and field2=true


x.MyUnion1:= y;	// anytype x now gets the type MyUnion1 and the values given by y.

      if (valueof(x.MyUnion1)==valueof(y)) 
	  {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_0016());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype can be record type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_014 {
	
type record MyRec1{
		charstring field1,
		boolean field2 };
	
		
type component GeneralComp {	    	    

	var anytype x;	// anytype x variable
	
	var MyRec1 y := {
		field1:= "abc",
		field2:= true };	// record y contains field1=abc and field2=true

}

 
testcase TC_Sem_060206_anytype_014() runs on GeneralComp {

x.MyRec1 := y;	// anytype x now gets the type MyRec1 and the values given by y.
		
 
      if (match(x.MyRec1.field1, "abc") and match(x.MyRec1.field2,true))  {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_014());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that redeclaration of an anytype value works properly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_012 {

type record R
	{
		anytype R1 // R Record type contains an anytype element.
	};

type component GeneralComp {	    	    

var anytype Var_1, Var_2,Var_3;
var R MyRec;

}
 
testcase TC_Sem_060206_anytype_012() runs on GeneralComp {

Var_1.integer := 10; // Var_1 integer with value of 10
Var_2.float := 3.0E0; 	// Var_2 float with value of 3.0
MyRec.R1.float := 3.5E0; // record MyRec R1 element is now a float with value of 3.5
	
Var_3.float := MyRec.R1.float + Var_2.float; // Var_3 is float type = 3.5 + 3.0

// changing types:	
Var_1.float := 5.5E0;	// Var_1 float with value of 5.5
Var_2.charstring := "abc"; 	// Var_2 charstring with value of "abc"
MyRec.R1.charstring := "def"; // record MyRec R1 element is now a charstring with value of "def" 
	
      if (match(Var_1.float, 5.5E0) and match(Var_2.charstring, "abc") and match(Var_3.float, 6.5E0) 
          and match(MyRec.R1.charstring, "def")) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_012());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype can be an enum type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_010 {
 type component GeneralComp {	    	    
}

type enumerated Myenum
{
FirstElement,
SecondElement
}
 
testcase TC_Sem_060206_anytype_010() runs on GeneralComp {

var anytype c;
c.Myenum:= FirstElement;	// anytype c follows the type Myenum and the value of c should be FirstElement
 
      if (c.Myenum ==FirstElement) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_010());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype can comprise array type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_017 {
	
type integer MyArray[1..3];		// MyArray type is an integer array with 3 elements
	
		
type component GeneralComp {	    	    

	var anytype x;	// Anytype x variable
	var MyArray y := {1,2,4};	// y array follows type MyArray with values 1,2,4

}

 
testcase TC_Sem_060206_anytype_0017() runs on GeneralComp {

x.MyArray := y;	// anytype x now follows type MyArray and gets the values of 1,2,4 as given in array y.
		
 
      if (match(x.MyArray, {1,2,4}))  {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_0017());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that record values can be anytype
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_009 {

	type record MyRec
	{
		anytype cs1 //Record type MyRec element is an anytype data
	}
	
	type component GeneralComp {
		var MyRec R;
		var anytype c,d;
}


	

testcase TC_Sem_060206_anytype_009() runs on GeneralComp {


R.cs1.charstring:= "abc";	// cs1 in R record is now charstring
c.charstring :=R.cs1.charstring;	// anytype c becomes a charstring

R.cs1.integer:= 15;		// cs1 in R record now integer
d.integer := R.cs1.integer; //anytype d becomes integer
	
	
      if ( match(c.charstring, "abc") and match(d.integer, 15)) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_009());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype can comprise set of and record of types
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_018 {
	
type record of integer FirstRecordOf;	// record of integers
type set of boolean FirstSetOf;		// set of booleans
	
		
type component GeneralComp {	    	    

	var anytype x;	// Anytype x and y variables
	var anytype y;
	
	var FirstRecordOf MyVar1 := { 0, 5, 2, -, 6 };	 // MyVar1 follows type FirstRecordOf with values 0,5,2,-,6
	var FirstSetOf MyVar2 := { true, -,-, false, true}; // MyVar2 follows type FirstSetOf with values true,-,-,false,true

}

 
testcase TC_Sem_060206_anytype_0018() runs on GeneralComp {

x.FirstRecordOf := MyVar1;	// anytype x is now a record of type with values of MyVar1
y.FirstSetOf := MyVar2;	// anytype x is now a set of type with values of MyVar2
 
      if (match(x.FirstRecordOf[0], 0) and match(x.FirstRecordOf[4], 6) 
      and  match(y.FirstSetOf[0], true) and  match(y.FirstSetOf[3], false) )  {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_0018());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that address type is included to anytype (if it has been explicitly defined within that module)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_013 {
	

type integer address;		// definition of address type globally
	
		
type component GeneralComp {	    	    

	var anytype x;
}

 
testcase TC_Sem_060206_anytype_013() runs on GeneralComp {

x.address:=10;	// anytype x now address type with value integer 10
		
 
      if (x.address==10)  {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_013());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype comprise float data type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_002 {
 type component GeneralComp {	    	    

var anytype Var1, Var2;
var float Var3;

}
 
testcase TC_Sem_060206_anytype_002() runs on GeneralComp {

Var1.float := 10.5;
Var2:= {float := Var1.float + 3.0};
Var3 := Var2.float * 2.0;
 
      if (Var3==27.0) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_002());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype can act as a set type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_015 {
	
type set MySet{
		charstring field1,
		boolean field2 };
	
		
type component GeneralComp {	    	    

	var anytype x; // anytype x variable
	
	var MySet y := {
		field1:= "abc",
		field2:= true };	// Set y contains field1=abc and field2=true

}

 
testcase TC_Sem_060206_anytype_015() runs on GeneralComp {

x.MySet := y;	// anytype x now gets the type MySet and the values given by y.
		
 
      if ( match(x.MySet.field1, "abc") and match(x.MySet.field2, true))  {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_015());
}

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.0.6, ensure that anytype comprise boolean data type
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060206_anytype_003 {
 type component GeneralComp {	    	    

var anytype Var1, Var2,Var3;
var boolean Var4, Var5;

}
 
testcase TC_Sem_060206_anytype_003() runs on GeneralComp {

Var1.boolean := true;
Var2.boolean:=true;
Var3.boolean := not Var1.boolean;	// not true = false

Var4 := Var1.boolean and Var2.boolean;		// true and true = true
Var5 := Var1.boolean and Var3.boolean;		// true and false = false
 
      if (match(Var4, true) and match(Var5, false)) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060206_anytype_003());
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that mandatory fields are created and uninitialized when expanding omitted record values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When referencing a field of an uninitialized record value or field or omitted field 
// (including omitting a field at a higher level of the embedding hierarchy) on the left 
// hand side of an assignment, the reference shall recursively be expanded up to and 
// including the depth of the referenced subfield as follows:  
// a) When expanding a value or value field of record type, the subfield referenced in 
// the dot notation shall be set to present and all unreferenced mandatory subfields shall 
// be left uninitialized; when the assignment is used in a scope where the optional 
// attribute is equal to "explicit omit", all unreferenced optional subfields shall be 
// left undefined. When the assignment is used in a scope where the optional attribute is 
// equal to "implicit omit", all unreferenced optional subfields shall be set to omit.
// b) Expansion of record of/set of/array, union and set values and intermediate fields 
// shall follow the rules of item a) in clauses 6.2.3 and 6.2.5.1, and clause 6.2.2.1 
// correspondingly.
// At the end of the expansion, the value at the right hand side of the assignment shall 
// be assigned to the referenced subfield.

module Sem_06020101_ReferencingRecordFields_013 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        record {
            integer field1,
            charstring field2
        } sub optional
    }  
    
    testcase TC_Sem_06020101_ReferencingRecordFields_013() runs on GeneralComp {
        var R v_rec;
        v_rec.sub := omit;
        v_rec.sub.field2 := "abc";
        if (isbound(v_rec.sub) and not isbound(v_rec.sub.field1)) {
	        setverdict(pass);
        } else {
	        setverdict(fail);
        }
    }
    
    control {
        execute(TC_Sem_06020101_ReferencingRecordFields_013());
    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that optional fields are created and uninitialized when expanding uninitialized record values (explicit omit)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When referencing a field of an uninitialized record value or field or omitted field 
// (including omitting a field at a higher level of the embedding hierarchy) on the left 
// hand side of an assignment, the reference shall recursively be expanded up to and 
// including the depth of the referenced subfield as follows:  
// a) When expanding a value or value field of record type, the subfield referenced in 
// the dot notation shall be set to present and all unreferenced mandatory subfields shall 
// be left uninitialized; when the assignment is used in a scope where the optional 
// attribute is equal to "explicit omit", all unreferenced optional subfields shall be 
// left undefined. When the assignment is used in a scope where the optional attribute is 
// equal to "implicit omit", all unreferenced optional subfields shall be set to omit.
// b) Expansion of record of/set of/array, union and set values and intermediate fields 
// shall follow the rules of item a) in clauses 6.2.3 and 6.2.5.1, and clause 6.2.2.1 
// correspondingly.
// At the end of the expansion, the value at the right hand side of the assignment shall 
// be assigned to the referenced subfield.

module Sem_06020101_ReferencingRecordFields_009 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        integer field1 optional,
        charstring field2
    }  
    
    testcase TC_Sem_06020101_ReferencingRecordFields_009() runs on GeneralComp {
        var R v_rec;
        v_rec.field2 := "abc";
        if (isbound(v_rec) and not isbound(v_rec.field1)) {
	        setverdict(pass);
        } else {
	        setverdict(fail);
        }
    }
    
    control {
        execute(TC_Sem_06020101_ReferencingRecordFields_009());
    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that referencing fields nested deep inside omitted record invokes expansion
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When referencing a field of an uninitialized record value or field or omitted field 
// (including omitting a field at a higher level of the embedding hierarchy) on the left 
// hand side of an assignment, the reference shall recursively be expanded up to and 
// including the depth of the referenced subfield as follows:  
// a) When expanding a value or value field of record type, the subfield referenced in 
// the dot notation shall be set to present and all unreferenced mandatory subfields shall 
// be left uninitialized; when the assignment is used in a scope where the optional 
// attribute is equal to "explicit omit", all unreferenced optional subfields shall be 
// left undefined. When the assignment is used in a scope where the optional attribute is 
// equal to "implicit omit", all unreferenced optional subfields shall be set to omit.
// b) Expansion of record of/set of/array, union and set values and intermediate fields 
// shall follow the rules of item a) in clauses 6.2.3 and 6.2.5.1, and clause 6.2.2.1 
// correspondingly.
// At the end of the expansion, the value at the right hand side of the assignment shall 
// be assigned to the referenced subfield.

module Sem_06020101_ReferencingRecordFields_016 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        record {
            record {
                record {
                    integer nested1,
                    integer nested2
                } subfield1,
                integer subfield2
            } field1,
            charstring field2
        } sub optional
    }  
    
    testcase TC_Sem_06020101_ReferencingRecordFields_016() runs on GeneralComp {
        var R v_rec;
        v_rec.sub := omit;
        v_rec.sub.field1.subfield1.nested1 := 0;
        if (isbound(v_rec.sub) and isbound(v_rec.sub.field1) and not isbound(v_rec.sub.field2) and
            isbound(v_rec.sub.field1.subfield1) and not isbound(v_rec.sub.field1.subfield2) and
            match(v_rec.sub.field1.subfield1.nested1, 0) and not isbound(v_rec.sub.field1.subfield1.nested2)) {
	        setverdict(pass);
        } else {
	        setverdict(fail);
        }
    }
    
    control {
        execute(TC_Sem_06020101_ReferencingRecordFields_016());
    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that referencing fields nested deep inside uninitialized record invokes expansion
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When referencing a field of an uninitialized record value or field or omitted field 
// (including omitting a field at a higher level of the embedding hierarchy) on the left 
// hand side of an assignment, the reference shall recursively be expanded up to and 
// including the depth of the referenced subfield as follows:  
// a) When expanding a value or value field of record type, the subfield referenced in 
// the dot notation shall be set to present and all unreferenced mandatory subfields shall 
// be left uninitialized; when the assignment is used in a scope where the optional 
// attribute is equal to "explicit omit", all unreferenced optional subfields shall be 
// left undefined. When the assignment is used in a scope where the optional attribute is 
// equal to "implicit omit", all unreferenced optional subfields shall be set to omit.
// b) Expansion of record of/set of/array, union and set values and intermediate fields 
// shall follow the rules of item a) in clauses 6.2.3 and 6.2.5.1, and clause 6.2.2.1 
// correspondingly.
// At the end of the expansion, the value at the right hand side of the assignment shall 
// be assigned to the referenced subfield.

module Sem_06020101_ReferencingRecordFields_011 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        record {
            record {
                integer nested1,
                integer nested2
            } subfield1,
            integer subfield2
        } field1,
        charstring field2
    }  
    
    testcase TC_Sem_06020101_ReferencingRecordFields_011() runs on GeneralComp {
        var R v_rec;
        v_rec.field1.subfield1.nested1 := 0;
        if (isbound(v_rec) and isbound(v_rec.field1) and not isbound(v_rec.field2) and
            isbound(v_rec.field1.subfield1) and not isbound(v_rec.field1.subfield2) and
            v_rec.field1.subfield1.nested1 == 0 and not isbound(v_rec.field1.subfield1.nested2)) {
	        setverdict(pass);
        } else {
	        setverdict(fail);
        }
    }
    
    control {
        execute(TC_Sem_06020101_ReferencingRecordFields_011());
    }

}
/***************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, The dot notation used in record type definitions is correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06020101_ReferencingRecordFields_004 {

type component GeneralComp {	    	    
}

 type record R {
  integer field1 (1 .. 10),
  charstring field2 optional
 }  

 
 type R.field2 MyChar;
 
testcase TC_Sem_06020101_ReferencingRecordFields_004() runs on GeneralComp {

 var MyChar v_char := "abc";  // any character string is allowed
 
      if (v_char=="abc") {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_06020101_ReferencingRecordFields_004());
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that optional fields are created and uninitialized when expanding omitted record values (explicit omit)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When referencing a field of an uninitialized record value or field or omitted field 
// (including omitting a field at a higher level of the embedding hierarchy) on the left 
// hand side of an assignment, the reference shall recursively be expanded up to and 
// including the depth of the referenced subfield as follows:  
// a) When expanding a value or value field of record type, the subfield referenced in 
// the dot notation shall be set to present and all unreferenced mandatory subfields shall 
// be left uninitialized; when the assignment is used in a scope where the optional 
// attribute is equal to "explicit omit", all unreferenced optional subfields shall be 
// left undefined. When the assignment is used in a scope where the optional attribute is 
// equal to "implicit omit", all unreferenced optional subfields shall be set to omit.
// b) Expansion of record of/set of/array, union and set values and intermediate fields 
// shall follow the rules of item a) in clauses 6.2.3 and 6.2.5.1, and clause 6.2.2.1 
// correspondingly.
// At the end of the expansion, the value at the right hand side of the assignment shall 
// be assigned to the referenced subfield.

module Sem_06020101_ReferencingRecordFields_014 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        record {
            integer field1 optional,
            charstring field2
        } sub optional
    }  
    
    testcase TC_Sem_06020101_ReferencingRecordFields_014() runs on GeneralComp {
        var R v_rec;
        v_rec.sub := omit;
        v_rec.sub.field2 := "abc";
        if (isbound(v_rec.sub) and not isbound(v_rec.sub.field1)) {
	        setverdict(pass);
        } else {
	        setverdict(fail);
        }
    }
    
    control {
        execute(TC_Sem_06020101_ReferencingRecordFields_014());
    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that expansion of uninitialized record values works when other constructive types are involved
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When referencing a field of an uninitialized record value or field or omitted field 
// (including omitting a field at a higher level of the embedding hierarchy) on the left 
// hand side of an assignment, the reference shall recursively be expanded up to and 
// including the depth of the referenced subfield as follows:  
// a) When expanding a value or value field of record type, the subfield referenced in 
// the dot notation shall be set to present and all unreferenced mandatory subfields shall 
// be left uninitialized; when the assignment is used in a scope where the optional 
// attribute is equal to "explicit omit", all unreferenced optional subfields shall be 
// left undefined. When the assignment is used in a scope where the optional attribute is 
// equal to "implicit omit", all unreferenced optional subfields shall be set to omit.
// b) Expansion of record of/set of/array, union and set values and intermediate fields 
// shall follow the rules of item a) in clauses 6.2.3 and 6.2.5.1, and clause 6.2.2.1 
// correspondingly.
// At the end of the expansion, the value at the right hand side of the assignment shall 
// be assigned to the referenced subfield.

module Sem_06020101_ReferencingRecordFields_012 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        union {
            record {
                integer nested1,
                integer nested2
            } option1[2],
            integer option2
        } field1,
        charstring field2
    }  
    
    testcase TC_Sem_06020101_ReferencingRecordFields_012() runs on GeneralComp {
        var R v_rec;
        v_rec.field1.option1[0].nested1 := 0;
        if (isbound(v_rec) and isbound(v_rec.field1) and not isbound(v_rec.field2) and            
            match(v_rec.field1.option1[0].nested1, 0) and not isbound(v_rec.field1.option1[0].nested2)) {
	        setverdict(pass);
        } else {
	        setverdict(fail);
        }
    }
    
    control {
        execute(TC_Sem_06020101_ReferencingRecordFields_012());
    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that dot notation can be used for referencing elements on the right hand side of an assignement
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Elements of a record shall be referenced by the dot notation TypeIdOrExpression.ElementId, 
// where TypeIdOrExpression resolves to the name of a structured type or an expression of 
// a structured type such as variable, formal parameter, module parameter, constant, template, 
// or function invocation. ElementId shall resolve to the name of a field in the structured 
// type.

module Sem_06020101_ReferencingRecordFields_005 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        integer field1 (1 .. 10),
        charstring field2 optional
    }  
    
    testcase TC_Sem_06020101_ReferencingRecordFields_005() runs on GeneralComp {
        var R v_rec := { field1 := 5, field2 := "abc" };
        if (v_rec.field1 == 5) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }
    
    control {
        execute(TC_Sem_06020101_ReferencingRecordFields_005());
    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that optional fields are created and omitted when expanding uninitialized record values (implicit omit)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When referencing a field of an uninitialized record value or field or omitted field 
// (including omitting a field at a higher level of the embedding hierarchy) on the left 
// hand side of an assignment, the reference shall recursively be expanded up to and 
// including the depth of the referenced subfield as follows:  
// a) When expanding a value or value field of record type, the subfield referenced in 
// the dot notation shall be set to present and all unreferenced mandatory subfields shall 
// be left uninitialized; when the assignment is used in a scope where the optional 
// attribute is equal to "explicit omit", all unreferenced optional subfields shall be 
// left undefined. When the assignment is used in a scope where the optional attribute is 
// equal to "implicit omit", all unreferenced optional subfields shall be set to omit.
// b) Expansion of record of/set of/array, union and set values and intermediate fields 
// shall follow the rules of item a) in clauses 6.2.3 and 6.2.5.1, and clause 6.2.2.1 
// correspondingly.
// At the end of the expansion, the value at the right hand side of the assignment shall 
// be assigned to the referenced subfield.

module Sem_06020101_ReferencingRecordFields_010 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        integer field1 optional,
        charstring field2
    }  
    
    testcase TC_Sem_06020101_ReferencingRecordFields_010() runs on GeneralComp {
        var R v_rec;
        v_rec.field2 := "abc";
        if (v_rec == { omit, "abc" }) {
	        setverdict(pass);
        } else {
	        setverdict(fail);
        }
    }
    
    control {
        execute(TC_Sem_06020101_ReferencingRecordFields_010());
    }
} with { optional "implicit omit" }
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that mandatory fields are created and uninitialized when expanding uninitialized record values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When referencing a field of an uninitialized record value or field or omitted field 
// (including omitting a field at a higher level of the embedding hierarchy) on the left 
// hand side of an assignment, the reference shall recursively be expanded up to and 
// including the depth of the referenced subfield as follows:  
// a) When expanding a value or value field of record type, the subfield referenced in 
// the dot notation shall be set to present and all unreferenced mandatory subfields shall 
// be left uninitialized; when the assignment is used in a scope where the optional 
// attribute is equal to "explicit omit", all unreferenced optional subfields shall be 
// left undefined. When the assignment is used in a scope where the optional attribute is 
// equal to "implicit omit", all unreferenced optional subfields shall be set to omit.
// b) Expansion of record of/set of/array, union and set values and intermediate fields 
// shall follow the rules of item a) in clauses 6.2.3 and 6.2.5.1, and clause 6.2.2.1 
// correspondingly.
// At the end of the expansion, the value at the right hand side of the assignment shall 
// be assigned to the referenced subfield.

module Sem_06020101_ReferencingRecordFields_008 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        integer field1,
        charstring field2
    }  
    
    testcase TC_Sem_06020101_ReferencingRecordFields_008() runs on GeneralComp {
        var R v_rec;
        v_rec.field2 := "abc";
        if (isbound(v_rec) and not isbound(v_rec.field1)) {
	        setverdict(pass);
        } else {
	        setverdict(fail);
        }
    }
    
    control {
        execute(TC_Sem_06020101_ReferencingRecordFields_008());
    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that dot notation can be used for referencing function invocation results
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Elements of a record shall be referenced by the dot notation TypeIdOrExpression.ElementId, 
// where TypeIdOrExpression resolves to the name of a structured type or an expression of 
// a structured type such as variable, formal parameter, module parameter, constant, template, 
// or function invocation. ElementId shall resolve to the name of a field in the structured 
// type.

module Sem_06020101_ReferencingRecordFields_007 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        record {
            integer subfield1
        } field1,
        charstring field2 optional
    }  
    
    function f_retVal() return R {
        return { field1 := { subfield1 := 5 }, field2 := "abc" };
    }
    
    testcase TC_Sem_06020101_ReferencingRecordFields_007() runs on GeneralComp {
        if (f_retVal().field1.subfield1 == 5) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }
    
    control {
        execute(TC_Sem_06020101_ReferencingRecordFields_007());
    }

}
/***************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, The dot notation used in record type definitions is correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06020101_ReferencingRecordFields_002 {

type component GeneralComp {	    	    
}

 type record R {
  integer field1 (1 .. 10),
  charstring field2 optional
 }  
 
 type R ConstrainedRecord ({1, omit}, {2, "xyz"}, {3, "zyx"}) ;
 
 type ConstrainedRecord.field2 MyChar;
 
testcase TC_Sem_06020101_ReferencingRecordFields_002() runs on GeneralComp {

 var MyChar v_char := "abc";  // any character string is allowed
 
      if (v_char=="abc") {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_06020101_ReferencingRecordFields_002());
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that optional fields are created and omitted when expanding omitted record values (implicit omit)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When referencing a field of an uninitialized record value or field or omitted field 
// (including omitting a field at a higher level of the embedding hierarchy) on the left 
// hand side of an assignment, the reference shall recursively be expanded up to and 
// including the depth of the referenced subfield as follows:  
// a) When expanding a value or value field of record type, the subfield referenced in 
// the dot notation shall be set to present and all unreferenced mandatory subfields shall 
// be left uninitialized; when the assignment is used in a scope where the optional 
// attribute is equal to "explicit omit", all unreferenced optional subfields shall be 
// left undefined. When the assignment is used in a scope where the optional attribute is 
// equal to "implicit omit", all unreferenced optional subfields shall be set to omit.
// b) Expansion of record of/set of/array, union and set values and intermediate fields 
// shall follow the rules of item a) in clauses 6.2.3 and 6.2.5.1, and clause 6.2.2.1 
// correspondingly.
// At the end of the expansion, the value at the right hand side of the assignment shall 
// be assigned to the referenced subfield.

module Sem_06020101_ReferencingRecordFields_015 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        record {
            integer field1 optional,
            charstring field2
        } sub optional
    }  
    
    testcase TC_Sem_06020101_ReferencingRecordFields_015() runs on GeneralComp {
        var R v_rec;
        v_rec.sub := omit;
        v_rec.sub.field2 := "abc";
        if (v_rec.sub == { omit, "abc" }) {
	        setverdict(pass);
        } else {
	        setverdict(fail);
        }
    }
    
    control {
        execute(TC_Sem_06020101_ReferencingRecordFields_015());
    }
} with { optional "implicit omit" }
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that dot notation can be used for referencing sub-elements on the right hand side of an assignement
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Elements of a record shall be referenced by the dot notation TypeIdOrExpression.ElementId, 
// where TypeIdOrExpression resolves to the name of a structured type or an expression of 
// a structured type such as variable, formal parameter, module parameter, constant, template, 
// or function invocation. ElementId shall resolve to the name of a field in the structured 
// type.

module Sem_06020101_ReferencingRecordFields_006 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        record {
            integer subfield1
        } field1,
        charstring field2 optional
    }  
    
    testcase TC_Sem_06020101_ReferencingRecordFields_006() runs on GeneralComp {
        var R v_rec := { field1 := { subfield1 := 5 }, field2 := "abc" };
        if (v_rec.field1.subfield1 == 5) {
	        setverdict(pass);
        } else {
	        setverdict(fail);
        }
    }
    
    control {
        execute(TC_Sem_06020101_ReferencingRecordFields_006());
    }

}
/***************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, The dot notation used in record type definitions is correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06020101_ReferencingRecordFields_001 {

type component GeneralComp {	    	    
}

 type record R {
  integer field1 (1 .. 10),
  charstring field2 optional
 }  
 
 type R ConstrainedRecord ({1, omit}, {2, "xyz"}, {3, "zyx"}) ;
 
 type ConstrainedRecord.field1 MyInteger;
 
testcase TC_Sem_06020101_ReferencingRecordFields_001() runs on GeneralComp {

 var MyInteger v_int := 9;  // v_int is allowed in (1 .. 10) range
 
      if (v_int==9) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_06020101_ReferencingRecordFields_001());
}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, verify that expansion of omitted record values works when other constructive types are involved
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// When referencing a field of an uninitialized record value or field or omitted field 
// (including omitting a field at a higher level of the embedding hierarchy) on the left 
// hand side of an assignment, the reference shall recursively be expanded up to and 
// including the depth of the referenced subfield as follows:  
// a) When expanding a value or value field of record type, the subfield referenced in 
// the dot notation shall be set to present and all unreferenced mandatory subfields shall 
// be left uninitialized; when the assignment is used in a scope where the optional 
// attribute is equal to "explicit omit", all unreferenced optional subfields shall be 
// left undefined. When the assignment is used in a scope where the optional attribute is 
// equal to "implicit omit", all unreferenced optional subfields shall be set to omit.
// b) Expansion of record of/set of/array, union and set values and intermediate fields 
// shall follow the rules of item a) in clauses 6.2.3 and 6.2.5.1, and clause 6.2.2.1 
// correspondingly.
// At the end of the expansion, the value at the right hand side of the assignment shall 
// be assigned to the referenced subfield.

module Sem_06020101_ReferencingRecordFields_017 {

    type component GeneralComp {	    	    
    }
    
    type record R {
        record {
            union {
                record {
                    integer nested1,
                    integer nested2
                } option1[2],
                integer option2
            } field1,
            charstring field2
        } sub optional
    }  
    
    testcase TC_Sem_06020101_ReferencingRecordFields_017() runs on GeneralComp {
        var R v_rec;
        v_rec.sub := omit;
        v_rec.sub.field1.option1[0].nested1 := 0;
        if (isbound(v_rec) and isbound(v_rec.sub.field1) and not isbound(v_rec.sub.field2) and            
            match(v_rec.sub.field1.option1[0].nested1, 0) and not isbound(v_rec.sub.field1.option1[0].nested2)) {
	        setverdict(pass);
        } else {
	        setverdict(fail);
        }
    }
    
    control {
        execute(TC_Sem_06020101_ReferencingRecordFields_017());
    }

}
/***************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:6.2.1.1, The dot notation used in record type definitions is correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06020101_ReferencingRecordFields_003 {

type component GeneralComp {	    	    
}

 type record R {
  integer field1 (1 .. 10),
  charstring field2 optional
 }  
 
 type R.field1 MyInteger;
 
testcase TC_Sem_06020101_ReferencingRecordFields_003() runs on GeneralComp {

 var MyInteger v_int := 9;  // v_int is allowed in (1 .. 10) range
 
      if (v_int==9) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_06020101_ReferencingRecordFields_003());
}

}
/***************************************************
 ** @author   STF 451, re-numbering done by STF 470 and 487
 ** @version  0.0.1
 ** @desc     Test cases for clause 6.2                     
 ** @purpose  1:6.2, Ensure that assignments with "implicit omit" attribute are correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060201_RecordTypeValues_001  {

type component GeneralComp {	    	    
}

 type record R {
  integer f1,
  integer f2 optional,
  integer f3,
  integer f4 optional,
  integer f5 optional
 }  
 
testcase TC_Sem_060201_RecordTypeValues_001() runs on GeneralComp {

 var R v_assigned := { 1, -, 2 } with { optional "implicit omit" }
 template R m_check := { 1, omit, 2, omit, omit }
 
      if (match(v_assigned,m_check)) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060201_RecordTypeValues_001());
}

}
/***************************************************
 ** @author   STF 451, re-numbering done by STF 470 and 487
 ** @version  0.0.1
 ** @desc     Test cases for clause 6.2                     
 ** @purpose  1:6.2, Ensure that assignments with "implicit omit" attribute are correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060201_RecordTypeValues_003 {

type component GeneralComp {	    	    
}

 type record R {
  integer f1,
  integer f2 optional,
  integer f3,
  integer f4 optional,
  integer f5 optional
 }  
 
testcase TC_Sem_060201_RecordTypeValues_003() runs on GeneralComp {

 var R v_assigned := { 1, 2, 3 } with { optional "implicit omit" }
 
      if ( match(v_assigned.f1,1) 
           and match(v_assigned.f3,3) 
           and not ispresent(v_assigned.f4) 
           and not ispresent(v_assigned.f5) ) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060201_RecordTypeValues_003());
}

}
/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.2.1, The element identifiers are local to the record and shall be unique within the record (but do not have to be globally unique).
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_060201_RecordTypeValues_001 {
    const integer field2 := 4; // do not edit the name
    
    type record MyRecordType {
		integer field1,
		MyOtherRecordType field2 optional,
		charstring field3
	}
    type record MyOtherRecordType {
    	bitstring field1,
    	boolean field2
    }
}/***************************************************
 ** @author   STF 451, re-numbering done by STF 470 and 487
 ** @version  0.0.1
 ** @desc     Test cases for clause 6.2                     
 ** @purpose  1:6.2, Ensure that assignments with "implicit omit" attribute are correctly handled
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060201_RecordTypeValues_002 {

type component GeneralComp {	    	    
}

 type record R {
  integer f1,
  integer f2 optional,
  integer f3,
  integer f4 optional,
  integer f5 optional
 }  

 const R c_assigned := { 1, -, 2 } with { optional "implicit omit" }
 
testcase TC_Sem_060201_RecordTypeValues_002() runs on GeneralComp {

 template R m_check := { 1, omit, 2, omit, omit }
 
      if (match(c_assigned,m_check)) {
	    setverdict(pass);
      }
      else {
	    setverdict(fail);
	  }

}

control {
    execute(TC_Sem_060201_RecordTypeValues_002());
}

}
/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.2.1, Ensure that the IUT correctly handles empty record definitions.
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_060201_RecordTypeValues_002 {
    type record MyRecordType {
	}
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.8, verify than null value can be assigned to a default variable
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The special value null represents an unspecific default reference, e.g. can be
// used for the initialization of variables of default type.

module Sem_060208_default_type_002 { 

	type component GeneralComp {
	}

	testcase TC_Sem_060208_default_type_002() runs on GeneralComp {
		var default v_default := null;
		if (isbound(v_default)) { setverdict(pass) }
		else { setverdict(fail) }
	}

	control{
		execute(TC_Sem_060208_default_type_002());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.8, verify than a reference to an activated default can be assigned to a default variable
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Default references are unique references to activated defaults. Such a unique 
// default reference is generated by a test component when an altstep is activated 
// as a default, i.e. a default reference is the result of an activate operation.

module Sem_060208_default_type_001 { 

	type component GeneralComp {
	}	
	
	altstep a() runs on GeneralComp
	{
		[] any port.receive {}
	}

	testcase TC_Sem_060208_default_type_001() runs on GeneralComp {
		var default v_default := activate(a());
		if (v_default != null) { setverdict(pass) }
		else { setverdict(fail) }
	}

	control{
		execute(TC_Sem_060208_default_type_001());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2.8, verify than existing default references can be assigned 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Default references have the special and predefined type default. 
// + general type compatibility rules

module Sem_060208_default_type_003 { 

	type component GeneralComp {
	}	
	
	altstep a() runs on GeneralComp
	{
		[] any port.receive {}
	}

	testcase TC_Sem_060208_default_type_001() runs on GeneralComp {
		var default v_default := activate(a()), v_default2;
		v_default2 := v_default;
		if (v_default == v_default2) { setverdict(pass) }
		else { setverdict(fail) }
	}

	control{
		execute(TC_Sem_060208_default_type_001());
	}
}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.10, Ensure that extending a component with another component works properly
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

/* The following requirements are tested:
 * It is allowed to have one component type extending several parent types in one definition,
 * which have to be specified as a comma-separated list of types in the definition.
 * Any of the parent types may also be defined by means of extension. 
 */

module Sem_060210_ReuseofComponentTypes_001 {
 
 //MyComp has a port
 type component MyComp {
       port loopbackPort pt_myPort;
    }
    
//Component GeneralComp has a timer and a port extended from MyComp    
 type component GeneralComp extends MyComp {
        timer t;
    }
    
    type port loopbackPort message {
        inout integer;
    }
  

    testcase TC_Sem_060210_ReuseofComponentTypes_001() runs on GeneralComp {
   
  //Send an integer:
     pt_myPort.send(2);  

    alt {
     [] pt_myPort.receive(2) {
        setverdict(pass, "Receive successful");
     }
     [] pt_myPort.receive {
        setverdict(fail, "Unexpected result");
     }
    }

  }

    control{
        execute(TC_Sem_060210_ReuseofComponentTypes_001());
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.10, Ensure that extending a component with several other component works properly
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

/* The following requirements are tested:
 * When defining component types by extending more than one parent type,
 * there shall be no name clash between the definitions of the different parent types,
 * i.e. there shall not be a port, variable, constant or timer identifier that is declared
 * in any two of the parent types (directly or by means of extension). 
 */

module Sem_060210_ReuseofComponentTypes_002 {
 
  //MyCompA has a port pt_myPortA
  type component MyCompA {
    port loopbackPort pt_myPortA;
  }
    
  //MyComp has a port pt_myPortB
  type component MyCompB {
    port loopbackPort pt_myPortB;
  }
    
//Component GeneralComp has a timer and inherit two ports from MyCompA and MyCompB   
  type component GeneralComp extends MyCompA, MyCompB {
    timer t;
  }
    
  type port loopbackPort message {
    inout integer;
    inout float;
  }
  
  function loopback() runs on GeneralComp system GeneralComp {
    var integer v_i;
    var float v_f;
    while (true) {
      alt {
        [] pt_myPortA.receive(integer:?) -> value v_i { pt_myPortA.send(v_i); }
        [] pt_myPortA.receive(float:?) -> value v_f { pt_myPortA.send(v_f); }
        [] pt_myPortB.receive(integer:?) -> value v_i { pt_myPortB.send(v_i); }
        [] pt_myPortB.receive(float:?) -> value v_f { pt_myPortB.send(v_f); }
      }
    }
  }

  testcase TC_Sem_060210_ReuseofComponentTypes_002() runs on GeneralComp {
   
    var GeneralComp v_server := GeneralComp.create;
    
    connect(mtc:pt_myPortA, v_server:pt_myPortA);
    connect(mtc:pt_myPortB, v_server:pt_myPortB);
    
    v_server.start(loopback());
   
    //Send an integer from pt_myPortA:
    pt_myPortA.send(2);
    alt {
      [] pt_myPortA.receive(2) {
        setverdict(pass,"Receive successful");
      }
      [] pt_myPortA.receive {
        setverdict(fail,"Unexpected result");
      }
    }
        
    //Send an integer from pt_myPortB:
    pt_myPortB.send(1.0);
    alt {
      [] pt_myPortB.receive(1.0) {
        setverdict(pass,"Receive successful");
      }
      [] pt_myPortB.receive {
        setverdict(fail,"Unexpected result");
      }
    }

  }

  control{
    execute(TC_Sem_060210_ReuseofComponentTypes_002());
  }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.2.10, Ensure that extending a component with and extended component works properly
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

/* The following requirements are tested:
 * It is allowed to have one component type extending several parent types in one definition,
 * which have to be specified as a comma-separated list of types in the definition.
 * Any of the parent types may also be defined by means of extension. 
 */

module Sem_060210_ReuseofComponentTypes_003 {

  //MyCompA has a port pt_myPortA
  type component MyCompA {
    port loopbackPort pt_myPortA;
    var integer MyInt;
  }
    
  //MyComp has a port pt_myPortB and inherit a port (pt_myPortA) form MyCompA
  type component MyCompB extends MyCompA {
    port loopbackPort pt_myPortB;
  }
    
//Component GeneralComp has a timer and inherit two ports from MyCompB (pt_myPortA and pt_myPortB)
  type component GeneralComp extends MyCompB {
    timer t;
  }
    
  type port loopbackPort message {
    inout integer;
    inout float;
  }
  

  function loopback() runs on GeneralComp {
    var integer v_i;
    var float v_f;
    while (true) {
      alt {
        [] pt_myPortA.receive(integer:?) -> value v_i { pt_myPortA.send(v_i); }
        [] pt_myPortA.receive(float:?) -> value v_f { pt_myPortA.send(v_f); }
        [] pt_myPortB.receive(integer:?) -> value v_i { pt_myPortB.send(v_i); }
        [] pt_myPortB.receive(float:?) -> value v_f { pt_myPortB.send(v_f); }
      }
    }
  }
    
  testcase TC_Sem_060210_ReuseofComponentTypes_003() runs on GeneralComp system GeneralComp {
   
    var GeneralComp v_server := GeneralComp.create;
    
    connect(mtc:pt_myPortA, v_server:pt_myPortA);
    connect(mtc:pt_myPortB, v_server:pt_myPortB);
    
    v_server.start(loopback());
   
    //Set a value to MyInt:
    MyInt := 10;
        
    //Send an integer from pt_myPortA:
    pt_myPortA.send(2);
    alt {
      [] pt_myPortA.receive(2) {
        setverdict(pass,"Receive successful");
      }
      [] pt_myPortA.receive {
        setverdict(fail,"Unexpected result");
      }
    }
        
    //Send an integer from pt_myPortB:
    pt_myPortB.send(1.0);
    alt {
      [] pt_myPortB.receive(1.0) {
        setverdict(pass,"Receive successful");
      }
      [] pt_myPortB.receive {
        setverdict(fail,"Unexpected result");
      }
    }

  }

  control{
    execute(TC_Sem_060210_ReuseofComponentTypes_003());
  }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.2, Fields not mentioned are implicitly left unspecified.
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_0602_TopLevel_005 {
    type record MyRecord {
        integer field1,
        charstring field2 optional,
        float field3
    }
    const MyRecord c_rec := {
        field1 := 5,
        // field2 implicitly unspecified
        field3 := 3.14
    } with {
        optional "implicit omit"
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that value list notation can be used for an array. 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0602_TopLevel_011 {
    
    type component GeneralComp {
    }
    
    type integer MyArray [3];

    testcase TC_Sem_0602_TopLevel_011() runs on GeneralComp {

        var MyArray v_myArray := {1,2,3};

        if (v_myArray == {1,2,3}) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_0602_TopLevel_011());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that assignment notation can be used for a record of type. 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0602_TopLevel_002 {
    
    type component GeneralComp {
    }
    
    type record of integer MyRecordOf;

    testcase TC_Sem_0602_TopLevel_002() runs on GeneralComp {

        var MyRecordOf v_allRecords := {
            [0] := 1,
            [1] := 2,
            [2] := 3
        };

        if (v_allRecords=={1,2,3}) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_0602_TopLevel_002());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that value list notation can be used for a record type. 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0602_TopLevel_007 {
    
    type component GeneralComp {
    }
    
    type record MyRecord {
        integer field1,
        charstring field2 optional,
        float field3
    }

    testcase TC_Sem_0602_TopLevel_007() runs on GeneralComp {

        var MyRecord v_myRecord := {5,"hi", 3.14};

        if (v_myRecord=={5,"hi",3.14}) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_0602_TopLevel_007());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.2, constant definition of a record type. 
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_0602_TopLevel_004 {
    type record MyRecord {
    	integer field1,
        charstring field2 optional,
    	float field3
    }
    const MyRecord c_rec := { 5, "foo", 3.14 };
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that assignment notation can be used for a union type. 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0602_TopLevel_005 {
    
    type component GeneralComp {
    }
    
    type union MyUnion {
        integer field1,
        charstring field2,
        float field3
    }

    testcase TC_Sem_0602_TopLevel_005() runs on GeneralComp {

        var MyUnion v_myUnion := {
            field1 := 5
        };

        if (v_myUnion.field1 == 5) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_0602_TopLevel_005());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that assignment notation can be used for a set of type. 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0602_TopLevel_004 {
    
    type component GeneralComp {
    }
    
    type set of integer MySetOf;

    testcase TC_Sem_0602_TopLevel_004() runs on GeneralComp {

        var MySetOf v_allSets := {
            [0] := 1,
            [1] := 2,
            [2] := 3
        };

        if (v_allSets=={1,2,3}) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_0602_TopLevel_004());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that value list notation can be used for a set of type. 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0602_TopLevel_010 {
    
    type component GeneralComp {
    }
    
    type set of integer MySetOf;

    testcase TC_Sem_0602_TopLevel_010() runs on GeneralComp {

        var MySetOf v_allSets := {1,2,3};

        if (v_allSets=={1,2,3}) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_0602_TopLevel_010());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.2, Valid recursive record type definition
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_0602_TopLevel_002 {
    // In case of record and set types, to avoid infinite recursion, fields referencing to its own type, shall be optional.
    type record MyRecord {
    	integer field1,
        MyRecord field2 optional,
    	float field3
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.2, Valid recursive union type definition
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_0602_TopLevel_001 {
    // In case of union types, to avoid infinite recursion, at least one of the alternatives shall not reference its own type.
	type union MyUnion {
		MyUnion choice1,
        charstring choice2
	}
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that indexed notation can be used for a set of type. 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0602_TopLevel_013 {
    
    type component GeneralComp {
    }
    
    type set of integer MySetOf;

    testcase TC_Sem_0602_TopLevel_013() runs on GeneralComp {

        var MySetOf v_allSets := {1,2,3};
        var integer Integer1 :=3;
        v_allSets[0] := Integer1;
        Integer1 := v_allSets[1];

        if ( match(v_allSets, {3,2,3}) and match(Integer1, 2)) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_0602_TopLevel_013());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that indexed notation can be used for an arrays. 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0602_TopLevel_009 {
    
    type component GeneralComp {
    }
    
    type integer MyArray [3];

    testcase TC_Sem_0602_TopLevel_009() runs on GeneralComp {

        var MyArray v_myArray := {1,2,3};
        var integer Integer1 :=3;
        v_myArray[0] := Integer1;
        Integer1 := v_myArray[1];

        if ( match(v_myArray, {3,2,3}) and match(Integer1, 2)) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_0602_TopLevel_009());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that value list notation can be used for a record of type. 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0602_TopLevel_008 {
    
    type component GeneralComp {
    }
    
    type record of integer MyRecordOf;

    testcase TC_Sem_0602_TopLevel_008() runs on GeneralComp {

        var MyRecordOf v_allRecords := {1,2,3};

        if (v_allRecords=={1,2,3}) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_0602_TopLevel_008());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.2, Valid recursive record type definition
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_0602_TopLevel_003 {
    type record MyRecord {
    	integer field1,
        charstring field2 optional,
    	float field3
    }
    const MyRecord c_rec := {
        field1 := 5,
        field2 := "hi",
        field3 := 3.14
    };
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that assignment notation can be used for a record type. 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0602_TopLevel_001 {
    
    type component GeneralComp {
    }
    
    type record MyRecord {
        integer field1,
        charstring field2 optional,
        float field3
    }

    testcase TC_Sem_0602_TopLevel_001() runs on GeneralComp {

        var MyRecord v_myRecord := {
            field1 := 5,
            field2 := "hi",
            field3 := 3.14
        };

        if (v_myRecord=={5,"hi",3.14}) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_0602_TopLevel_001());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that assignment notation can be used for an array. 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0602_TopLevel_006 {
    
    type component GeneralComp {
    }
    
    type integer MyArray [3];

    testcase TC_Sem_0602_TopLevel_006() runs on GeneralComp {

        var MyArray v_myArray;
        v_myArray[0] := 1;
        v_myArray[1] := 2;
        v_myArray[2] := 3;

        if (v_myArray == {1,2,3}) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_0602_TopLevel_006());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that value list notation can be used for a set type and the values 
 **                  are assigned to the fields in the sequential order of the fields in the type definition. 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0602_TopLevel_014 {
    
    type component GeneralComp {
    }
    
    type set MySet {
        integer field1,
        charstring field2 optional,
        float field3
    }

    testcase TC_Sem_0602_TopLevel_014() runs on GeneralComp {

        var MySet v_mySet := {5,"hi",3.14};// SEE NOTE under 6.2.2

        if (v_mySet=={5,"hi",3.14}) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_0602_TopLevel_014());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that indexed notation can be used for a record of type. 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0602_TopLevel_012 {
    
    type component GeneralComp {
    }
    
    type record of integer MyRecordOf;

    testcase TC_Sem_0602_TopLevel_012() runs on GeneralComp {

        var MyRecordOf v_allRecords := {1,2,3};
        var integer Integer1 :=3;
        v_allRecords[0] := Integer1;
        Integer1 := v_allRecords[1];

        if ( match(v_allRecords, {3,2,3}) and match(Integer1, 2)) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_0602_TopLevel_012());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.2, Ensure that assignment notation can be used for a set type. 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0602_TopLevel_003 {
    
    type component GeneralComp {
    }
    
    type set MySet {
        integer field1,
        charstring field2 optional,
        float field3
    }

    testcase TC_Sem_0602_TopLevel_003() runs on GeneralComp {

        var MySet v_mySet := {
            field1 := 5,
            field2 := "hi",
            field3 := 3.14
        };

        if (v_mySet=={field1 := 5,
                      field2 := "hi",
                      field3 := 3.14}) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_0602_TopLevel_003());
    }
}/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:6.3.2, Ensure that the IUT correctly handles assignments from structures having compatible types and type ranges 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_060302_structured_types_001 { 

	type enumerated EnumeratedType {e_black, e_white};
	type EnumeratedType EnumeratedSynonym;

	type record RecordType { 
 	 integer  a(0..10) optional, 
 	 integer  b(0..10) optional, 
 	 boolean  c 
	} 
	type record ModifiedRecord { 
 	 integer  e 	   optional, 
 	 integer  f(0..5)  optional, 
 	 boolean  g 
	} 

	type set SetType { 
 	 integer  a(0..10) optional, 
 	 integer  b(0..10) optional, 
 	 boolean  c 
	} 
	type set ModifiedSet { 
 	 integer  e 	   optional, 
 	 integer  f(0..5)  optional, 
 	 boolean  g 
	} 

	type record of integer IntegerList(0..10);
	type record of integer ModifiedList;

	type set of integer IntegerUnorderedList(0..10);
	type set of integer ModifiedUnorderedList;

	type union UnionType { 
 	 integer  a(0..10), 
 	 EnumeratedType  b, 
 	 boolean  c 
	} 
	type union ModifiedUnion { 
 	 integer  a, 
 	 boolean  c, 
 	 EnumeratedSynonym  b 
	}


type component GeneralComp {	    	    
}	

testcase TC_Sem_060302_structured_types_001() runs on GeneralComp {

    var EnumeratedType v_enum1:=e_black;
    var EnumeratedSynonym v_enum2;
    var ModifiedRecord v_rec1:={f:=4,e:=8,g:=false};
    var RecordType v_rec2;
    var ModifiedSet v_set1:={f:=4,e:=8,g:=false};
    var SetType v_set2;
	var ModifiedList v_list1:={2,4,8};
	var IntegerList v_list2;
 	var ModifiedUnorderedList v_ulist1:={2,4,8};
	var IntegerUnorderedList v_ulist2;
	var ModifiedUnion v_union1:={a:=2};
	var UnionType v_union2;
    
    v_enum2:=v_enum1;
    v_rec2:=v_rec1;
    v_set2:=v_set1;
    v_list2:=v_list1;
    v_ulist2:=v_ulist1;
    v_union2:=v_union1;

    if (
     (v_enum2==e_black) and
     (v_rec2.a==8 and  v_rec2.b==4 and v_rec2.c==false) and 
     (v_set2.a==8 and  v_set2.b==4 and v_set2.c==false) and 
     (v_list2[0]==2 and v_list2[1]==4 and v_list2[2]==8) and 
     (v_ulist2[0]==2 and v_ulist2[1]==4 and v_ulist2[2]==8) and 
     (v_union2.a==2) 
    ) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}

control{
    execute(TC_Sem_060302_structured_types_001());
}

}
module Sem_060302_structured_types_004_importB { 
  type integer I (0..2); 
  type anytype Atype;
} 

module Sem_060302_structured_types_004_importA { 
  type integer I (0..2); 
  type float F; 
  type anytype Atype;
 } 


/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:6.3.2, Ensure that the IUT correctly handles assignments from structures having compatible anytypes 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_060302_structured_types_004 { 

 import from Sem_060302_structured_types_004_importA all; 
 import from Sem_060302_structured_types_004_importB all; 


type component GeneralComp {	    	    
}	

testcase TC_Sem_060302_structured_types_004() runs on GeneralComp {

   var Sem_060302_structured_types_004_importA.Atype v_a; 
   var Sem_060302_structured_types_004_importB.Atype v_b := { integer := 1 } 
    
   v_a:=v_b;
    
    if ( match(v_a.integer, 1) ) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}

control{
    execute(TC_Sem_060302_structured_types_004());
}

}


/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:6.3.2, Ensure that the IUT correctly handles assignments from structures having compatible types and lengths 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_060302_structured_types_002 language "TTCN-3:2010" {

    type record RecordType {
        integer  a,
        integer  b optional
    }

    type set SetType {
        integer  a,
        integer  b optional
    }

    type record length (1..2) of integer ShortIntegerList;
    type record of integer IntegerList;

    type set length (1..2) of integer ShortUnorderedIntegerList;
    type set of integer UnorderedIntegerList;


    type component GeneralComp {
    }

    testcase TC_Sem_060302_structured_types_002() runs on GeneralComp {
	
        var IntegerList v_list1:={1,-};
        var ShortIntegerList v_list2;
        var UnorderedIntegerList v_ulist1:={1,-};
        var ShortUnorderedIntegerList v_ulist2;

        var integer v_matcher[2] := {1,-};
	
        var boolean v_check;
    
        v_list2:=v_list1;
        v_ulist2:=v_ulist1;

        v_check := (v_list2[0]==1);

	
        if ( v_check )
        {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_060302_structured_types_002());
    }

}
/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:6.3.2, Ensure that the IUT correctly handles assignments from structures having compatible types and lengths 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_060302_structured_types_006 {

    type record RecordType {
        integer  a,
        integer  b optional
    }

    type set SetType {
        integer  a,
        integer  b optional
    }

    type record length (1..2) of integer ShortIntegerList;
    type record of integer IntegerList;

    type set length (1..2) of integer ShortUnorderedIntegerList;
    type set of integer UnorderedIntegerList;


    type component GeneralComp {
    }

    testcase TC_Sem_060302_structured_types_006() runs on GeneralComp {

        var IntegerList v_list1:={0,-};
        var ShortIntegerList v_list2;
        var RecordType v_rec1;
        var UnorderedIntegerList v_ulist1:={1,-};
        var ShortUnorderedIntegerList v_ulist2;
        var SetType v_set1;

        var integer v_matcher[2] := {1,-};
	
        var boolean v_check1;
    
        v_list1:=v_matcher;
        v_list2:=v_list1;


        v_check1 := (v_list2[0]==1);
	
        if ( v_check1 )
        {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_060302_structured_types_006());
    }

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:6.3.2, Ensure that the IUT correctly handles assignments from structures having compatible types and type ranges 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_060302_structured_types_003 { 


	type record RecordType { 
 	 integer  a(0..10) optional, 
 	 integer  b(0..10) optional, 
 	 boolean  c 
	} 

	type set SetType { 
 	 integer  a(0..10) optional, 
 	 integer  b(0..10) optional, 
 	 boolean  c 
	} 



type component GeneralComp {	    	    
}	

testcase TC_Sem_060302_structured_types_003() runs on GeneralComp {

    var RecordType v_rec1:={a:=4,b:=8,c:=false};
    var SetType v_set1;
    
    v_set1.a:=v_rec1.a;
    v_set1.b:=v_rec1.b;
    v_set1.c:=v_rec1.c;

    if (
     v_set1.a==4 and  v_set1.b==8 and v_set1.c==false
    ) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}

control{
    execute(TC_Sem_060302_structured_types_003());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:6.3.2, Ensure that the IUT correctly handles assignments from structures having compatible types and type ranges 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_060302_structured_types_005 { 


	type record RecordType { 
 	 integer  a(0..10) optional, 
 	 integer  b(0..10) optional, 
 	 boolean  c 
	} 
	
	type record of RecordType RecordList;



type component GeneralComp {	    	    
}	

testcase TC_Sem_060302_structured_types_005() runs on GeneralComp {

    var RecordList v_list;
    var RecordType v_record:={a:=1,b:=2,c:=false};
    var integer v_int;
    
    
    v_list:= {v_record,v_record};
    v_int:=v_list[1].b;
    
    if ( v_int==2 ) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}

control{
    execute(TC_Sem_060302_structured_types_005());
}

}
/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:6.3.1, Ensure that the IUT correctly handles assignments from compatible type ranges 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// charstring and universal charstring assigments
module Sem_060301_non_structured_types_003 { 
  
    type charstring ConstrainedChar ("a" .. "z");
    type universal charstring ConstrainedUChar (char(0, 0, 1, 111) .. char(0, 0, 1, 113));
   

type component GeneralComp {	    	    
}	

testcase TC_Sem_060301_non_structured_types_003() runs on GeneralComp {

   
    var charstring v_char := "jkl"; 
    var ConstrainedChar v_constrainedChar;
    var universal charstring v_uChar := char(0, 0, 1, 112);
    var ConstrainedUChar v_constrainedUChar;
  
    

    v_constrainedChar:=v_char;
    v_constrainedUChar:=v_uChar;

    if (
     (v_constrainedChar=="jkl") and
     (v_constrainedUChar==char(0, 0, 1, 112)))
	{
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}

control{
    execute(TC_Sem_060301_non_structured_types_003());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.2
 ** @purpose  1:6.3.1, Ensure that the IUT correctly handles assignments from compatible type ranges 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// integer and float assigments from compatible types.
module Sem_060301_non_structured_types_001 { 
    type integer ConstrainedInt(1..10);
    type float ConstrainedFloat(1.0 .. 1E1);

type component GeneralComp {	    	    
}	

testcase TC_Sem_060301_non_structured_types_001() runs on GeneralComp {

    var integer v_int:=5;
    var ConstrainedInt v_constrainedInt;
    var float v_float:=5.0;
    var ConstrainedFloat v_constrainedFloat;

    
    
    v_constrainedInt:=v_int;
    v_constrainedFloat:=v_float;


    if (
     (v_constrainedInt==5) and
     (v_constrainedFloat==5.0)
    ) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}

control{
    execute(TC_Sem_060301_non_structured_types_001());
}

}
/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:6.3.1, Ensure that the IUT correctly handles assignments from compatible type ranges 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// bitstring and hexstring assignments

module Sem_060301_non_structured_types_004 { 

    type bitstring ConstrainedBitString ('01'B, '10'B, '11'B);
    type hexstring ConstrainedHexString ('1A'H, '1B'H, '1C'H);

type component GeneralComp {	    	    
}	

testcase TC_Sem_060301_non_structured_types_004() runs on GeneralComp {

    var bitstring v_bitstr := '10'B; 
    var ConstrainedBitString v_constrainedBitstr;
    var hexstring v_hexstr := '1B'H; 
    var ConstrainedHexString v_constrainedHexstr;

    v_constrainedBitstr:=v_bitstr;
    v_constrainedHexstr:=v_hexstr;

    if (
     (v_constrainedBitstr=='10'B) and
     (v_constrainedHexstr=='1B'H) 
    ) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}

control{
    execute(TC_Sem_060301_non_structured_types_004());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:6.3.1, Ensure that the IUT correctly handles assignments from compatible size restrictions 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_060301_non_structured_types_002 { 
    type integer ConstrainedInt[1..2];
    type float ConstrainedFloat[1..2];
    type charstring ConstrainedChar length (1..2);
    type universal charstring ConstrainedUChar length (1..2);
    type bitstring ConstrainedBitString length (1..2);
    type hexstring ConstrainedHexString length (1..2);

type component GeneralComp {	    	    
}	
/**
 * @desc Equals method for floats
 * @return true if abs(f1 - f2) < 1.E-6
 */
function f_isFloatNear(in float f1, in float f2) return boolean {
  var float delta := f1-f2;
  if (delta < 0.0) {
    delta := 0.0 - delta;
  }
  return delta < 1E-6;
}

testcase TC_Sem_060301_non_structured_types_002() runs on GeneralComp {

    var integer v_int[2]:={5,4};
    var ConstrainedInt v_constrainedInt;
    var float v_float[2]:={5.0,4.0};
    var ConstrainedFloat v_constrainedFloat;
    var charstring v_char := "jk"; 
    var ConstrainedChar v_constrainedChar;
    var universal charstring v_uChar := char(0, 0, 1, 112);
    var ConstrainedUChar v_constrainedUChar;
    var bitstring v_bitstr := '10'B; 
    var ConstrainedBitString v_constrainedBitstr;
    var hexstring v_hexstr := '1B'H; 
    var ConstrainedHexString v_constrainedHexstr;
    
    
    v_constrainedInt:=v_int;
    v_constrainedFloat:=v_float;
    v_constrainedChar:=v_char;
    v_constrainedUChar:=v_uChar;
    v_constrainedBitstr:=v_bitstr;
    v_constrainedHexstr:=v_hexstr;

    if (
     (v_constrainedInt[1]==5) and
     (v_constrainedInt[2]==4) and
     (f_isFloatNear(v_constrainedFloat[1],5.0)) and
     (f_isFloatNear(v_constrainedFloat[2],4.0)) and
     (v_constrainedChar=="jk") and
     (v_constrainedUChar==char(0, 0, 1, 112)) and
     (v_constrainedBitstr=='10'B) and
     (v_constrainedHexstr=='1B'H) 
    ) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
}

control{
    execute(TC_Sem_060301_non_structured_types_002());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:6.3.3, Ensure that the IUT correctly handles assignments from structures having compatible components 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_060303_component_types_002 {

    type integer ConstrainedInteger(0..10);

    type component TestCaseComp {
        const integer c_integer:=2;
        const ConstrainedInteger c_constrained:=2;
    }

    type component FunctionComp {
        const integer c_integer:=2;
    }

    function f_testFunction(integer p_arg) runs on FunctionComp return integer {

        var integer v_result;
        v_result:=p_arg*c_integer;
        return v_result;
    }

    testcase TC_Sem_060303_component_types_002() runs on TestCaseComp {

        var integer v_int:=2;
        
        if ( f_testFunction(v_int)==4 ) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_060303_component_types_002());
    }

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:6.3.3, Ensure that the IUT correctly handles assignments from structures having compatible components 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_060303_component_types_001 {

    type integer ConstrainedInteger(0..10);

    type component TestCaseComp {
        const integer c_integer:=2;
        const ConstrainedInteger c_constrained:=2;
    }

    type component FunctionComp {
        const integer c_integer:=2;
        const ConstrainedInteger c_constrained:=2;
    }

    function f_testFunction(integer p_arg) runs on FunctionComp return integer {

        var integer v_result;
        v_result:=p_arg*c_integer*c_constrained;
        return v_result;
    }

    testcase TC_Sem_060303_component_types_001() runs on TestCaseComp {

        var integer v_int:=1;
        
        if ( f_testFunction(v_int)==4 ) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control {
        execute(TC_Sem_060303_component_types_001());
    }

}
/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign large integer values
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_060100_SimpleBasicTypes_002 {
    const integer c_i1 := 10000000000000; // large positive 10^13
	const integer c_i2 := -10000000000000; // large negative -10^13
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign and read large integer values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060100_SimpleBasicTypes_002 {

    const integer c_i := 50000000000000;
    
    type component GeneralComp {}
    
    testcase TC_Sem_610_SimpleBasicTypes_002() runs on GeneralComp {
    	if (c_i == 50000000000000){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_610_SimpleBasicTypes_002());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Accept all verdict values
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_060100_SimpleBasicTypes_006 {
    const verdicttype c_v1 := pass;
    const verdicttype c_v2 := fail;
    const verdicttype c_v4 := inconc;
    const verdicttype c_v5 := none;
    const verdicttype c_v6 := error;
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign different integer values
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_060100_SimpleBasicTypes_001 {
    const integer c_i1 := 0;
	const integer c_i2 := 1;
	const integer c_i3 := -5;
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Accept float mantisa for float values
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_060100_SimpleBasicTypes_005 {
    const float c_f1 := 2.0E2;
    const float c_f2 := -2.1E-1;
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign and read verdicts
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060100_SimpleBasicTypes_005 {

    const verdicttype c_v := inconc;
    
    type component GeneralComp {}
    
    testcase TC_Sem_610_SimpleBasicTypes_005() runs on GeneralComp {
    	if (c_v == inconc){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_610_SimpleBasicTypes_005());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign and read large float values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060100_SimpleBasicTypes_004 {

    const float c_f := 5.23E200;
    
    type component GeneralComp {}
    
    testcase TC_Sem_610_SimpleBasicTypes_004() runs on GeneralComp {
    	if (c_f > 1E200){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_610_SimpleBasicTypes_004());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign small and large float values
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_060100_SimpleBasicTypes_004 {
    const float c_f1 := 2E256; // large positive 2^256
    const float c_f2 := -2E256; // large negative -2^256
	const float c_f3 := 2E-256; // small positive 2^-256
	const float c_f4 := -2E-256; // small negative -2^256
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign and read integer values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060100_SimpleBasicTypes_001 {

    const integer c_i := 5;
    
    type component GeneralComp {}
    
    testcase TC_Sem_610_SimpleBasicTypes_001() runs on GeneralComp {
    	if (c_i == 5){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_610_SimpleBasicTypes_001());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign different float values
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_060100_SimpleBasicTypes_003 {
    const float c_f1 := 0.0;
	const float c_f2 := 131E57;
	const float c_f3 := 131E-57;
    const float c_f4 := -502E55;
	const float c_f5 := -502E-55;
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.0, Assign and read float values
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060100_SimpleBasicTypes_003 {

    const float c_f := 5.12E-5;
    
    type component GeneralComp {}
    
    testcase TC_Sem_610_SimpleBasicTypes_003() runs on GeneralComp {
    	if (c_f > 5E-5){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_610_SimpleBasicTypes_003());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign different octetstring values
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_060101_TopLevel_003 {
    const octetstring c_o1 := '00'O;
    const octetstring c_o2 := '1Fa3B5'O;
    const octetstring c_o3 := '07aDC4'O;
    const octetstring c_o4 := '000000000000000000000000'O;
    const octetstring c_o5 := 'FFFFFFFFFFFFFFFFFFFFFFFF'O;
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign and read octetstring
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060101_TopLevel_003 {

    const octetstring c_o := 'E1F30A'O;
    
    type component GeneralComp {}
    
    testcase TC_Sem_611_TopLevel_003() runs on GeneralComp {
    	if (c_o == 'e1f30a'O){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_611_TopLevel_003());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign different bitstring values
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_060101_TopLevel_001 {
    const bitstring c_b1 := '0'B;
    const bitstring c_b2 := '1'B;
    const bitstring c_b3 := '01001'B;
    const bitstring c_b4 := '000000000000000000000'B;
    const bitstring c_b5 := '111111111111111111111'B;
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign and read hexstring
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060101_TopLevel_002 {

    const hexstring c_h := 'E1F0A'H;
    
    type component GeneralComp {}
    
    testcase TC_Sem_611_TopLevel_002() runs on GeneralComp {
    	if (c_h == 'e1f0a'H){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_611_TopLevel_002());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign and read charstring
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060101_TopLevel_004 {

    const charstring c_s1 := "abcdef";
    const charstring c_s2 := "ab""cdef";
    
    type component GeneralComp {}
    
    testcase TC_Sem_611_TopLevel_004() runs on GeneralComp {
    	if (c_s1 == "abcdef"){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    	if (lengthof(c_s2) == 7){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_611_TopLevel_004());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign and read bitstring
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060101_TopLevel_001 {

    const bitstring c_b := '10001'B;
    
    type component GeneralComp {}
    
    testcase TC_Sem_611_TopLevel_001() runs on GeneralComp {
    	if (c_b == '10001'B){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_611_TopLevel_001());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign and read universal charstring
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060101_TopLevel_005 {

    const universal charstring c_s1 := char (0, 0, 40, 48) & char ( 0, 0, 1, 113);
    
    type component GeneralComp {}
    
    testcase TC_Sem_611_TopLevel_005() runs on GeneralComp {
    	if (lengthof(c_s1) == 2) {
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_611_TopLevel_005());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign and read universal charstring
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_060101_TopLevel_006 {

    const universal charstring c_s1 := "the Braille character " & char (0, 0, 40, 48) & "looks like this";
    
    type component GeneralComp {}
    
    testcase TC_Sem_611_TopLevel_006() runs on GeneralComp {
    	if (lengthof(c_s1) > 10) {
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_611_TopLevel_006());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign and read universal charstring using USI like notation
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 The UCS sequence identifier-like (USI-like) notation using their short identifiers of code point. The USI-like notation is composed of the keyword char followed by parentheses. The
parentheses enclose a comma-separated list of short identifiers . Each short identifier represents a single
character and it shall be composed of a letter U or u followed by an optional "+" PLUS SIGN character,
followed by 1..8 hexadecimal digits. 
*/

module Sem_060101_TopLevel_007 {
    
    type component GeneralComp {}
    
    testcase TC_Sem_060101_TopLevel_007() runs on GeneralComp {
        var universal charstring v_a  :=  char(U0041);  //USI notation for character "A"
        var universal charstring v_b  :=  char(U0171);  //USI notation for character ""
        var universal charstring v_c  :=  char(U41);    //USI notation for character "A" without leading zeroes
        var universal charstring v_d  :=  char(U+171,U41);  //USI notation for character "" and "A"  without leading zeroes and + sign notation

        
               
    	if (match(v_a,"A") and 
            match(v_b,"") and
            match(v_c,"A") and
            match(v_d,"A"))
        {
    		setverdict(pass,"v_a:",v_a, "v_b:",v_b, "v_c:",v_c,"v_d:",v_d);
    	}
    	else {
    		setverdict(fail,"v_a:",v_a, "v_b:",v_b, "v_c:",v_c,"v_d:",v_d);
    	}
    }
    
    control{
        execute(TC_Sem_060101_TopLevel_007());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1, Assign different hexstring values
 ** @verdict  pass accept, noexecution
 ***************************************************/
module Syn_060101_TopLevel_002 {
    const hexstring c_h1 := '0'H;
    const hexstring c_h2 := '1FaB5'H;
    const hexstring c_h3 := '07aDC4'H;
    const hexstring c_h4 := '0000000000000000000000000'H;
    const hexstring c_h5 := 'FFFFFFFFFFFFFFFFFFFFFFFFF'H;
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1.1, Access octetstring elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010101_AccessStringElements_002 {
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010101_AccessStringElements_002() runs on GeneralComp {
        var octetstring v_b := '100010'O;
        v_b[2] := '01'O;
    	if (v_b == '100001'O){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_06010101_AccessStringElements_002());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1.1, Access hexstring elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010101_AccessStringElements_005 {
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010101_AccessStringElements_005() runs on GeneralComp {
        var hexstring v_b := '00000'H;
        v_b[0] := '1'H;
        v_b[1] := '0'H;
        v_b[2] := '1'H;
        v_b[3] := '0'H;
        v_b[4] := '1'H;
    	if (v_b == '10101'H){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_06010101_AccessStringElements_005());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1.1, Access bitstring elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010101_AccessStringElements_004 {
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010101_AccessStringElements_004() runs on GeneralComp {
        var bitstring v_b := ''B;
        v_b[0] := '1'B;
        v_b[1] := '0'B;
        v_b[2] := '1'B;
        v_b[3] := '0'B;
        v_b[4] := '1'B;
    	if (v_b == '10101'B){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_06010101_AccessStringElements_004());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1.1, Access bitstring elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010101_AccessStringElements_001 {
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010101_AccessStringElements_001() runs on GeneralComp {
        var bitstring v_b := '10001'B;
        v_b[2] := '1'B;
    	if (v_b == '10101'B){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_06010101_AccessStringElements_001());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1.1, Access charstring elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010101_AccessStringElements_008 {
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010101_AccessStringElements_008() runs on GeneralComp {
        var universal charstring v_b := char (0, 0, 40, 20);
        v_b[0] := "d";
    	if (v_b[0] == "d"){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_06010101_AccessStringElements_008());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1.1, Access hexstring elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010101_AccessStringElements_003 {
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010101_AccessStringElements_003() runs on GeneralComp {
        var hexstring v_b := '10001'H;
        v_b[2] := '1'H;
    	if (v_b == '10101'H){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_06010101_AccessStringElements_003());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1.1, Access octetstring elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010101_AccessStringElements_006 {
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010101_AccessStringElements_006() runs on GeneralComp {
        var octetstring v_b := ''O;
        v_b[0] := '10'O;
        v_b[1] := '01'O;
    	if (v_b == '1001'O){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_06010101_AccessStringElements_006());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.1.1.1, Access charstring elements with non printable characters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010101_AccessStringElements_009 {
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010101_AccessStringElements_009() runs on GeneralComp {
        var universal charstring v_b := char (0, 0, 1, 116);
       
		
    	if (v_b == "" ){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_06010101_AccessStringElements_009());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.1.1, Access charstring elements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010101_AccessStringElements_007 {
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010101_AccessStringElements_007() runs on GeneralComp {
        var charstring v_b := "abc";
        v_b[2] := "d";
    	if (v_b == "abd"){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_06010101_AccessStringElements_007());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.1.2.5, Assign values to pattern restricted character strings with @nocase modifier.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
When the "@nocase" modifier is used after the pattern keyword, the matching is evaluated in a case insensitive way.
*/

module Sem_06010205_StringPattern_003 {
    type charstring MyString (pattern @nocase "abc*xyz"); // with @nocase modifier now characters from "A...Z" is also allowed 

    type component GeneralComp {}
    
    testcase TC_Sem_06010205_StringPattern_003() runs on GeneralComp {
        
        var MyString v_c;
        
        //valid:
        v_c := "ABc1234xyz";
        v_c := "aBC:xYz";
        v_c := "AbC.xyZ";
        v_c := "ABc*xYZ";
        v_c := "ABC?XYZ";
		setverdict(pass,"The resuls is: ",v_c);
    }
    
    control{
        execute(TC_Sem_06010205_StringPattern_003());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.5, Assign values to pattern restricted character strings.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010205_StringPattern_002 {
    type charstring MyString (pattern "abc?xyz");

    type component GeneralComp {}
    
    testcase TC_Sem_06010205_StringPattern_002() runs on GeneralComp {
        var MyString v_c;
        v_c := "abc1xyz";
        v_c := "abc:xyz";
        v_c := "abc.xyz";
        v_c := "abc*xyz";
        v_c := "abc?xyz";
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010205_StringPattern_002());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.5, Assign values to pattern restricted character strings.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010205_StringPattern_001 {
    type charstring MyString (pattern "abc*xyz");

    type component GeneralComp {}
    
    testcase TC_Sem_06010205_StringPattern_001() runs on GeneralComp {
        var MyString v_c;
        v_c := "abcxyz";
        v_c := "abc123xyz";
        v_c := "abc:xyz";
        v_c := "abc...xyz";
        v_c := "abc*xyz";
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010205_StringPattern_001());
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign values to range restricted universal charstring.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010203_Ranges_007 {
    type universal charstring MyUCharString (char(0, 0, 1, 111) .. char(0, 0, 1, 113));
        
    type component GeneralComp {}
    
    testcase TC_Sem_06010203_Ranges_007() runs on GeneralComp {
        var MyUCharString v_uc1;
        v_uc1 := char(0, 0, 1, 111);
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010203_Ranges_007());
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign values to range restricted cahrstring with mixed bounds.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010203_Ranges_006 {
    type charstring MyCahrstringRange (!"a".."f");
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010203_Ranges_006() runs on GeneralComp {
        var MyCahrstringRange v_c1;
        v_c1 := "b";
        v_c1 := "c";
        v_c1 := "d";
        v_c1 := "e";
        v_c1 := "f";
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010203_Ranges_006());
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign values to range restricted cahrstring with exclusive bounds.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010203_Ranges_005 {
    type charstring MyCharstringRange (!"a"..!"f");
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010203_Ranges_005() runs on GeneralComp {
        var MyCharstringRange v_c1;
        v_c1 := "b";
        v_c1 := "c";
        v_c1 := "d";
        v_c1 := "e";
        v_c1 := "bcde";
        v_c1 := "bbeeebccdee";
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010203_Ranges_005());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign values to range restricted integer.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010203_Ranges_001 {
    type integer MyIntegerRange (0 .. 255);
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010203_Ranges_001() runs on GeneralComp {
        var MyIntegerRange v_i;
        v_i := 0;
        v_i := 100;
        v_i := 255;
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010203_Ranges_001());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign values to infinity range restricted integer.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010203_Ranges_002 {
    type integer MyIntegerRange1 (-infinity .. 0);
    type integer MyIntegerRange2 (0 .. infinity);
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010203_Ranges_002() runs on GeneralComp {
        var MyIntegerRange1 v_i1;
        var MyIntegerRange2 v_i2;
        v_i1 := 0;
        v_i1 := -100;
        v_i1 := -200000;
        v_i2 := 0;
        v_i2 := 100;
        v_i2 := 200000;
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010203_Ranges_002());
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign values to range restricted universal charstring with mixed bounds.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010203_Ranges_008 {
	//  Defines a string type of any length with each character within the range (111 or 112)
    type universal charstring MyUCharString (char(0, 0, 1, 111) .. !char(0, 0, 1, 113));
        
    type component GeneralComp {}
    
    testcase TC_Sem_06010203_Ranges_008() runs on GeneralComp {
        var MyUCharString v_uc1;
        v_uc1 := char(0, 0, 1, 111);
        v_uc1 := char(0, 0, 1, 112);
        v_uc1 := char(0, 0, 1, 112) & char(0, 0, 1, 112);
        v_uc1 := char(0, 0, 1, 112) & char(0, 0, 1, 111) & char(0, 0, 1, 112);
        setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010203_Ranges_008());
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign values to range restricted cahrstring with inclusive bounds.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010203_Ranges_004 {
    type charstring MyCharstringRange ("a".."f");
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010203_Ranges_004() runs on GeneralComp {
        var MyCharstringRange v_c1;
        v_c1 := "a";
        v_c1 := "c";
        v_c1 := "f";
        v_c1 := "acdef";
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010203_Ranges_004());
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:6.1.2.3, Assign values to range restricted integer with exclusive bounds.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010203_Ranges_003 {
    type integer MyIntegerRange1 (!0 .. 255);
    type integer MyIntegerRange2 (0 .. !255);
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010203_Ranges_003() runs on GeneralComp {
        var MyIntegerRange1 v_i1;
        var MyIntegerRange2 v_i2;
        v_i1 := 1; // 0 not allowed
        v_i1 := 100;
        v_i1 := 255;
        v_i2 := 0;
        v_i2 := 100;
        v_i2 := 254; // 255 not allowed
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010203_Ranges_003());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.2, Assign values to mixed restricted bit strings.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0601020602_StringMixing_004 {
    type bitstring MyString ('111'B, '101010'B, '111111'B) length (3 .. 8);

    type component GeneralComp {}
    
    testcase TC_Sem_0601020602_StringMixing_004() runs on GeneralComp {
        var MyString v_c;
        v_c := '111'B;
        v_c := '101010'B;
        v_c := '111111'B;
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_0601020602_StringMixing_004());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.2, Assign values to mixed restricted character strings.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0601020602_StringMixing_003 {
    type charstring MyString ("abcdef", "abc", "123abc") length (3 .. 8);

    type component GeneralComp {}
    
    testcase TC_Sem_0601020602_StringMixing_003() runs on GeneralComp {
        var MyString v_c;
        v_c := "123abc";
        v_c := "abc";
        v_c := "abcdef";
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_0601020602_StringMixing_003());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.2, Assign values to mixed restricted character strings.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0601020602_StringMixing_001 {
    type charstring MyString (pattern "abc*xyz") length (5 .. 8);

    type component GeneralComp {}
    
    testcase TC_Sem_0601020602_StringMixing_001() runs on GeneralComp {
        var MyString v_c;
        v_c := "abcxyz";
        v_c := "abc12xyz";
        v_c := "abc:xyz";
        v_c := "abc..xyz";
        v_c := "abc*xyz";
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_0601020602_StringMixing_001());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.2, Assign values to pattern restricted character strings using @nocase modifier
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
When the "@nocase" modifier is used after the pattern keyword, the matching is evaluated in a case insensitive way
*/

module Sem_0601020602_StringMixing_007 {
    type charstring unicharString (pattern "[a-z]#(1,5)") length (1..5); // charstring between "a".."z" and length from 1 to 5
    type charstring unicharString_nocase (pattern @nocase "[a-z]#(1,5)") length (1..5); // with @nocase modifier now characters from "A...Z" is also allowed 

    type component GeneralComp {}
    
    testcase TC_Sem_0601020602_StringMixing_007() runs on GeneralComp {
        var unicharString v_a;        //without @nocase modifier
        var unicharString_nocase v_b; //with @nocase modifier
        v_a :="abxyz";
        v_b :=v_a;        //v_b :="abxyz";
        v_b :="AbXyZ";      

      	setverdict(pass,"The result is: ",v_b);
    }
    
    control{
        execute(TC_Sem_0601020602_StringMixing_007());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.2, Assign values to mixed restricted hex strings.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0601020602_StringMixing_005 {
    type hexstring MyString ('1F1'H, '103A10'H, '111111'H) length (3 .. 8);

    type component GeneralComp {}
    
    testcase TC_Sem_0601020602_StringMixing_005() runs on GeneralComp {
        var MyString v_c;
        v_c := '1F1'H;
        v_c := '103A10'H;
        v_c := '111111'H;
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_0601020602_StringMixing_005());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.2, Assign values to mixed restricted character strings.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0601020602_StringMixing_002 {
    type charstring MyString ("a".."z") length (3 .. 8);

    type component GeneralComp {}
    
    testcase TC_Sem_0601020602_StringMixing_002() runs on GeneralComp {
        var template MyString v_c;
        v_c := "abc";
        v_c := "abcdefgh";
        v_c := pattern "abc?def";
        v_c := pattern "abc*xyz";
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_0601020602_StringMixing_002());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.2, Assign values to mixed restricted octet strings.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0601020602_StringMixing_006 {
    type octetstring MyString ('FF1111'O, '101010A3'O, 'FFFFFFFFFF'O) length (3 .. 8);

    type component GeneralComp {}
    
    testcase TC_Sem_0601020602_StringMixing_006() runs on GeneralComp {
        var MyString v_c;
        v_c := 'FF1111'O;
        v_c := '101010A3'O;
        v_c := 'FFFFFFFFFF'O;
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_0601020602_StringMixing_006());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.1, Assign values to mixed restricted integers.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0601020601_MixingSubtype_002 {
    type integer MyInt (1, 5, 10, 100 .. infinity);

    type component GeneralComp {}
    
    testcase TC_Sem_0601020601_MixingSubtype_002() runs on GeneralComp {
        var MyInt v_i;
        v_i := 1;
        v_i := 5;
        v_i := 10;
        v_i := 100;
        v_i := 1000;
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_0601020601_MixingSubtype_002());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.6.1, Assign values to mixed restricted floats.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_0601020601_MixingSubtype_001 {
    type float lessThanPiAndNaN (-infinity .. 3142E-3, not_a_number);

    type component GeneralComp {}
    
    testcase TC_Sem_0601020601_MixingSubtype_001() runs on GeneralComp {
        var lessThanPiAndNaN v_f;
        v_f := 3.14E0;
        v_f := 0.0;
        v_f := -4E40;
        v_f := not_a_number;
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_0601020601_MixingSubtype_001());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.1.2.4, Assign values to list of types restricted charstring.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010204_StringLenghtRestrict_004 {
    type charstring myStrings1 length(2 .. 4); //length between 2 and 4 characters
    type charstring myStrings2 length(4); //fixed length 4 characters
    type charstring myStrings3 length(0 .. infinity); //unlimited character length

    type component GeneralComp {}
    
    testcase TC_Sem_06010204_StringLenghtRestrict_004() runs on GeneralComp {
        var myStrings1 v_b1;
        var myStrings2 v_b2;
        var myStrings3 v_b3;
        v_b1 := "ab";	//2 characters
        v_b1 := "abc";	//3 characters 
        v_b2 := "efgh";	//fixed 4 characters
        v_b3 := "abcdefghijklm";	//unlimited
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010204_StringLenghtRestrict_004());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.4, Assign values to list of types restricted bitstring.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010204_StringLenghtRestrict_001 {
    type bitstring BitStrings1 length(1 .. 2);
    type bitstring BitStrings2 length(5);
    type bitstring BitStrings3 length(0 .. infinity);

    type component GeneralComp {}
    
    testcase TC_Sem_06010204_StringLenghtRestrict_001() runs on GeneralComp {
        var BitStrings1 v_b1;
        var BitStrings2 v_b2;
        var BitStrings3 v_b3;
        v_b1 := '10'B;
        v_b1 := '1'B;
        v_b2 := '10000'B;
        v_b3 := '111111'B;
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010204_StringLenghtRestrict_001());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.1.2.4, Assign values to list of types restricted hexstring.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010204_StringLenghtRestrict_002 {
    type hexstring HexStrings1 length(1 .. 2);
    type hexstring HexStrings2 length(4);
    type hexstring HexStrings3 length(0 .. infinity);

    type component GeneralComp {}
    
    testcase TC_Sem_06010204_StringLenghtRestrict_002() runs on GeneralComp {
        var HexStrings1 v_b1;
        var HexStrings2 v_b2;
        var HexStrings3 v_b3;
        v_b1 := 'F'H;
        v_b1 := 'FE'H;
        v_b2 := 'FE80'H;
        v_b3 := 'FFFFFFFFFF'H;
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010204_StringLenghtRestrict_002());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.1.2.4, Assign values to list of types restricted octetstring.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010204_StringLenghtRestrict_003 {
    type octetstring ocStrings1 length(2 .. 4);
    type octetstring ocStrings2 length(4);
    type octetstring ocStrings3 length(0 .. infinity);

    type component GeneralComp {}
    
    testcase TC_Sem_06010204_StringLenghtRestrict_003() runs on GeneralComp {
        var ocStrings1 v_b1;
        var ocStrings2 v_b2;
        var ocStrings3 v_b3;
        v_b1 := 'FE80'O;	//2 octets
        v_b1 := 'FE8001'O;	//3 octets
        v_b2 := 'FE800201'O;	//4 octets
        v_b3 := 'FE830043'O;	//4 octets
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010204_StringLenghtRestrict_003());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign values to list of types restricted boolean value.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010202_ListOfTypes_008 {
    type boolean MyBoolean1 (false,true);	

    
    type component GeneralComp {}
    
    testcase TC_Sem_06010202_ListOfTypes_008() runs on GeneralComp {
        var MyBoolean1 v_b;
        v_b := false;
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010202_ListOfTypes_008());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign values to list of types unicharstring allows non-printable characters
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010202_ListOfTypes_005 {
  type universal charstring unicharString1 ("0" .. "9","A".."Z"); // charstring between "0" and "9" and "A".."Z"
  type universal charstring unicharString2 ("a".."z"); // charstring between "a" to "z" 
  type universal charstring unicharStrings_1_2 (unicharString1, unicharString2);
    type component GeneralComp {}
    
    testcase TC_Sem_06010202_ListOfTypes_006() runs on GeneralComp {
        var unicharStrings_1_2 v_b;
        v_b :="5";
        v_b :="H";
        v_b:="j";
      	setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010202_ListOfTypes_006());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign values to list of types restricted hexstring.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010202_ListOfTypes_002 {
    type hexstring HexStrings1 ('FE80'H, '01'H );
    type hexstring HexStrings2 ('00'H, '7F'H, 'B8'H, 'A0'H);
    type hexstring HexStrings_1_2 (HexStrings1, HexStrings2);
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010202_ListOfTypes_002() runs on GeneralComp {
        var HexStrings_1_2 v_b;
        v_b := 'FE80'H;	 //FE80 value is defined by the type HexStrings1
        v_b := '7F'H;	//7F value is defined by the type HexStrings2
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010202_ListOfTypes_002());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign values to list of types restricted bitstring.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010202_ListOfTypes_001 {
    type bitstring BitStrings1 ('0'B, '1'B );
    type bitstring BitStrings2 ('00'B, '01'B, '10'B, '11'B);
    type bitstring BitStrings_1_2 (BitStrings1, BitStrings2);
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010202_ListOfTypes_001() runs on GeneralComp {
        var BitStrings_1_2 v_b;
        v_b := '10'B;
        v_b := '1'B;
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010202_ListOfTypes_001());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign values to list of types restricted floats.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010202_ListOfTypes_007 {
    type float Float1 (1.0E0..9E0);	//float values between 1 and 9
    type float Float2 (2.0E1..3.0E1);	//float values between 20 and 30
    type float Float_1_2 (Float1, Float2);
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010202_ListOfTypes_007() runs on GeneralComp {
        var Float_1_2 v_b;
        v_b := 5.5E0;	//5.5 is between 1 and 9
        v_b := 2.55E1;	//25.5 is between 20 and 30
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010202_ListOfTypes_007());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign values to list of types restricted octetstring.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010202_ListOfTypes_003 {
    type octetstring Firstoctetstrings('0036'O,'0050'O); //30 and 40 in decimal
    type octetstring Secondtoctetstrings ('0074'O,'0120'O); //50 and 60 in decimal
    type octetstring octetStrings_1_2 (Firstoctetstrings, Secondtoctetstrings);
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010202_ListOfTypes_003() runs on GeneralComp {
        var octetStrings_1_2 v_b;
        v_b := '0074'O;	 // '0074'O value is defined by the type Secondtoctetstrings
        v_b := '0050'O;	//'0050'O value is defined by the type Firstoctetstrings
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010202_ListOfTypes_003());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign values to list of types restricted charstring.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010202_ListOfTypes_004 {
    type charstring Firstcharstrings("abc", "def"); 
    type charstring Secondcharstrings("ghi", "jkl"); 
    type charstring charStrings_1_2 (Firstcharstrings,Secondcharstrings);
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010202_ListOfTypes_004() runs on GeneralComp {
        var charStrings_1_2 v_b;
        v_b := "abc";
        v_b := "jkl";	
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010202_ListOfTypes_004());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign values to list of types restricted integers.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010202_ListOfTypes_006 {
    type integer Integer1 (0..9 );
    type integer Integer2 (20..30);
    type integer Integer_1_2 (Integer1, Integer2);
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010202_ListOfTypes_006() runs on GeneralComp {
        var Integer_1_2 v_b;
        v_b := 5;
        v_b := 25;
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010202_ListOfTypes_006());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:6.1.2.2, Assign values to list of types restricted verdicttype.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010202_ListOfTypes_009 {
    type verdicttype Myverdict1 (pass, error);	//only "pass" and "error" values are listed
	type verdicttype Myverdict2 (inconc, none);	//only "inconc" and "none" values are listed
    type verdicttype Myverdict_1_2 (Myverdict1, Myverdict2);
    
    
    type component GeneralComp {}
    
    testcase TC_Sem_06010202_ListOfTypes_009() runs on GeneralComp {
        var Myverdict_1_2 v_b;
        v_b := pass;
        v_b := none;
		setverdict(pass);
    }
    
    control{
        execute(TC_Sem_06010202_ListOfTypes_009());
    }
}/***************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:6.1.2.1, Assign invalid values to restricted bitstring.
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_06010201_ListOfValues_001 {
    type bitstring MyListOfBitStrings ('01'B, '10'B, '11'B);

    type component GeneralComp {}
    
    testcase TC_Sem_06010201_ListOfValues_001() runs on GeneralComp {
        var MyListOfBitStrings v_b := '10'B;
    	if (v_b == '10'B){
    		setverdict(pass);
    	}
    	else {
    		setverdict(fail);
    	}
    }
    
    control{
        execute(TC_Sem_06010201_ListOfValues_001());
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer can be declared in module control parts
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer can be declared in module control, test cases, functions, altsteps
 **/


module Sem_12_toplevel_timer_002 {
    type component TComp{
    }
    testcase TC_Sem_12_toplevel_timer_002(verdicttype v_verdict) runs on TComp{
        setverdict(v_verdict);
    }
    control{
        timer t_timer:=10.0;
        t_timer.start;
        if (t_timer.running){
            execute(TC_Sem_12_toplevel_timer_002(pass))
        }
        else{
            execute(TC_Sem_12_toplevel_timer_002(fail))
        }
        
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure non-initialized timer declaration syntax
 ** @verdict  pass accept, noexecution
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module Syn_12_toplevel_timer_001 {
    type component TComp{
        timer t_timer; 
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer can be declared in components but used in functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timers can be declared in component and used in test cases, functions, altsteps on this component
 **/


module Sem_12_toplevel_timer_008 {
    type component TComp{
        timer t_timer:=10.0;
    }
    function func() runs on TComp 
    {
        
        t_timer.start;
        if (t_timer.running){
            setverdict( pass );
        }
        else {
            setverdict( fail );
        }
        
    }
    testcase TC_Sem_12_toplevel_timer_008() runs on TComp{
        func();
    }
    control{
       execute(TC_Sem_12_toplevel_timer_008())
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer declaration with expression
 ** @verdict  pass accept, noexecution
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module Syn_12_toplevel_timer_006 {
    control {
        var anytype v_any := { float := 1.0 };
        timer t_timer := v_any.float; 
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure definition of a list of timers is allowed as a single declaration
 ** @verdict  pass accept, noexecution
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module Syn_12_toplevel_timer_003 {
    type component TComp{
        timer t_timer1, t_timer2 := 2.0, t_timer_array1[5], t_timer_array2[3] := {0.0, 1.0, 2.0}; 
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer can be declared in components
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timers can be declared in component type
 **/


module Sem_12_toplevel_timer_001 {
    type component TComp{
    	timer t_timer:=10.0;
    }
    testcase TC_Sem_12_toplevel_timer_001() runs on TComp{
        t_timer.start;
        if (t_timer.running){
            setverdict(pass)
        }
        else {
            setverdict(fail)
        }
    }
    control{
        execute(TC_Sem_12_toplevel_timer_001())
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer can be declared in test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer can be declared in module control, test cases, functions, altsteps
 **/


module Sem_12_toplevel_timer_005 {
    type component TComp{
    }
    testcase TC_Sem_12_toplevel_timer_005() runs on TComp{
        timer t_timer:=10.0;
        t_timer.start;
        if (t_timer.running){
            setverdict(pass);
        }
        else{
            setverdict(fail);
        }   
    }
    control{
       execute(TC_Sem_12_toplevel_timer_005())
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer can be declared in altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer can be declared in module control, test cases, functions, altsteps
 **/


module Sem_12_toplevel_timer_003 {
    type component TComp{
        timer aux_t;
    }
    altstep a_step () runs on TComp{
                   timer t_timer:=3.0;
                   [] aux_t.timeout{
                       t_timer.start;
                       if (t_timer.running){
                           setverdict(pass);
                           stop;
                       }
                       else{
                           setverdict(fail);
                           stop;
                       }
                       t_timer.stop;
                   }
                   
    };
    testcase TC_Sem_12_toplevel_timer_003() runs on TComp{
        aux_t.start(0.0);
        a_step();
    }
    control{
       execute(TC_Sem_12_toplevel_timer_003())
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer can be declared in components but used in test cases
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timers can be declared in component and used in test cases, functions, altsteps on this component
 **/


module Sem_12_toplevel_timer_007 {
    type component TComp{
        timer t_timer:=10.0;
    }
    testcase TC_Sem_12_toplevel_timer_007() runs on TComp{
        
        t_timer.start;
        if (t_timer.running){
            setverdict(pass);
        }
        else{
            setverdict(fail);
        }   
    }
    control{
       execute(TC_Sem_12_toplevel_timer_007())
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer can be declared in functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer can be declared in module control, test cases, functions, altsteps
 **/


module Sem_12_toplevel_timer_004 {
    type component TComp{
    }
    function func()
    {
        timer t_timer:=10.0;
        t_timer.start;
        if (t_timer.running){
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
        
    }
    testcase TC_Sem_12_toplevel_timer_004() runs on TComp{
        func();
    }
    control{
       execute(TC_Sem_12_toplevel_timer_004())
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer declaration with expression
 ** @verdict  pass accept, noexecution
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module Syn_12_toplevel_timer_005 {
    function one() return float
    {
        return 1.0;
    }
    control {
        timer t_timer := one(); 
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer can be declared in components but used in altsteps
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timers can be declared in component and used in test cases, functions, altsteps on this component
 **/


module Sem_12_toplevel_timer_009 {
    type component TComp{
        timer aux_t;
        timer t_timer:=10.0;
    }
    altstep a_step () runs on TComp{
                   
                   [] aux_t.timeout{
                       t_timer.start;
                       if (t_timer.running){
                           setverdict(pass);
                       }
                       else{
                           setverdict(fail);
                       }
                   }
                   
    };
    testcase TC_Sem_12_toplevel_timer_009() runs on TComp{
        aux_t.start(0.0);
        a_step();
    }
    control{
       execute(TC_Sem_12_toplevel_timer_009())
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer array declaration syntax
 ** @verdict  pass accept, noexecution
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer declaration syntax
 **/


module Syn_12_toplevel_timer_002 {
    type component TComp{
        timer t_timer[5]; 
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer array initialization syntax
 ** @verdict  pass accept, noexecution
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/timer array values are non-neg float or minus
 **/


module Syn_12_toplevel_timer_004 {
    type component TComp{
        timer t_timer[5] := {1.0, -, 1.0, 1.0, 1.0}; 
    }
}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:12, Ensure timer`s elapsed time is plausible
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
/*
 * #reqname  /Requirements/12 Declaring timers/Timer value is non-neg float
 **/


module Sem_12_toplevel_timer_006 {
    type component TComp{
        timer t_timer1:=1.05;
        timer t_timer2:=1.0;
        timer t_timer3:=0.95;
    }
    altstep a_step() runs on TComp{
                []t_timer2.timeout{
                    if (match(t_timer3.running, false) and t_timer1.running){
                        setverdict(pass);
                    }
                    else {
                        setverdict(fail);
                    }
                }
                []t_timer1.timeout{
                    setverdict(fail);
                }
            }
    testcase TC_Sem_12_toplevel_timer_006() runs on TComp{
        
        t_timer1.start;
        t_timer2.start;
        t_timer3.start;
        a_step();
        
    }    
    control{
       execute(TC_Sem_12_toplevel_timer_006())
    }
}/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.3, Ensure that the IUT properly evaluates invocation of testcases with system clause
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Syn_1603_testcases_001 {
	
type component GeneralComp {	
}
	
testcase TC_Syn_1603_testcases_001 () runs on GeneralComp system GeneralComp {

 setverdict(pass);
}


control{

    execute(TC_Syn_1603_testcases_001());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.2.1, Ensure that the IUT recognizes altstep definitions and correctly evaluates them
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_160201_invoking_altsteps_002 {

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2
	}

    type port loopbackPort message {
	  inout MessageType
	}

	type component GeneralComp {	    	    
	  port loopbackPort messagePort
	}	

	
altstep AltSet1() runs on GeneralComp { 
  
     [] messagePort.check {
        setverdict(inconc);
     }
     
}

altstep AltSet2() runs on GeneralComp { 
  
     [] messagePort.receive {
        setverdict(pass);
     }
     
}

testcase TC_Sem_160201_invoking_altsteps_002 () runs on GeneralComp {
 var MessageType v_testMessage;
 timer t_timer;
 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string"
 } 

 messagePort.send(v_testMessage);
 t_timer.start( 1.0 );

 alt {
  [] AltSet2();
  [] AltSet1();		//evaluation of sequential altstep activations
  [] t_timer.timeout {
        setverdict(fail);
     }
 }
 
}

control{

    execute(TC_Sem_160201_invoking_altsteps_002());

}

}
/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:16.2.1, Ensure that altsteps  are correctly handled for dynamically mapped ports
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// Mycompport A is dynamically mapped
module Sem_160201_invoking_altsteps_003{ 

    type port loopbackPort message {
	  inout integer
	}
		
	type port IntegerOutputPortType message {
	  inout integer
	}
	
type component GeneralComp
	{
	
		port IntegerOutputPortType MycomportA
	}

type component MyTestSystemInterface
	{
 		port loopbackPort messagePort
	}
	
altstep AltStep1() runs on GeneralComp { 
  
     [] MycomportA.receive {
     }
}
	
	
// MyTestSystemInterface is the test system interface
testcase TC_Sem_160201_invoking_altsteps_003() runs on GeneralComp system MyTestSystemInterface {
 timer tc_timer := 1.0;
 map(mtc:MycomportA, system:messagePort);


 MycomportA.send(2);
 tc_timer.start;
 unmap(mtc:MycomportA);
 setverdict(pass);

    alt {
     [] AltStep1();
     [] tc_timer.timeout {
        setverdict(pass);
     }
    }
}
control{
    execute(TC_Sem_160201_invoking_altsteps_003());
}
}/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.2.1, Ensure that the IUT recognizes altstep definitions and correctly evaluates them
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160201_invoking_altsteps_001 {

	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2
	}

    type port loopbackPort message {
	  inout MessageType
	}

	type component GeneralComp {	    	    
	  port loopbackPort messagePort
	}	


	
altstep AltSet1() runs on GeneralComp { 
  
     [] messagePort.receive {
        setverdict(pass);
     }
     
}

testcase TC_Sem_160201_invoking_altsteps_001 () runs on GeneralComp {
 var MessageType v_testMessage;
 timer t_timer;
 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string"
 } 

 messagePort.send(v_testMessage);
 t_timer.start( 1.0 );

 alt {
  [] AltSet1();
  [] t_timer.timeout {
        setverdict(pass);
     }
 }
 
}

control{

    execute(TC_Sem_160201_invoking_altsteps_001());

}

}
/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:16.2.1, Ensure that altsteps  are correctly handled for dynamically mapped ports
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// Mycompport A is dynamically mapped
module Sem_160201_invoking_altsteps_004{ 

    type port loopbackPort message {
	  inout integer
	}
		
	type port IntegerOutputPortType message {
	  inout integer
	}
	
type component GeneralComp
	{
      timer tc_timer := 0.1;
	  port IntegerOutputPortType MycomportA
	}

type component MyTestSystemInterface
	{
 		port loopbackPort messagePort
	}
	
altstep AltStep1() runs on GeneralComp { 
  
     [] tc_timer.timeout {
        MycomportA.clear;
        setverdict(pass);
     }
}
	
	
// MyTestSystemInterface is the test system interface
testcase TC_Sem_160201_invoking_altsteps_004() runs on GeneralComp system MyTestSystemInterface {
 map(mtc:MycomportA, system:messagePort);


 MycomportA.send(2);
 tc_timer.start;
 unmap(mtc:MycomportA);

    alt {
     [] AltStep1();
    }
}
control{
    execute(TC_Sem_160201_invoking_altsteps_004());
}
}/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.2, Ensure that the IUT recognizes altstep definitions and correctly evaluates them
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1602_toplevel_001 {

    type record MessageType {
        integer  		field1,
        charstring  	field2
    }

    type port loopbackPort message {
        inout MessageType
    }

    type component GeneralComp {
        port loopbackPort messagePort
    }

    function f_test ( integer p_integer := 0 ) runs on GeneralComp return integer {

        return p_integer+1;
    }

	
    altstep AltSet1() runs on GeneralComp {
        var integer v_LocalVar := f_test();   // local variable
  
        [] messagePort.receive {
            setverdict(pass);
        }
     
    }

    testcase TC_Sem_1602_toplevel_001 () runs on GeneralComp {
        var MessageType v_testMessage;
        v_testMessage:=  {
            field1 := 1,
            field2 := "test string"
        }

        messagePort.send(v_testMessage);

        AltSet1();
 
    }

    control{

        execute(TC_Sem_1602_toplevel_001());

    }

}
/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_023 {
	type union U { integer f1, octetstring f2 }
	
type component GeneralComp {	
}
	

testcase TC_Sem_160102_predefined_functions_023 () runs on GeneralComp {
	template U template1 := ({ f1 := 2 }, {f2 := 'AB'O });
	var boolean v_i;

 	v_i:=ischosen(template1.f1);	//function returns false value
		if(v_i==false) {
			setverdict(pass);
		} else {
			setverdict(fail, "Unexpected decoding result");
		}
}


control{

    execute(TC_Sem_160102_predefined_functions_023());

}

}
/***************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_015 {
    type enumerated EnumeratedType {e_black, e_white};
    type enumerated EnumeratedTypeWithLabels1 {e_black (1), e_white};
    type enumerated EnumeratedTypeWithLabels2 {e_black (-1), e_white};
    type enumerated EnumeratedTypeWithLabels3 {e_black (-1), e_white , e_yellow (0) };

    type component GeneralComp {
    }

    testcase TC_Sem_160102_predefined_functions_015 () runs on GeneralComp {
        var EnumeratedTypeWithLabels2 vl_enum2_black := e_white;
        var EnumeratedTypeWithLabels2 vl_enum2_white := e_black;

        const EnumeratedTypeWithLabels2 c_enum2_black := e_black;
        const EnumeratedTypeWithLabels2 c_enum2_white := e_white;

        int2enum(-1, vl_enum2_black);
        int2enum(0, vl_enum2_white);
        
        setverdict(pass, "Both enumerated values matched");
        
        if (vl_enum2_black != c_enum2_black) {
            setverdict(fail, "black enumerated value not matching ", vl_enum2_black, c_enum2_black);
        }
        if (vl_enum2_white != c_enum2_white) {
            setverdict(fail, "black enumerated value not matching ", vl_enum2_white, c_enum2_white);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_015());
    }
}
/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_021 {
    type enumerated MyEnumeratedType {e_black, e_white, e_green};

    type record MyRecord {
        record {
            boolean innerField1 optional,
            integer innerField2 optional
        } field1 optional,
        integer field2,
        integer field3,
        MyEnumeratedType field4 optional
    }
	
    type component GeneralComp {
    }
	

    testcase TC_Sem_160102_predefined_functions_021 () runs on GeneralComp {
        var MyRecord v_record1 := { field1 := omit, field2 := 2, field3 := 3, field4 := omit } ;
        var boolean v_i;

        v_i:=ispresent(v_record1.field1.innerField1);	//function returns false value
		if(v_i==false) {
			setverdict(pass);
		} else {
			setverdict(fail, "Unexpected decoding result");
		}
    }


    control{

        execute(TC_Sem_160102_predefined_functions_021());

    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined function for removing Byte order mark works properly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * check that reomve_bom() function successfully removes the byte order mark present at the beginning of a stream of serialized (encoded) universal character strings
 UCS encoding scheme
 */


module Sem_160102_predefined_functions_082 {
    
    type component GeneralComp {
    }
    
    testcase TC_Sem_160102_predefined_functions_082 () runs on GeneralComp {
   		
      
    var octetstring v_test_1 :='FEFF0AC2'O ;   
    var octetstring v_test_2 :='C0'O ; 

    var octetstring v_remove := remove_bom(v_test_1);    // expected result: v_remove := '0AC2'O
    var octetstring v_remove_2 := remove_bom(v_test_2);  // expected result: v_remove := 'C0'O
       
	if (match(v_remove,'0AC2'O) and match(v_remove_2, 'C0'O)) {
			setverdict(pass,"Results are: ",v_remove, " and ",v_remove_2 );
		} else {
			setverdict(fail,"Failed,the results are: ",v_remove, " and ",v_remove_2, "Expected: '0AC2'O and 'C0'O");
		}
    }     



    control{
        execute(TC_Sem_160102_predefined_functions_082());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_057 {
	
    
    type component GeneralComp {
    }
     /*Type definitions:*/
    type record of integer MyRecofInt;

    testcase TC_Sem_160102_predefined_functions_057 () runs on GeneralComp {

    var template MyRecofInt v_9 := * length (1 .. 6); // omit and length restriction
        
  
   if ( match(istemplatekind(v_9, "length"), true)) {setverdict(pass," length: ", istemplatekind(v_9, "length"));}
           else{setverdict(fail," length:",istemplatekind(v_9, "length"), " expected result: true");}
    }
    control{

        execute(TC_Sem_160102_predefined_functions_057());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined encvalue_unichar function works properly in case of encoding universal charstring
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/


/* The following requirements are tested:  

 * this test focuses on the predefined functions encvalue_unichar (utf-16)*/



module Sem_160102_predefined_functions_064 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_064 () runs on GeneralComp {

    var charstring v_test := "abc";

     //Encoding:  

    var universal charstring v_test_enc_16 := encvalue_unichar(v_test,"UTF-16"); //encode to universal charstring UTF-16
    setverdict(pass,"Encoded value: ", v_test_enc_16);

    }



    control{

        execute(TC_Sem_160102_predefined_functions_064());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined encvalue_unichar function works properly in case of encoding universal charstring
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/

/* The following requirements are tested:  

 * this test focuses on the predefined functions encvalue_unichar (utf-16 big endian)*/



module Sem_160102_predefined_functions_067 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_067 () runs on GeneralComp {

    var charstring v_test := "abc";

     //Encoding:  

    var universal charstring v_test_enc_16BE := encvalue_unichar(v_test,"UTF-16BE"); //encode to universal charstring UTF-16 big endian
    setverdict(pass,"Encoded value: ", v_test_enc_16BE);

    }

    control{

        execute(TC_Sem_160102_predefined_functions_067());

    }

}/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.33)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_025 {
	
    type component GeneralComp {
    }
	

    testcase TC_Sem_160102_predefined_functions_025 () runs on GeneralComp {
        var charstring v_example:="example text string";
        var charstring v_i;

        v_i:=regexp(v_example,universal charstring: "?+(text)?+",0);	//works according to resolution of CR 6424
		if(v_i=="text") {
			setverdict(pass);
		} else {
			setverdict(fail, "Unexpected matching result");
		}
    }


    control{

        execute(TC_Sem_160102_predefined_functions_025());

    }

}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue function works properly in case of not enough bits
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// (C.5.2)
// The decvalue function decodes a bitstring into a value. The test system shall suppose that 
// the bitstring encoded_value represents an encoded instance of the actual type of decoded_value.
// If the decoding was unsuccessful, the actual parameters for encoded_value and decoded_value are 
// not changed. The function shall return an integer value to indicate success or failure of the 
// decoding below:
// The return value 2 indicates that decoding could not be completed as encoded_value did not 
// contain enough bits.

module Sem_160102_predefined_functions_020 {
    type integer I with { variant "32 bit"};

    type component GeneralComp {
    }

    testcase TC_Sem_160102_predefined_functions_020 () runs on GeneralComp {
        var bitstring v_test := int2bit(0, 16);
		var I v_decoded;
		var integer v_res := decvalue(v_test, v_decoded);
		// expected result:
		// v_res: 2 (failed, not enough bits) -> there are only 16 bits available, while 32 is needed
		// v_decoded: uninitialized
		// v_test: original 16-bit value
		if (match(v_res, 2) and not isbound(v_decoded) and match(lengthof(v_test), 16)) {
			setverdict(pass);
		} else {
			setverdict(fail, "Unexpected decoding result");
		}
    }

    control{
        execute(TC_Sem_160102_predefined_functions_020());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an UTF-32 universal charstring value to an octetstring.*/

module Sem_160102_predefined_functions_029 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_029 () runs on GeneralComp {
       
    // universal charstring:    
        var universal charstring v_0 := "ABC123abc";
        
    // predefined function for universal charstring to octetstring conversion:     
        var octetstring v_encoded := unichar2oct(v_0,"UTF-32");        //"UTF-32", expected value: '0000 0041 0000 0042 0000 0043 0000 0031 0000 0032 0000 0033 0000 0061 0000 0062 0000 0063'O
        var octetstring v_1 := '000000410000004200000043000000310000003200000033000000610000006200000063'O;
  

        if( match(v_encoded,v_1)
        ) {
            setverdict(pass,"Encoded value for: ",v_0, " is ", v_encoded);
        }
        else {
            setverdict(fail,"encoded value is: ", v_encoded, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_029());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_056 {
	
    
    type component GeneralComp {
    }
     /*Type definitions:*/
    type record of integer MyRecofInt;

    testcase TC_Sem_160102_predefined_functions_056 () runs on GeneralComp {

    var template MyRecofInt v_9 := omit length (1 .. 6); // omit and length restriction
        
    if ( match(istemplatekind(v_9, "omit"), true)) {setverdict(pass," omit: ", istemplatekind(v_9, "omit"));}
           else{setverdict(fail," omit:",istemplatekind(v_9, "omit"), " expected result: true");}
    }
    control{

        execute(TC_Sem_160102_predefined_functions_056());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined encvalue_unichar function works properly in case of encoding universal charstring
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/

/* The following requirements are tested:  

 * this test focuses on the predefined functions encvalue_unichar (utf-16 little endian)*/



module Sem_160102_predefined_functions_066 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_066 () runs on GeneralComp {

    var charstring v_test := "abc";

     //Encoding:  

    var universal charstring v_test_enc_16LE := encvalue_unichar(v_test,"UTF-16LE"); //encode to universal charstring UTF-16 little endian
    setverdict(pass,"Encoded value: ", v_test_enc_16LE);

    }

    control{

        execute(TC_Sem_160102_predefined_functions_066());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * this test investigates that IUT correctly evaluates predefined function any2unistr, 
 * the invalue parameter of the any2unistr function may be uninitialized or partially initialized;
*/

module Sem_160102_predefined_functions_044 {
	    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_044 () runs on GeneralComp {
       
         var bitstring v_2 := '11101'B; //bitstring
           
      //bitstring
        if(match(any2unistr(v_2),"'11101'B")) { setverdict(pass,"Result: ",any2unistr(v_2));}
         else{setverdict(fail,"Result is: ",any2unistr(v_2), " Expected:'11101'B");}
       
    }

    control{
        execute(TC_Sem_160102_predefined_functions_044());
    }
}/***************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// test enum2int with labels
module Sem_160102_predefined_functions_013 {

    type enumerated EnumeratedTypeWithLabels2 {e_black (-1), e_white};
    type enumerated EnumeratedTypeWithLabels3 {e_black (-1), e_white , e_yellow (0) };

    type component GeneralComp {
    }

    testcase TC_Sem_160102_predefined_functions_013 () runs on GeneralComp {
        var EnumeratedTypeWithLabels2 vl_enum2_black := e_black;
        var EnumeratedTypeWithLabels2 vl_enum2_white := e_white;
        var EnumeratedTypeWithLabels3 vl_enum3_black := e_black;
        var EnumeratedTypeWithLabels3 vl_enum3_white := e_white;
        var EnumeratedTypeWithLabels3 vl_enum3_yellow := e_yellow;

        if( match(enum2int(vl_enum2_black), -1) and
            match(enum2int(vl_enum2_white), 0)
        ) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    
        if( match(enum2int(vl_enum3_black), -1) and
            match(enum2int(vl_enum3_white), 1)
        ) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_013());
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an UTF-32 universal charstring value to a Big endian octetstring.*/

module Sem_160102_predefined_functions_033 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_033 () runs on GeneralComp {
       
    // universal charstring:    
        var universal charstring v_0 := "AB";
        
    // predefined function for universal charstring to octetstring conversion:     
        var octetstring v_encoded := unichar2oct(v_0, "UTF-32BE");      //"UTF-32" Big endian, expected value:'42 00 00 00 41 00 00 00'O 
        var octetstring v_1 := '4200000041000000'O;
  

        if( match(v_encoded,v_1)
        ) {
            setverdict(pass,"Encoded value for: ",v_0, " is ", v_encoded);
        }
        else {
            setverdict(fail,"encoded value is: ", v_encoded, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_033());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_060 {
	
    
    type component GeneralComp {
    }
     /*Type definitions:*/
    type record of integer MyRecofInt;

    testcase TC_Sem_160102_predefined_functions_060() runs on GeneralComp {

    var template MyRecofInt v_10 := {permutation(1, 2, 3),?,*} ; // permutation, Any element(?) and AnyElementsOrNone(*)
        
  
        if ( match(istemplatekind(v_10, "permutation"), true)) {setverdict(pass," permutation: ", istemplatekind(v_10, "permutation"));}
           else{setverdict(fail," permutation:",istemplatekind(v_10, "permutation"), " expected result: true");}
    }
    control{

        execute(TC_Sem_160102_predefined_functions_060());

    }

}/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_001 {
    type enumerated EnumeratedType {e_black, e_white};

    type component GeneralComp {
    }

    /**
     * @desc Equals method for floats
     * @return true if abs(f1 - f2) < 1.E-6
     */
    function f_isFloatNear(in float f1, in float f2) return boolean {
        var float delta := f1-f2;
        if (delta < 0.0) {
            delta := 0.0 - delta;
        }
        return delta < 1E-6;
    }

    testcase TC_Sem_160102_predefined_functions_001 () runs on GeneralComp {
        const universal charstring c_i:="i";
        var integer v_result:=0;
        var EnumeratedType v_enum:=e_white;

        if( match(int2char(105), "i") and
            match(int2unichar(105), c_i) and
            match(int2bit(5,4), '0101'B) and
            match(int2hex(55,4), '0037'H) and
            match(int2oct(55,2), '0037'O) and
            match(int2str(55), "55") and
            (f_isFloatNear(int2float(5),5.0)) and
            match(float2int(5.0), 5) and
            match(char2int("i"), 105) and
            match(char2oct("i"), '69'O) and
            match(unichar2int(c_i), 105) and
            match(bit2int('101'B), 5) and
            match(bit2hex('110111'B), '37'H) and
            match(bit2oct('110111'B), '37'O) and
            match(bit2str('110111'B), "110111") and
            match(hex2int('37'H), 55) and
            match(hex2bit('37'H),'00110111'B) and
            match(hex2oct('37'H), '37'O) and
            match(hex2str('37'H), "37") and
            match(oct2int('37'O), 55) and
            match(oct2bit('37'O), '00110111'B) and
            match(oct2hex('37'O), '37'H) and
            match(oct2str('37'O), "37") and
            match(oct2char('69'O), "i") and
            match(str2int("55"),55) and
            match(str2oct("55"), '55'O) and
            (f_isFloatNear(str2float("5.5"),5.5)) and
            match(enum2int(v_enum), 1)
        ) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_001());
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_059 {
	
    
    type component GeneralComp {
    }
     /*Type definitions:*/
    type record of integer MyRecofInt;

    testcase TC_Sem_160102_predefined_functions_059() runs on GeneralComp {

    var template MyRecofInt v_10 := {permutation(1, 2, 3),?,*} ; // permutation, Any element(?) and AnyElementsOrNone(*)
        
  
            if ( match(istemplatekind(v_10, "AnyElementsOrNone"), true)) {setverdict(pass," AnyElementsOrNone: ", istemplatekind(v_10, "AnyElementsOrNone"));}
           else{setverdict(fail," AnyElementsOrNone:",istemplatekind(v_10, "AnyElementsOrNone"), " expected result: true");}
    }
    control{

        execute(TC_Sem_160102_predefined_functions_059());

    }

}/***************************************************
 ** @author   STF 433
 ** @version  0.0.2
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
// test enum2int predefined function with labels

module Sem_160102_predefined_functions_010 {
    type enumerated EnumeratedType {e_black, e_white};
    type enumerated EnumeratedTypeWithLabels1 {e_black (1), e_white};
   
    type component GeneralComp {
    }

    testcase TC_Sem_160102_predefined_functions_010 () runs on GeneralComp {
        var EnumeratedType vl_enum_black := e_black;
        var EnumeratedType vl_enum_white := e_white;
        var EnumeratedTypeWithLabels1 vl_enum1_black := e_black;
        var EnumeratedTypeWithLabels1 vl_enum1_white := e_white;

        if( match(enum2int(vl_enum_black), 0) and
            match(enum2int(vl_enum_white), 1)
        ) {
            setverdict(pass);
        }
        else {
            setverdict(fail, "fail 0");
        }
      
        if( match(enum2int(vl_enum1_black), 1) and
            match(enum2int(vl_enum1_white), 0)
        ) {
            setverdict(pass);
        }
        else {
            setverdict(fail, "fail 1");
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_010());
    }
}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_160102_predefined_functions_003 {
    type enumerated MyEnumeratedType {e_black, e_white, e_green};

    type record MyRecord {
        record {
            boolean innerField1 optional,
            integer innerField2 optional
        } field1 optional,
        integer field2,
        integer field3,
        MyEnumeratedType field4 optional
    }
	
    type union U { integer f1, octetstring f2 }
	
    type component GeneralComp {
    }
	
    testcase TC_Sem_160102_predefined_functions_003 () runs on GeneralComp {
        var MyRecord v_record1 := {
				field1 := {innerField1 := omit, innerField2 := omit},
				field2 := 2,
				field3 := 3,
				field4 := omit
			};
        var U v_U1 := {f1 := 1};
        template MyRecord template1 := {
			field1 := {?, *},
			field2 := 2,
			field3 := 3,
			field4 := (e_black, e_white)  ifpresent
		}
        template U template2 := {f2 := ?}

        if( match(ispresent(v_record1.field1), true) and
            match(ispresent(v_record1.field4), false) and
            match(ispresent(v_record1.field2), true) and
            match(ispresent(template1.field1.innerField1), true) and
            match(ischosen(v_U1.f1), true) and
            match(ischosen(v_U1.f2), false) and
            match(ischosen(template2.f2), true) and
            match(ischosen(template2.f1), false) and
            match(isvalue(template1.field2), true) and
            match(isvalue(template2.f2), false)
        ) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_003());
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_055 {
	
    
    type component GeneralComp {
    }
    type set of integer MySet(0 .. 10);

    testcase TC_Sem_160102_predefined_functions_055 () runs on GeneralComp {

    var template MySet v_8 := subset (1, 2, 3); //subset
        
     if ( match(istemplatekind(v_8, "subset"), true)) {setverdict(pass," superset: ", istemplatekind(v_8, "subset"));}
           else{setverdict(fail," subset:",istemplatekind(v_8, "subset"), " expected result: true");}
    }
    control{

        execute(TC_Sem_160102_predefined_functions_055());

    }

}/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.4.1)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * Check that regexp predefined function with @nocase modfier evaluates the charstrings case insensitive way
 * 
 * */

module Sem_160102_predefined_functions_090 {
	
    type component GeneralComp {
    }
	

    testcase TC_Sem_160102_predefined_functions_090 () runs on GeneralComp {
        var charstring v_example_1:="example text string";
        var charstring v_example_2:="ExAmPlE TeXt StRinG";
        
        var charstring v_i,v_j;
        
		v_i := regexp @nocase(v_example_1,charstring:"?+(TeXt)?+",0);    //capital letters in expression
        v_j := regexp @nocase(v_example_2,charstring:"?+(text)?+",0);    //captial letters in inpar 
       
        if(match(v_i,"text") and match(v_j,"TeXt")) {
			setverdict(pass,"Results are: ",v_i, " and ", v_j);
		} else {
			setverdict(fail,"Results are: ",v_i, " and ", v_j);
		}
    }


    control{

        execute(TC_Sem_160102_predefined_functions_090());

    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_058 {
	
    
    type component GeneralComp {
    }
     /*Type definitions:*/
    type record of integer MyRecofInt;

    testcase TC_Sem_160102_predefined_functions_058 () runs on GeneralComp {

    var template MyRecofInt v_10 := {permutation(1, 2, 3),?,*} ; // permutation, Any element(?) and AnyElementsOrNone(*)
        
  
     if ( match(istemplatekind(v_10, "AnyElement"), true)) {setverdict(pass," AnyElement: ", istemplatekind(v_10, "AnyElement"));}
           else{setverdict(fail," AnyElement:",istemplatekind(v_10, "AnyElement"), " expected result: true");}
    }
    control{

        execute(TC_Sem_160102_predefined_functions_058());

    }

}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_011 {
    type enumerated EnumeratedType {e_black, e_white};
    type enumerated EnumeratedTypeWithLabels1 {e_black (1), e_white};
    type enumerated EnumeratedTypeWithLabels2 {e_black (-1), e_white};
    type enumerated EnumeratedTypeWithLabels3 {e_black (-1), e_white , e_yellow (0) };

    type component GeneralComp {
    }

    testcase TC_Sem_160102_predefined_functions_011 () runs on GeneralComp {
        var EnumeratedType vl_enum_black := e_black;
        var EnumeratedType vl_enum_white := e_white;
        var EnumeratedTypeWithLabels1 vl_enum1_black := e_white;
        var EnumeratedTypeWithLabels1 vl_enum1_white := e_black;
        var EnumeratedTypeWithLabels2 vl_enum2_black := e_white;
        var EnumeratedTypeWithLabels2 vl_enum2_white := e_black;
        var EnumeratedTypeWithLabels3 vl_enum3_black := e_white;
        var EnumeratedTypeWithLabels3 vl_enum3_white := e_black;
        var EnumeratedTypeWithLabels3 vl_enum3_yellow := e_black;

        const EnumeratedType c_enum_black := e_black;
        const EnumeratedType c_enum_white := e_white;
        const EnumeratedTypeWithLabels1 c_enum1_black := e_black;
        const EnumeratedTypeWithLabels1 c_enum1_white := e_white;
        const EnumeratedTypeWithLabels2 c_enum2_black := e_black;
        const EnumeratedTypeWithLabels2 c_enum2_white := e_white;
        const EnumeratedTypeWithLabels3 c_enum3_black := e_black;
        const EnumeratedTypeWithLabels3 c_enum3_white := e_white;

        int2enum(0,vl_enum_black);
        int2enum(1,vl_enum_white);
        if( match(vl_enum_black, c_enum_black) and
            match(vl_enum_white, c_enum_white)
        ) {
            setverdict(pass);
        }
        else {
            setverdict(fail, "fail 0");
        }
      
        int2enum(1,vl_enum1_black);
        int2enum(0,vl_enum1_white);
        if( match(vl_enum1_black, c_enum1_black) and
            match(vl_enum1_white, c_enum1_white)
        ) {
            setverdict(pass);
        }
        else {
            setverdict(fail, "fail 1");
        }

        int2enum(-1,vl_enum2_black);
        int2enum(0,vl_enum2_white);
        if( match(vl_enum2_black, c_enum2_black) and
            match(vl_enum2_white, c_enum2_white)
        ) {
            setverdict(pass);
        }
        else {
            setverdict(fail, "fail 2");
        }
    
        int2enum(-1,vl_enum3_black);
        int2enum(1,vl_enum3_white);
        if( match(vl_enum3_black, c_enum3_black) and
            match(vl_enum3_white, c_enum3_white)
        ) {
            setverdict(pass);
        }
        else {
            setverdict(fail, "fail 3");
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_011());
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined function isvalue() works properly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * check that isvalue() predefined function works properly
 */


module Sem_160102_predefined_functions_084 {
    
    type component GeneralComp {
    }
    
    testcase TC_Sem_160102_predefined_functions_084 () runs on GeneralComp {
   	
    var boolean v_res;
        
    var GeneralComp MyComp;

    
        
    v_res := isvalue(MyComp);        //component ,expected result: false

        
        
     if ( match(v_res, false)) {setverdict(pass," isvalue(MyComp): ", v_res);}
           else{setverdict(fail," isvalue(MyComp):", v_res, " expected result: false");}

    }     


    control{
        execute(TC_Sem_160102_predefined_functions_084());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an UTF-16 universal charstring value to an octetstring.*/

module Sem_160102_predefined_functions_028 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_028 () runs on GeneralComp {
       
    // universal charstring:    
        var universal charstring v_0 := "ABC123abc";
        
    // predefined function for universal charstring to octetstring conversion:     
        var octetstring v_encoded := unichar2oct(v_0,"UTF-16");        //"UTF-16", expected value: '0041 0042 0043 0031 0032 0033 0061 0062 0063'O
        var octetstring v_1 := '004100420043003100320033006100620063'O;
  

        if( match(v_encoded,v_1)
        ) {
            setverdict(pass,"Encoded value for: ",v_0, " is ", v_encoded);
        }
        else {
            setverdict(fail,"encoded value is: ", v_encoded, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_028());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an octetstring to an UTF-32 Big Endian byte order universal charstring.*/


module Sem_160102_predefined_functions_041 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_041 () runs on GeneralComp {
       
    //octetstring:    
        var octetstring v_0 := '430000004200000041000000'O;
        
    // predefined function for universal charstring to octetstring conversion:     
        var universal charstring v_decode := oct2unichar(v_0,"UTF-32BE");        //expected value: ABC
        var universal charstring v_1 := "ABC"; 

        if( match(v_decode,v_1)
        ) {
            setverdict(pass,"Decoded value for: ",v_0, " is ", v_decode);
        }
        else {
            setverdict(fail,"encoded value is: ", v_decode, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_041());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined function isvalue() works properly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * check that isvalue() predefined function works properly
 */


module Sem_160102_predefined_functions_086 {
    
    type component GeneralComp {
    }
    
    testcase TC_Sem_160102_predefined_functions_086 () runs on GeneralComp {
   	
    var boolean v_res;
        
    var default MyDef := null;

    
        
    v_res := isvalue(MyDef);         //dafult, expected result: true

    
    if ( match(v_res, true)) {setverdict(pass," isvalue(MyDef): ", v_res);}
           else{setverdict(fail," isvalue(MyDef)):", v_res, " expected result: true");}
        
    }


    control{
        execute(TC_Sem_160102_predefined_functions_086());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 *16.1.2 Restriction a.3:
 * any_string or sequence_type parameters of the functions substr may be partially initialized; */


module Sem_160102_predefined_functions_092 {
	
    type component GeneralComp {}
    
    type record of integer RoI;

    
    testcase TC_Sem_160102_predefined_functions_092 () runs on GeneralComp {
       
    var RoI v_Rec1;
    var RoI v_res;
    
       v_Rec1 :={-,0,-,2};      //partially initialized record of integers  
       v_res := substr(v_Rec1,1,1);            //expected result: {0}
     
        if( match(v_res,{0}) ) {
                    setverdict(pass,v_res);
       } else {
                    setverdict(fail,"The value of v_res:",v_res);
              }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_092());
    }

}/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_160102_predefined_functions_002 {
    type record of integer IntegerList;

    type record MyRecord {
        boolean field1,
        record of integer field2,
        integer field3 optional
    }

    type component GeneralComp {
    }
	
    testcase TC_Sem_160102_predefined_functions_002 () runs on GeneralComp {
        template MyRecord template1 := {
            field1 := true,
            field2 := { permutation(2, 3), ? },
            field3 := omit
        }
        template MyRecord template2 := {
            field1 := true,
            field2 := {permutation(2, 3)},
            field3 := omit
        } 
        template IntegerList template3 := { 1, 2, 3, * } length(1..3) ;

        if (not (lengthof(charstring:"test") == 4)) {
            setverdict(fail);
        } 
        if (not (lengthof(universal charstring:"test") == 4)) {
            setverdict(fail);
        } 
        if (not (lengthof(bitstring:'010'B) == 3)) {
            setverdict(fail);
        } 
        if (not (lengthof(hexstring:'55'H) == 2)) {
            setverdict(fail);
        } 
        if (not (lengthof(octetstring:'55'O) == 1)) {
            setverdict(fail);
        } 
        if (not (lengthof(charstring:pattern "t??t") == 4)) {
            setverdict(fail);
        } 
        if (not (lengthof(bitstring:'1??1'B) == 4)) {
            setverdict(fail);
        } 
        if (not (lengthof(hexstring:'1*1'H length(8)) == 8)) {
            setverdict(fail);
        } 
        if (not (lengthof(octetstring:'00?FF'O length(3)) == 3)) {
            setverdict(fail);
        } 
        if (not (lengthof(octetstring:'AB?'O) == 2)) {
            setverdict(fail);
        } 
        if (not (lengthof(template1.field2) == 3)) {
            setverdict(fail);
        } 
        if (not (sizeof(template2) == 2)) {
            setverdict(fail);
        } 
        if (not (lengthof(template3) == 3)) {
            setverdict(fail);
        } 
        setverdict(pass);
    }

    control {
        execute(TC_Sem_160102_predefined_functions_002());
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_047 {
	
    
    type component GeneralComp {
    }

    /*Type definition:*/
    type record of integer MyRecofInt;

    testcase TC_Sem_160102_predefined_functions_047 () runs on GeneralComp {
    
       var template MyRecofInt v_0 := {1,2,3} ifpresent; // ifpresent

  
        
        if ( match(istemplatekind(v_0, "ifpresent"), true)) {setverdict(pass," ifpresent: ", istemplatekind(v_0, "ifpresent"));}
           else{setverdict(fail,"  ifpresent:",istemplatekind(v_0, "ifpresent"), " expected result: true");}

    }
    control{

        execute(TC_Sem_160102_predefined_functions_047());

    }

}/***************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_014 {

    type enumerated EnumeratedTypeWithLabels1 {e_black (1), e_white};

    type component GeneralComp {
    }

    testcase TC_Sem_160102_predefined_functions_014 () runs on GeneralComp {
        var EnumeratedTypeWithLabels1 vl_enum1_black := e_white;
        var EnumeratedTypeWithLabels1 vl_enum1_white := e_black;

        const EnumeratedTypeWithLabels1 c_enum1_black := e_black;
        const EnumeratedTypeWithLabels1 c_enum1_white := e_white;
      
        int2enum(1,vl_enum1_black);
        int2enum(0,vl_enum1_white);
        if( match(vl_enum1_black, c_enum1_black) and
            match(vl_enum1_white, c_enum1_white)
        ) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_014());
    }
}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_009 {
    type enumerated MyEnumeratedType {e_black, e_white, e_green};

    type record MyRecord {
        record {
            boolean innerField1 optional,
            integer innerField2 optional
        } field1 optional,
        integer field2,
        integer field3,
        MyEnumeratedType field4 optional
    }
	
    type component GeneralComp {
    }
	
    testcase TC_Sem_160102_predefined_functions_009 () runs on GeneralComp {
        template MyRecord template1 := {
			field1 := {?, *},
			field2 := 2,
			field3 := 3,
			field4 := (e_black, e_white)  ifpresent
		}

        if (ispresent(template1.field4)) {	// not present
            setverdict(fail);
        } else {
            setverdict(pass);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_009());
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_051 {
	
    
    type component GeneralComp {
    }

    /*Type definition:*/
    type record of integer MyRecofInt;

    testcase TC_Sem_160102_predefined_functions_051 () runs on GeneralComp {

      var template MyRecofInt v_4 :=?; //anytype (?) 
        
      if ( match(istemplatekind(v_4, "AnyValue"), true)) {setverdict(pass," AnyValue: ", istemplatekind(v_4, "AnyValue"));}
           else{setverdict(fail,"  AnyValue:",istemplatekind(v_4, "AnyValue"), " expected result: true");}

    }
    control{

        execute(TC_Sem_160102_predefined_functions_051());

    }

}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined encvalue function works correctly (as specified in Annex C.5.1)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// (C.5.1) The encvalue function encodes a value or template into a bitstring. When the actual 
// parameter that is passed to inpar is a template, it shall resolve to a specific value (the 
// same restrictions apply as for the argument of the send statement). The returned bitstring 
// represents the encoded value of inpar, however, the TTCN-3 test system need not make any 
// check on its correctness.

module Sem_160102_predefined_functions_016 {
    type integer I with { variant "32 bit"};

    type component GeneralComp {
    }

    testcase TC_Sem_160102_predefined_functions_016 () runs on GeneralComp {
        var template I v_test := 0;
		var bitstring v_res := encvalue(v_test);
		if (lengthof(v_res) == 32) {
			setverdict(pass);
		} else {
			setverdict(fail, "Invalid encoding length");
		}
    }

    control{
        execute(TC_Sem_160102_predefined_functions_016());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined function isvalue() works properly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * check that isvalue() predefined function works properly
 */


module Sem_160102_predefined_functions_087 {
    
    type component GeneralComp {
    }
    
    testcase TC_Sem_160102_predefined_functions_087 () runs on GeneralComp {
   	
    var boolean v_res;
        
    template charstring Mytemaplate2 := pattern "A*Z";

    
        
    v_res := isvalue(Mytemaplate2);  //pattern, expected result: false

    
   if ( match(v_res, false)) {setverdict(pass," isvalue(Mytemaplate2: ", v_res);}
           else{setverdict(fail," isvalue(Mytemaplate2): ", v_res, " expected result: false");}
        
        
    }


    control{
        execute(TC_Sem_160102_predefined_functions_087());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an octetstring to an UTF-32 encoded universal charstring.*/


module Sem_160102_predefined_functions_037 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_037 () runs on GeneralComp {
       
    //octetstring:    
        var octetstring v_0 := '000000410000004200000043'O;
        
    // predefined function for universal charstring to octetstring conversion:     
        var universal charstring v_decode := oct2unichar(v_0,"UTF-32");        //expected value: ABC
        var universal charstring v_1 := "ABC"; 

        if( match(v_decode,v_1)
        ) {
            setverdict(pass,"Decoded value for: ",v_0, " is ", v_decode);
        }
        else {
            setverdict(fail,"encoded value is: ", v_decode, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_037());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue_unichar function works properly
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/

/* The following requirements are tested:  

 * this test focuses on the predefined functions decvalue_unichar (utf-32)*/



module Sem_160102_predefined_functions_074 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_074 () runs on GeneralComp {

    
    //encoded text:
   var universal charstring v_enc := encvalue_unichar(123,"UTF-32"); //encode UTF-32


    //decode:
    var integer v_test_dec;
    var integer v_res:= decvalue_unichar(v_enc,v_test_dec,"UTF-32"); //decode (UTF-32)
    
    if (v_res == 0) {
          setverdict(pass, "Decoded ", v_enc , " with result ", v_res);
    } else {
          setverdict(fail, "Unexpected decoding result: Decoded ", v_enc , " with result ", v_res);
    }

   }

    control{

        execute(TC_Sem_160102_predefined_functions_074());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_050 {
	
    
    type component GeneralComp {
    }

    /*Type definition:*/
    type record of integer MyRecofInt;

    testcase TC_Sem_160102_predefined_functions_050 () runs on GeneralComp {
    var template MyRecofInt v_1 := {1,2,3,4,5}; // specific value of integer type
    var template integer v_3 := complement(all from v_1, 10); //component
        
     if ( match(istemplatekind(v_3, "complement"), true)) {setverdict(pass," component: ", istemplatekind(v_3, "complement"));}
           else{setverdict(fail,"  componenet:",istemplatekind(v_3, "complement"), " expected result: true");}

    }
    control{

        execute(TC_Sem_160102_predefined_functions_050());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an octetstring to an UTF-8 encoded universal charstring.*/


module Sem_160102_predefined_functions_035 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_035 () runs on GeneralComp {
       
    //octetstring:    
        var octetstring v_0 := '414243'O;
        
    // predefined function for universal charstring to octetstring conversion:     
        var universal charstring v_decode := oct2unichar(v_0,"UTF-8");        //expected value: ABC
        var universal charstring v_1 := "ABC"; 

        if( match(v_decode,v_1)
        ) {
            setverdict(pass,"Decoded value for: ",v_0, " is ", v_decode);
        }
        else {
            setverdict(fail,"encoded value is: ", v_decode, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_035());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined encvalue_unichar function works properly in case of encoding universal charstring
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/

/* The following requirements are tested:  

 * this test focuses on the predefined functions encvalue_unichar (utf-32 big endian)*/



module Sem_160102_predefined_functions_069 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_069 () runs on GeneralComp {

    var charstring v_test := "abc";

     //Encoding:  

    var universal charstring v_test_enc_32BE := encvalue_unichar(v_test,"UTF-32BE"); //encode to universal charstring UTF-32 big endian
    setverdict(pass,"Encoded value: ", v_test_enc_32BE);

    }

    control{

        execute(TC_Sem_160102_predefined_functions_069());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * check that rnd() uses seeds per component
 *  
 */


module Sem_160102_predefined_functions_091 {
	
  type component GeneralComp {}
	
    
  //function to generate random number with seed given as input
  function frnd(float seed) runs on GeneralComp {
    var float v_random1 := rnd(seed);
    var float v_random2 := rnd();
             
    setverdict(pass);
    if (not match(rnd(seed), v_random1)) {
      setverdict(fail, "rnd from same seed has to be identical to ", v_random1);
    }
    if (match(rnd(seed+1.0), v_random1)) {
      setverdict(fail, "rnd from different seed should not be identical with ", v_random1);
    }
  }
    
  testcase TC_Sem_160102_predefined_functions_091 (float General_Comp_seed) runs on GeneralComp system GeneralComp {
       
    var float v_random1,v_random2;
     
    //Generate components with different seeds
    var GeneralComp v_ptc1,v_ptc2;
     
    v_ptc1:= GeneralComp.create alive;
    v_ptc2:= GeneralComp.create alive;
        
    //different seeds given to components:
    v_ptc1.start(frnd(General_Comp_seed));
    v_ptc2.start(frnd(General_Comp_seed+0.5));
    all component.done;
  }

  control{
    const float General_Comp_seed := 0.0;
    execute(TC_Sem_160102_predefined_functions_091(General_Comp_seed));
  }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an octetstring to an UTF-32 Little Endian byte order universal charstring.*/


module Sem_160102_predefined_functions_039 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_039 () runs on GeneralComp {
       
    //octetstring:    
        var octetstring v_0 := '000000410000004200000043'O;
        
    // predefined function for universal charstring to octetstring conversion:     
        var universal charstring v_decode := oct2unichar(v_0,"UTF-32LE");        //expected value: ABC
        var universal charstring v_1 := "ABC"; 

        if( match(v_decode,v_1)
        ) {
            setverdict(pass,"Decoded value for: ",v_0, " is ", v_decode);
        }
        else {
            setverdict(fail,"encoded value is: ", v_decode, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_039());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined function isvalue() works properly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * check that isvalue() predefined function works properly
 */


module Sem_160102_predefined_functions_088 {
    
    type record MyRec{
    integer field1,
    integer field2 optional}
    
    type record MyRec2 {
     MyRec field1,
     integer field2
    }
    
    type component GeneralComp {
    }
    
    testcase TC_Sem_160102_predefined_functions_088() runs on GeneralComp {
   	
    var boolean v_res;
        
    var MyRec2 MyRecValue := {{1,-},1};

    
        
    v_res := isvalue(MyRecValue.field1.field1);  //nested, expected result: true

    
   if ( match(v_res, true)) {setverdict(pass," isvalue(MyRecValue.field1.field1): ", v_res);}
           else{setverdict(fail," isvalue(MyRecValue.field1.field1):", v_res, " expected result: true");}
        
    }


    control{
        execute(TC_Sem_160102_predefined_functions_088());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_061 {
	
    
    type component GeneralComp {
    }
     /*Type definitions:*/
    type record of integer MyRecofInt;

    testcase TC_Sem_160102_predefined_functions_061() runs on GeneralComp {

   var template charstring v_11 := pattern "abc";    //pattern template
        
    if ( match(istemplatekind(v_11, "pattern"), true)) {setverdict(pass," pattern: ", istemplatekind(v_11, "pattern"));}
           else{setverdict(fail," pattern:",istemplatekind(v_11, "pattern"), " expected result: true");}
        
    }
    control{

        execute(TC_Sem_160102_predefined_functions_061());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_049 {
	
    
    type component GeneralComp {
    }

    /*Type definition:*/
    type record of integer MyRecofInt;

    testcase TC_Sem_160102_predefined_functions_049 () runs on GeneralComp {

       var template MyRecofInt v_1 := {1,2,3,4,5}; // specific value of integer type
       var template integer v_2 := (all from v_1, 10);    //Template list
        
        if ( match(istemplatekind(v_2, "list"), true)) {setverdict(pass," list: ", istemplatekind(v_2, "list"));}
           else{setverdict(fail,"  value:",istemplatekind(v_2, "list"), " expected result: true");}

    }
    control{

        execute(TC_Sem_160102_predefined_functions_049());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an octetstring to an UTF-16 Big Endian byte order universal charstring.*/


module Sem_160102_predefined_functions_040 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_040 () runs on GeneralComp {
       
    //octetstring:    
        var octetstring v_0 := '430042004100'O;
        
    // predefined function for universal charstring to octetstring conversion:     
        var universal charstring v_decode := oct2unichar(v_0,"UTF-16BE");        //expected value: ABC
        var universal charstring v_1 := "ABC"; 

        if( match(v_decode,v_1)
        ) {
            setverdict(pass,"Decoded value for: ",v_0, " is ", v_decode);
        }
        else {
            setverdict(fail,"encoded value is: ", v_decode, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_040());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue_unichar function works properly
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/

/* The following requirements are tested:  

 * this test focuses on the predefined functions decvalue_unichar (utf-16 big endian)*/



module Sem_160102_predefined_functions_078 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_078 () runs on GeneralComp {

    
    //encoded text:
   var universal charstring v_enc := encvalue_unichar(123,"UTF-16BE");


    //decode:
    var integer v_test_dec;
    var integer v_res:= decvalue_unichar(v_enc,v_test_dec,"UTF-16BE"); //decode (UTF-16 big endian)
    
    if (v_res == 0) {
          setverdict(pass, "Decoded ", v_enc , " with result ", v_res);
    } else {
          setverdict(fail, "Unexpected decoding result: Decoded ", v_enc , " with result ", v_res);
    }

   }

    control{

        execute(TC_Sem_160102_predefined_functions_078());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue_unichar function works properly
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/

/* The following requirements are tested:  

 * this test focuses on the predefined functions decvalue_unichar (utf-32 big endian)*/



module Sem_160102_predefined_functions_079 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_079 () runs on GeneralComp {

    
    //encoded text:
   var universal charstring v_enc := encvalue_unichar(123,"UTF-32BE");


    //decode:
    var integer v_test_dec;
    var integer v_res:= decvalue_unichar(v_enc,v_test_dec,"UTF-32BE"); //decode (UTF-32 big endian)
    
    if (v_res == 0) {
          setverdict(pass, "Decoded ", v_enc , " with result ", v_res);
    } else {
          setverdict(fail, "Unexpected decoding result: Decoded ", v_enc , " with result ", v_res);
    }

   }

    control{

        execute(TC_Sem_160102_predefined_functions_079());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue_unichar function works properly
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/
//NOT working with TestCast 6.8.2.5 -test fails 


/* The following requirements are tested:  

 * this test focuses on the predefined functions decvalue_unichar (utf-8) with charstring input*/



module Sem_160102_predefined_functions_071 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_071 () runs on GeneralComp {

    
    //encoded text:
   var universal charstring v_enc := encvalue_unichar("aBcDeF","UTF-8");


    //decode:
    var charstring v_test_dec;
    var integer v_res:= decvalue_unichar(v_enc,v_test_dec,"UTF-8"); //decode (UTF-8)
    
    if (v_res == 0) {
          setverdict(pass, "Decoded ", v_enc , " with result ", v_res);
    } else {
          setverdict(fail, "Unexpected decoding result: Decoded ", v_enc , " with result ", v_res);
    }

   }

    control{

        execute(TC_Sem_160102_predefined_functions_071());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts a universal charstring value to an octetstring.*/


module Sem_160102_predefined_functions_026 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_026 () runs on GeneralComp {
       
    // universal charstring:    
        var universal charstring v_0 := "ABC123abc";
        
    // predefined function for universal charstring to octetstring conversion:     
        var octetstring v_encoded := unichar2oct(v_0);        //string_encoding parameter is omitted, the default value "UTF-8", expected value: '414243313233616263'O
        var octetstring v_1 := '414243313233616263'O;
  

        if( match(v_encoded,v_1)
        ) {
            setverdict(pass,"Encoded value for: ",v_0, " is ", v_encoded);
        }
        else {
            setverdict(fail,"encoded value is: ", v_encoded, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_026());
    }
}/***************************************************
 * @author STF 470
 * @version 0.0.1
 * @purpose 1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 * @verdict pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_024 {
	type union U {
		integer f1,
		octetstring f2
	}

	type component GeneralComp {
	}


	testcase TC_Sem_160102_predefined_functions_024() runs on GeneralComp {
		template U template1 := {f2 := ?}
		var boolean v_i;

		v_i := isvalue(template1.f1); //function returns false value
		if(v_i==false) {
			setverdict(pass);
		} else {
			setverdict(fail, "Unexpected decoding result");
		}
	}

	control {
		execute(TC_Sem_160102_predefined_functions_024());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue function performs decoding if there are more bits than needed
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// (C.5.2) 
// The decvalue function decodes a bitstring into a value. The test system shall suppose that 
// the bitstring encoded_value represents an encoded instance of the actual type of decoded_value.
// If the decoding was successful, then the used bits are removed from the parameter encoded_value, 
// the rest is returned (in the parameter encoded_value), and the decoded value is returned 
// in the parameter decoded_value. The function shall return an integer value to indicate success 
// or failure of the decoding below:
//  The return value 0 indicates that decoding was successful.

module Sem_160102_predefined_functions_018 {
    type integer I with { variant "32 bit"};

    type component GeneralComp {
    }

    testcase TC_Sem_160102_predefined_functions_018 () runs on GeneralComp {
		const bitstring c_suffix := '11111111'B;
        var bitstring v_test := int2bit(0, 32) & c_suffix; // 8 excess bits
		var I v_decoded;
		var integer v_res := decvalue(v_test, v_decoded);
		// expected result:
		// v_res: 0 (success)
		// v_decoded: 0
		// v_test: '11111111'B (8 excess bits shall be returned)
		if (match(v_res, 0) and match(v_decoded, 0) and match(v_test, c_suffix)) {
			setverdict(pass);
		} else {
			setverdict(fail, "Unexpected decoding result");
		}
    }

    control{
        execute(TC_Sem_160102_predefined_functions_018());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue function performs full decoding correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// (C.5.2) 
// The decvalue function decodes a bitstring into a value. The test system shall suppose that 
// the bitstring encoded_value represents an encoded instance of the actual type of decoded_value.
// If the decoding was successful, then the used bits are removed from the parameter encoded_value, 
// the rest is returned (in the parameter encoded_value), and the decoded value is returned 
// in the parameter decoded_value. The function shall return an integer value to indicate success 
// or failure of the decoding below:
//  The return value 0 indicates that decoding was successful.

module Sem_160102_predefined_functions_017 {
    type integer I with { variant "32 bit"};

    type component GeneralComp {
    }

    testcase TC_Sem_160102_predefined_functions_017 () runs on GeneralComp {
        var bitstring v_test := int2bit(0, 32);
		var I v_decoded;
		var integer v_res := decvalue(v_test, v_decoded);
		// expected result:
		// v_res: 0 (success)
		// v_decoded: 0
		// v_test: ''B (fully decoded)
		if (match(v_res, 0) and match(v_decoded, 0) and match(lengthof(v_test), 0)) {
			setverdict(pass);
		} else {
			setverdict(fail, "Unexpected decoding result");
		}
    }

    control{
        execute(TC_Sem_160102_predefined_functions_017());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue_unichar function works properly
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/

/* The following requirements are tested:  

 * this test focuses on the predefined functions decvalue_unichar (utf-16 big endian)*/



module Sem_160102_predefined_functions_077 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_077 () runs on GeneralComp {

    
    //encoded text:
   var universal charstring v_enc := encvalue_unichar(123,"UTF-16BE");


    //decode:
    var integer v_test_dec;
    var integer v_res:= decvalue_unichar(v_enc,v_test_dec,"UTF-16BE"); //decode (UTF-16 big endian)
    
    if (v_res == 0) {
          setverdict(pass, "Decoded ", v_enc , " with result ", v_res);
    } else {
          setverdict(fail, "Unexpected decoding result: Decoded ", v_enc , " with result ", v_res);
    }

   }

    control{

        execute(TC_Sem_160102_predefined_functions_077());

    }

}/***************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_012 {
    type enumerated EnumeratedType {e_black, e_white};
    type enumerated EnumeratedTypeWithLabels1 {e_black (-1), e_red (1), e_white(0) , e_yellow };  //e_yellow is 2

    type component GeneralComp {
    }

    testcase TC_Sem_160102_predefined_functions_012 () runs on GeneralComp {
        var EnumeratedType vl_enum_black := e_black;
        var EnumeratedType vl_enum_white := e_white;
        var EnumeratedTypeWithLabels1 vl_enum1_red := e_white;
        var EnumeratedTypeWithLabels1 vl_enum1_yellow := e_black;

        const EnumeratedType c_enum_black := e_black;
        const EnumeratedType c_enum_white := e_white;
        const EnumeratedTypeWithLabels1 c_enum1_red := e_red;
        const EnumeratedTypeWithLabels1 c_enum1_yellow := e_yellow;
      
        int2enum(1,vl_enum1_red);
        int2enum(2,vl_enum1_yellow);
        
        setverdict(pass);
        
        if (vl_enum1_red != c_enum1_red) {
            setverdict(fail, "cannot decode e_red");
        }

        if (vl_enum1_yellow != c_enum1_yellow) {
            setverdict(fail, "cannot decode e_yellow");
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_012());
    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an UTF-8 universal charstring value to an octetstring.*/


module Sem_160102_predefined_functions_027 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_027 () runs on GeneralComp {
       
    // universal charstring:    
        var universal charstring v_0 := "ABC123abc";
        
    // predefined function for universal charstring to octetstring conversion:     
        var octetstring v_encoded := unichar2oct(v_0,"UTF-8");        //"UTF-8", expected value: '414243313233616263'O
        var octetstring v_1 := '414243313233616263'O;
  

        if( match(v_encoded,v_1)
        ) {
            setverdict(pass,"Encoded value for: ",v_0, " is ", v_encoded);
        }
        else {
            setverdict(fail,"encoded value is: ", v_encoded, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_027());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue and decvalue_unichar function works properly in case of uninitialized encode value is given
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * all actual in and inout parameters shall be initialized with the following exceptions:
 * 16.1.2. Restriction a.3 : the encoded_value parameter of the decvalue and decvalue_unichar function may be uninitialized.*/

module Sem_160102_predefined_functions_080 {
    type enumerated E { one(1), two(2), three(3) } with { variant "32 bit"};

    type component GeneralComp {
    }

    testcase TC_Sem_160102_predefined_functions_080 () runs on GeneralComp {
        
        var bitstring v_test;    // uninitialized value for encoded_value parameter decvalue() input
        var universal charstring v_test_enc_8; // uninitialized value encoded_value parameter for decvalue_unichar() input
		var E v_decoded;
        var E v_decoded_8;
        
		var integer v_res := decvalue(v_test, v_decoded);
        var integer v_res_8 := decvalue_unichar(v_test_enc_8, v_decoded_8, "UTF-8");
      
        if(match(v_res,1)){
            setverdict(pass,"Decoded ", v_decoded , " with result ", v_res);
        }else{
             setverdict(fail,"Decode failed ", v_decoded , " with result ", v_res);
        }
        
        if(match(v_res_8,1)){
            setverdict(pass,"Decoded ", v_decoded_8 , " with result ", v_res_8);
        }else{
             setverdict(fail,"Decode failed ", v_decoded_8 , " with result ", v_res_8);
        }
    }
    control{
        execute(TC_Sem_160102_predefined_functions_080());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined encvalue_unichar function works properly in case of encoding universal charstring
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/

/* The following requirements are tested:  

 * this test focuses on the predefined functions encvalue_unichar (utf8)*/



module Sem_160102_predefined_functions_063 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_063 () runs on GeneralComp {

    var charstring v_test := "abc";

     //Encoding:  

    var universal charstring v_test_enc_8 := encvalue_unichar(v_test,"UTF-8"); //encode to universal charstring UTF-8
    setverdict(pass,"Encoded value: ", v_test_enc_8);

    }



    control{

        execute(TC_Sem_160102_predefined_functions_063());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined function isvalue() works properly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * check that isvalue() predefined function works properly
 */


module Sem_160102_predefined_functions_083 {
    
    type component GeneralComp {
    }
    
    testcase TC_Sem_160102_predefined_functions_083 () runs on GeneralComp {
   	
    var boolean v_res;
        
    template charstring Mytemaplate:= "1234ABCD";     

    
        
    v_res := isvalue(Mytemaplate);   //template, expected result: true

        
        
        if ( match(v_res, true)) {setverdict(pass," isvalue(Mytemaplate): ", v_res);}
           else{setverdict(fail," isvalue(Mytemaplate):", v_res, " expected result: true");}

    }     


    control{
        execute(TC_Sem_160102_predefined_functions_083());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * this test investigates that IUT correctly evaluates predefined function any2unistr, 
 * the invalue parameter of the any2unistr function may be uninitialized or partially initialized;
*/

module Sem_160102_predefined_functions_045 {
	    
    type record of integer MyRoI;
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_045 () runs on GeneralComp {
       
        template MyRoI v_3 := *;     //template record of integer anyvalue
           
        //template record of integer anyvalue (*)  
        if(match(any2unistr(v_3),"*")) { setverdict(pass,"Result: ",any2unistr(v_3));}
         else{setverdict(fail,"Result is: ",any2unistr(v_3), " Expected:*");}
               
    }

    control{
        execute(TC_Sem_160102_predefined_functions_045());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_048 {
	
    
    type component GeneralComp {
    }

    /*Type definition:*/
    type record of integer MyRecofInt;

    testcase TC_Sem_160102_predefined_functions_048 () runs on GeneralComp {
    
       var template MyRecofInt v_1 := {1,2,3,4,5}; // specific value of integer type
        
       if ( match(istemplatekind(v_1, "value"), true)) {setverdict(pass," value: ", istemplatekind(v_1, "value"));}
           else{setverdict(fail,"  value:",istemplatekind(v_1, "value"), " expected result: true");}

    }
    control{

        execute(TC_Sem_160102_predefined_functions_048());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue_unichar function works properly
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/

/* The following requirements are tested:  

 * this test focuses on the predefined functions decvalue_unichar (utf-8)*/



module Sem_160102_predefined_functions_070 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_070 () runs on GeneralComp {

    
    //encoded text:
   var universal charstring v_enc := encvalue_unichar(123,"UTF-8");


    //decode:
    var integer v_test_dec;
    var integer v_res:= decvalue_unichar(v_enc,v_test_dec,"UTF-8"); //decode (UTF-8)
    
    if (v_res == 0) {
          setverdict(pass, "Decoded ", v_enc , " with result ", v_res);
    } else {
          setverdict(fail, "Unexpected decoding result: Decoded ", v_enc , " with result ", v_res);
    }

   }

    control{

        execute(TC_Sem_160102_predefined_functions_070());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined function isvalue() works properly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * check that isvalue() predefined function works properly
 */


module Sem_160102_predefined_functions_089 {
    
    type record MyRec{
    integer field1,
    integer field2 optional}
    
    type record MyRec2 {
     MyRec field1,
     integer field2
    }
    
    type component GeneralComp {
    }
    
    testcase TC_Sem_160102_predefined_functions_089() runs on GeneralComp {
   	
    var boolean v_res;
        
    var MyRec2 MyRecValue := {{1,-},1};

    
        
    v_res := isvalue(MyRecValue.field1.field2);  //nested omit, expected result: false  

    
     if ( match(v_res, false)) {setverdict(pass," isvalue(MyRecValue.field1.field2): ", v_res);}
           else{setverdict(fail," isvalue(MyRecValue.field1.field2):", v_res, " expected result: true");}
        
    }


    control{
        execute(TC_Sem_160102_predefined_functions_089());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_052 {
	
    
    type component GeneralComp {
    }

    /*Type definition:*/
    type record of integer MyRecofInt;

    testcase TC_Sem_160102_predefined_functions_052 () runs on GeneralComp {

      var template MyRecofInt v_5 := *; //anyvalue (*)
        
      if ( match(istemplatekind(v_5, "AnyValueOrNone"), true)) {setverdict(pass," AnyValueOrNone: ", istemplatekind(v_5, "AnyValueOrNone"));}
           else{setverdict(fail,"  AnyValueOrNone:",istemplatekind(v_5, "AnyValueOrNone"), " expected result: true");}

    }
    control{

        execute(TC_Sem_160102_predefined_functions_052());

    }

}/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_022 {
	type union U { integer f1, octetstring f2 }
	
type component GeneralComp {	
}
	

testcase TC_Sem_160102_predefined_functions_022 () runs on GeneralComp {
	template U template1 := ?;
	var boolean v_i;

 	v_i:=ischosen(template1.f1);	//function returns false value
		if(v_i==false) {
			setverdict(pass);
		} else {
			setverdict(fail, "Unexpected decoding result");
		}
}


control{

    execute(TC_Sem_160102_predefined_functions_022());

}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined function get_stringencoding works properly 
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * The get_stringencoding function analyses the encoded_value and returns the UCS encoding scheme.*/


module Sem_160102_predefined_functions_081 {
    
    type component GeneralComp {
    }
       
    testcase TC_Sem_160102_predefined_functions_081 () runs on GeneralComp {
   		
      
   var octetstring v_test := '414243C3A9C3BC'O;    //UTF-8 encoded octetstring. The decoded value is: ABC

   var charstring v_get := get_stringencoding(v_test);    // expected result: "UTF8"
       
	if (match(v_get , ("UTF-8","<unknown>"))) {
			setverdict(pass,"Decoded: ",v_get);
		} else {
			setverdict(fail, "Unexpected result: ", v_get);
		}
    }     



    control{
        execute(TC_Sem_160102_predefined_functions_081());
    }
}/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_004 {
	
    type component GeneralComp {
    }

    testcase TC_Sem_160102_predefined_functions_004 () runs on GeneralComp {
        var charstring v_example:="example text string";

        if( match(regexp(v_example,charstring:"?+(text)?+",0), "text") and   //inline templates in this function are allowed by BNF 165.
            match(regexp(v_example,charstring:"(?+)(text)(?+)",2), " string") and
            match(regexp(v_example,charstring:"((?+)(text)(?+))",0), "example text string") and
            match(substr('00100110'B,3,4), '0011'B) and
            match(substr('ABCDEF'H,2,3), 'CDE'H) and
            match(substr('01AB23CD'O,1,2), 'AB23'O) and
            match(replace('00000110'B,1,3,'111'B), '01110110'B) and
            match(replace('ABCDEF'H,0,2,'123'H), '123CDEF'H) and
            match(replace('01AB23CD'O,2,1,'FF96'O), '01ABFF96CD'O) and
            match(replace(v_example,0,7,"my"), "my text string")
        ) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_004());
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an UTF-32 universal charstring value to a Little endian octetstring.*/

module Sem_160102_predefined_functions_031 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_031 () runs on GeneralComp {
       
    // universal charstring:    
        var universal charstring v_0 := "ABC";
        
    // predefined function for universal charstring to octetstring conversion:     
        var octetstring v_encoded := unichar2oct(v_0, "UTF-32LE");      //"UTF-32" little endian, expected value:'0000 0041 0000 0042 0000 0043'O 
        var octetstring v_1 := '000000410000004200000043'O;
  

        if( match(v_encoded,v_1)
        ) {
            setverdict(pass,"Encoded value for: ",v_0, " is ", v_encoded);
        }
        else {
            setverdict(fail,"encoded value is: ", v_encoded, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_031());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * this test investigates that IUT correctly evaluates predefined function any2unistr, 
 * the invalue parameter of the any2unistr function may be uninitialized or partially initialized;
*/

module Sem_160102_predefined_functions_043 {
	    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_043 () runs on GeneralComp {
       
         var integer v_1;    //uninitialized value
           
        //uninitialized value
        if( match(any2unistr(v_1),"UNINITIALIZED")) { setverdict(pass,"Result: ",any2unistr(v_1));}
         else{setverdict(fail,"Result is: ",any2unistr(v_1), " Expected: UNINITIALIZED");}
       
    }

    control{
        execute(TC_Sem_160102_predefined_functions_043());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_054 {
	
    
    type component GeneralComp {
    }
    type set of integer MySet(0 .. 10);

    testcase TC_Sem_160102_predefined_functions_054 () runs on GeneralComp {

     var template MySet v_7 := superset (1, 2, 3); //superset 
        
     if ( match(istemplatekind(v_7, "superset"), true)) {setverdict(pass," superset: ", istemplatekind(v_7, "superset"));}
           else{setverdict(fail," superset:",istemplatekind(v_7, "superset"), " expected result: true");}
    }
    control{

        execute(TC_Sem_160102_predefined_functions_054());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue_unichar function works properly
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/
//NOT working with TestCast 6.8.2.5 -test fails 

/* The following requirements are tested:  

 * this test focuses on the predefined functions decvalue_unichar (utf-32) with charstring input*/



module Sem_160102_predefined_functions_075 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_075 () runs on GeneralComp {

    
    //encoded text:
   var universal charstring v_enc := encvalue_unichar("aBc","UTF-32"); //encode UTF-32


    //decode:
    var charstring v_test_dec;
    var integer v_res:= decvalue_unichar(v_enc,v_test_dec,"UTF-32"); //decode (UTF-32)
    
    if (v_res == 0) {
          setverdict(pass, "Decoded ", v_enc , " with result ", v_res);
    } else {
          setverdict(fail, "Unexpected decoding result: Decoded ", v_enc , " with result ", v_res);
    }

   }

    control{

        execute(TC_Sem_160102_predefined_functions_075());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined encvalue_unichar function works properly in case of encoding universal charstring
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/

/* The following requirements are tested:  

 * this test focuses on the predefined functions encvalue_unichar (utf-32 little endian)*/



module Sem_160102_predefined_functions_068 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_068 () runs on GeneralComp {

    var charstring v_test := "abc";

     //Encoding:  

    var universal charstring v_test_enc_32LE := encvalue_unichar(v_test,"UTF-32LE"); //encode to universal charstring UTF-32 little endian
    setverdict(pass,"Encoded value: ", v_test_enc_32LE);

    }

    control{

        execute(TC_Sem_160102_predefined_functions_068());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue_unichar function works properly
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/

/* The following requirements are tested:  

 * this test focuses on the predefined functions decvalue_unichar (utf-16) with charstring input*/



module Sem_160102_predefined_functions_073 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_073 () runs on GeneralComp {

    
    //encoded text:
    var universal charstring v_test := "aBcDe";
    var universal charstring v_enc := encvalue_unichar(v_test,"UTF-16");


    //decode:
    var charstring v_test_dec;
    var integer v_res:= decvalue_unichar(v_enc,v_test_dec,"UTF-16"); //decode (UTF-16)
    
    if (v_res == 0) {
          setverdict(pass, "Decoded ", v_test_dec , " with result ", v_res);
    } else {
          setverdict(fail, "Unexpected decoding result: Decoded ", v_test_dec, " with result ", v_res);
    }

   }

    control{

        execute(TC_Sem_160102_predefined_functions_073());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined function isvalue() works properly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * check that isvalue() predefined function works properly
 */


module Sem_160102_predefined_functions_085 {
    
    type integer address;
    
    type component GeneralComp {
    }
    
    testcase TC_Sem_160102_predefined_functions_085 () runs on GeneralComp {
   	
    var boolean v_res;
        
    var address MyAddr := null;

    
        
    v_res := isvalue(MyAddr);        //address, expected result: true

        
        
    if ( match(v_res, true)) {setverdict(pass," isvalue(MyAddr): ", v_res);}
           else{setverdict(fail," isvalue(MyAddr):", v_res, " expected result: true");}

    }     


    control{
        execute(TC_Sem_160102_predefined_functions_085());
    }
}/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

module Sem_160102_predefined_functions_007 {
    type enumerated MyEnumeratedType {e_black, e_white};
    type record of integer IntegerList;

    type record MyRecord {
        boolean field1,
        record of integer field2,
        integer field3,
        MyEnumeratedType field4 optional
    }

    type component GeneralComp {
    }
	
    testcase TC_Sem_160102_predefined_functions_007 () runs on GeneralComp {
        template MyRecord template1 := {
            field1 := true,
            field2 := { permutation(2, 3), ? },
            field3 := 5,
            field4 := omit
        }
        template MyRecord template2 := {
            field1 := true,
            field2 := {permutation(2, 3)},
            field3 := 6,
            field4 := omit
        }
        template IntegerList template3 := { 1, 2, 3, * } length(1..3) ;

        if(lengthof(charstring : "test")!=4) {
          setverdict(fail, "lengthof(charstring : ""test"")");
        }
        if (lengthof(universal charstring : "test")!=4) {
          setverdict(fail, "lengthof(universal charstring : ""test"")");
        }
        if (lengthof('010'B)!=3) {		// STF409: value definitions are interpreted as templates here
           setverdict(fail, "lengthof('010'B)");
        }
        if (lengthof('55'H)!=2) {		// STF409: value definitions are interpreted as templates here
           setverdict(fail, "lengthof('55'H)");
        }
        if (lengthof('55'O)!=1) {		// STF409: value definitions are interpreted as templates here
          setverdict(fail, "lengthof('55'O)");
        }
        if  (lengthof(charstring : pattern "t??t")!=4) {
          setverdict(fail, "lengthof(charstring : pattern ""t??t"")");
        }
        if  (lengthof(bitstring : '1??1'B)!=4) {
          setverdict(fail, "lengthof(bitstring : '1??1'B)");
        }
        if  (lengthof(hexstring : '1*1'H length(8))!=8) {
        	setverdict(fail, "lengthof(hexstring : '1*1'H length(8))");
        }
        if  (lengthof(octetstring : '00?FF'O length(3))!=3) {
        	setverdict(fail, "lengthof(octetstring : '00?FF'O length(3))");
        }
        if  (lengthof(octetstring : 'AB?'O)!=2) {
        	setverdict(fail, "lengthof(octetstring : 'AB?'O)");
        }
        if  (sizeof(template1.field2)!=3) {
        	setverdict(fail, "sizeof(", template1.field2, ")");
        }
        if  (sizeof(template2.field2)!=2) {
        	setverdict(fail, "sizeof(", template2.field2, ")");
        }
        if  (lengthof(template3)!=3) {
        	setverdict(fail, "lengthof(", template3, ")");
        }
        setverdict(pass);
    }

    control{
        execute(TC_Sem_160102_predefined_functions_007());
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an octetstring to an UTF-16 Little Endian byte order universal charstring.*/


module Sem_160102_predefined_functions_038 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_038 () runs on GeneralComp {
       
    //octetstring:    
        var octetstring v_0 := '004100420043'O;
        
    // predefined function for universal charstring to octetstring conversion:     
        var universal charstring v_decode := oct2unichar(v_0,"UTF-16LE");        //expected value: ABC
        var universal charstring v_1 := "ABC"; 

        if( match(v_decode,v_1)
        ) {
            setverdict(pass,"Decoded value for: ",v_0, " is ", v_decode);
        }
        else {
            setverdict(fail,"encoded value is: ", v_decode, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_038());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an octetstring to an UTF-16 encoded universal charstring.*/


module Sem_160102_predefined_functions_036 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_036 () runs on GeneralComp {
       
    //octetstring:    
        var octetstring v_0 := '004100420043'O;
        
    // predefined function for universal charstring to octetstring conversion:     
        var universal charstring v_decode := oct2unichar(v_0,"UTF-16");        //expected value: ABC
        var universal charstring v_1 := "ABC"; 

        if( match(v_decode,v_1)
        ) {
            setverdict(pass,"Decoded value for: ",v_0, " is ", v_decode);
        }
        else {
            setverdict(fail,"encoded value is: ", v_decode, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_036());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue function works properly in case of decoding failure
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirements are tested:
// (C.5.2) 
// The decvalue function decodes a bitstring into a value. The test system shall suppose that 
// the bitstring encoded_value represents an encoded instance of the actual type of decoded_value.
// If the decoding was unsuccessful, the actual parameters for encoded_value and decoded_value are 
// not changed. The function shall return an integer value to indicate success or failure of the 
// decoding below:
//  The return value 1 indicates an unspecified cause of decoding failure.

module Sem_160102_predefined_functions_019 {
    type enumerated E { one(1), two(2), three(3) } with { variant "32 bit"};

    type component GeneralComp {
    }

    testcase TC_Sem_160102_predefined_functions_019 () runs on GeneralComp {
        var bitstring v_test := int2bit(0, 32);
		var E v_decoded;
		var integer v_res := decvalue(v_test, v_decoded);
		// expected result:
		// v_res: 1 (failure, unspecified) -> no named value corresponding to ordinal number 0
		// v_decoded: uninitialized
		// v_test: original 32-bit value
		if (match(v_res, 1) and not isbound(v_decoded) and match(lengthof(v_test), 32)) {
			setverdict(pass);
		} else {
			setverdict(fail, "Unexpected decoding result");
		}
    }

    control{
        execute(TC_Sem_160102_predefined_functions_019());
    }
}/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_006 {
	
    type component GeneralComp {
    }
	
    testcase TC_Sem_160102_predefined_functions_006 () runs on GeneralComp {
        var float v_random1;

        v_random1:=rnd(0.0);
        if( match(rnd(0.0), v_random1) and not match(rnd(1.0), v_random1) ) {
            setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_006());
    }

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue_unichar function works properly
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/

/* The following requirements are tested:  

 * this test focuses on the predefined functions decvalue_unichar (utf-16 little endian)*/



module Sem_160102_predefined_functions_076 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_076 () runs on GeneralComp {

    
    //encoded text:
   var universal charstring v_enc := encvalue_unichar(123,"UTF-16");


    //decode:
    var integer v_test_dec;
    var integer v_res:= decvalue_unichar(v_enc,v_test_dec,"UTF-16LE"); //decode (UTF-16 little endian)
    
    if (v_res == 0) {
          setverdict(pass, "Decoded ", v_enc , " with result ", v_res);
    } else {
          setverdict(fail, "Unexpected decoding result: Decoded ", v_enc , " with result ", v_res);
    }

   }

    control{

        execute(TC_Sem_160102_predefined_functions_076());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an UTF-16 universal charstring value to a Big endian octetstring.*/

module Sem_160102_predefined_functions_032 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_032 () runs on GeneralComp {
       
    // universal charstring:    
        var universal charstring v_0 := "AB";
        
    // predefined function for universal charstring to octetstring conversion:     
        var octetstring v_encoded := unichar2oct(v_0, "UTF-16BE");      //"UTF-16" Big endian, expected value:'42004100'O; 
        var octetstring v_1 := '42004100'O;
  

        if( match(v_encoded,v_1)
        ) {
            setverdict(pass,"Encoded value for: ",v_0, " is ", v_encoded);
        }
        else {
            setverdict(fail,"encoded value is: ", v_encoded, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_032());
    }
}/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_005 {
    type enumerated MyEnumeratedType {e_black, e_white, e_green};

    type record MyRecord {
        record {
            boolean innerField1 optional,
            integer innerField2 optional
        } field1 optional,
        integer field2,
        integer field3,
        MyEnumeratedType field4 optional
    }
	
    type component GeneralComp {
    }
	
    testcase TC_Sem_160102_predefined_functions_005 () runs on GeneralComp {
        var MyRecord v_record1 := {
				field1 := {},
				field2 := 2,
				field3 := 3,
				field4 := omit
			};
        var bitstring v_encoded;
        var MyRecord v_decoded;
	
        v_encoded:=encvalue(v_record1);
        if( match(decvalue(v_encoded,v_decoded), 0) and
            match(v_record1,v_decoded)
        ) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
    } with {
        optional "implicit omit";
    }

    control{
        execute(TC_Sem_160102_predefined_functions_005());
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue function works properly in case of encoding universal charstring
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/

/* The following requirements are tested:  

 * this test focuses on the predefined functions encvalue_unichar (utf-16) */



module Sem_160102_predefined_functions_065 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_065 () runs on GeneralComp {

    var charstring v_test := "abc";

     //Encoding:  

    var universal charstring v_test_enc_32 := encvalue_unichar(v_test,"UTF-32"); //encode to universal charstring UTF-32
    setverdict(pass,"Encoded value: ", v_test_enc_32);

    }



    control{

        execute(TC_Sem_160102_predefined_functions_065());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an octetstring to universal charstring.*/


module Sem_160102_predefined_functions_034 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_034 () runs on GeneralComp {
       
    //octetstring:    
        var octetstring v_0 := '414243313233616263'O;
        
    // predefined function for universal charstring to octetstring conversion:     
        var universal charstring v_decode := oct2unichar(v_0);        //expected value: ABC123abc
        var universal charstring v_1 := "ABC123abc"; 

        if( match(v_decode,v_1)
        ) {
            setverdict(pass,"Decoded value for: ",v_0, " is ", v_decode);
        }
        else {
            setverdict(fail,"encoded value is: ", v_decode, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_034());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * this test investigates that IUT correctly evaluates predefined function any2unistr, 
 * the invalue parameter of the any2unistr function may be uninitialized or partially initialized;
*/

module Sem_160102_predefined_functions_046 {
	    
        type record MyRec {
        integer field1,
        boolean field2,
        integer field3 optional
    };
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_046 () runs on GeneralComp {
       
       template MyRec v_4 := {1,false,-}; // record containing integer, boolean and optional elements
           
        // record containing integer, boolean and optional elements
        if(match(any2unistr(v_4),pattern "{ field1 := 1, field2 := false, field3 := UNINITIALIZED }" )) { 
          setverdict(pass,"Result: ",any2unistr(v_4));}
         else{setverdict(fail,"Result is: ",any2unistr(v_4), " Expected:{ field1 := 1, field2 := false, field3 := UNINITIALIZED }");}        
    }

    control{
        execute(TC_Sem_160102_predefined_functions_046());
    }
}/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160102_predefined_functions_008 {
    type enumerated MyEnumeratedType {e_black, e_white, e_green};

    type record MyRecord {
        record {
            boolean innerField1 optional,
            integer innerField2 optional
        } field1 optional,
        integer field2,
        integer field3,
        MyEnumeratedType field4 optional
    }
	
    type component GeneralComp {
    }
	
    testcase TC_Sem_160102_predefined_functions_008 () runs on GeneralComp {
        template MyRecord template1 := {
			field1 := {?, *},
			field2 := 2,
			field3 := 3,
			field4 := (e_black, e_white)  ifpresent
		}

        if (ispresent(template1.field1.innerField2)) {	// not present
            setverdict(fail);
        } else {
            setverdict(pass);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_008());
    }
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * this test investigates that IUT correctly evaluates predefined function any2unistr, 
 * the invalue parameter of the any2unistr function may be uninitialized or partially initialized;
*/

module Sem_160102_predefined_functions_042 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_042 () runs on GeneralComp {
       
     
        var integer v_0 := 100; //integer with value

      
        //integer with value
        if( match(any2unistr(v_0),"100")) { setverdict(pass,"Result: ",any2unistr(v_0));}
        else{setverdict(fail,"Result is: ",any2unistr(v_0), " Expected: 100");}
       
    }

    control{
        execute(TC_Sem_160102_predefined_functions_042());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that predefined decvalue_unichar function works properly
 ** @verdict  pass accept, ttcn3verdict:pass

 ***************************************************/

/* The following requirements are tested:  

 * this test focuses on the predefined functions decvalue_unichar (utf-16)*/



module Sem_160102_predefined_functions_072 {
    
    type component GeneralComp {

    }

    testcase TC_Sem_160102_predefined_functions_072 () runs on GeneralComp {

    
    //encoded text:
   var universal charstring v_enc := encvalue_unichar(123,"UTF-16");


    //decode:
    var integer v_test_dec;
    var integer v_res:= decvalue_unichar(v_enc,v_test_dec,"UTF-16"); //decode (UTF-16)
    
    if (v_res == 0) {
          setverdict(pass, "Decoded ", v_enc , " with result ", v_res);
    } else {
          setverdict(fail, "Unexpected decoding result: Decoded ", v_enc , " with result ", v_res);
    }

   }

    control{

        execute(TC_Sem_160102_predefined_functions_072());

    }

}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested:
 * This function converts an UTF-16 universal charstring value to a Little endian octetstring.*/

module Sem_160102_predefined_functions_030 {
	
    
    type component GeneralComp {
    }


    testcase TC_Sem_160102_predefined_functions_030 () runs on GeneralComp {
       
    // universal charstring:    
        var universal charstring v_0 := "ABC";
        
    // predefined function for universal charstring to octetstring conversion:     
        var octetstring v_encoded := unichar2oct(v_0, "UTF-16LE");      //"UTF-16" little endian, expected value:'0041 0042 0043'O; 
        var octetstring v_1 := '004100420043'O;
  

        if( match(v_encoded,v_1)
        ) {
            setverdict(pass,"Encoded value for: ",v_0, " is ", v_encoded);
        }
        else {
            setverdict(fail,"encoded value is: ", v_encoded, " expected ", v_1);
        }
    }

    control{
        execute(TC_Sem_160102_predefined_functions_030());
    }
}/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:16.1.2, Ensure that the IUT recognizes predefined functions and correctly evaluates them (as specified by Annex C.3.5)
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

/* The following requirements are tested: 
 * this test investigates that IUT correctly evaluates predefined function istemplateking().*/

module Sem_160102_predefined_functions_053 {
	
    
    type component GeneralComp {
    }

    testcase TC_Sem_160102_predefined_functions_053 () runs on GeneralComp {

     var template integer v_6 := (-100 .. -1);  // tamplate with ranged values 
        
       if ( match(istemplatekind(v_6, "range"), true)) {setverdict(pass," range: ", istemplatekind(v_6, "range"));}
           else{setverdict(fail," range:",istemplatekind(v_6, "range"), " expected result: true");}
    }
    control{

        execute(TC_Sem_160102_predefined_functions_053());

    }

}/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.1, Ensure that the IUT correctly handles function definitions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1601_toplevel_001 {


type component GeneralComp {	    	    
}
	
function f_test ( integer p_integer := 0 ) return integer {

 return p_integer+1;
 return p_integer+2;
}

testcase TC_Sem_1601_toplevel_001 () runs on GeneralComp {

 	if(f_test(1)==2) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
 
}


control{

    execute(TC_Sem_1601_toplevel_001());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.1, Ensure that the IUT correctly handles function definitions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1601_toplevel_003 {


type component GeneralComp {	
	var integer v_comp:=1;    	    
}
	
function f_test ( integer p_integer := 0 ) runs on GeneralComp return integer {

 return f_two(p_integer);
}

function f_two ( integer p_integer := 0 ) runs on GeneralComp return integer {

 return p_integer+v_comp;
}


testcase TC_Sem_1601_toplevel_003 () runs on GeneralComp {

 	if(f_test(1)==2) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
 
}


control{

    execute(TC_Sem_1601_toplevel_003());

}

}
/***************************************************
 ** @author   STF 470 
 ** @version  0.0.1
 ** @purpose  1:16.1, Ensure that the IUT correctly handles function definitions
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1601_toplevel_002 {
 
    type component GeneralComp {
    }
	
    function f_test ( template octetstring p_ostring ) return template octetstring {

        return p_ostring & p_ostring;
    }

    testcase TC_Sem_1601_toplevel_002 () runs on GeneralComp {

        if( match('FFFFFFFF'O, f_test('FF?'O)) ) {
            setverdict(pass);
        }
        else {
            setverdict(fail);
        }
 
    }


    control{

        execute(TC_Sem_1601_toplevel_002());

    }

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.1.3, Ensure that the IUT recognizes external functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ** @configuration  external_functions
 ***************************************************/
module Sem_160103_external_functions_002 {

    type record MyRecord {
        integer field1,
        integer field2,
        integer field3
    }

    type port TestPort message {
        inout MyRecord
    }
	
    type component GeneralComp {
    }
	/**
	 * @return p_in + 1
	 */
    external function xf_Sem_160103_external_functions_002(inout integer p_in) return integer;

    testcase TC_Sem_160103_external_functions_002 () runs on GeneralComp {
        var integer v_input := 5;
        var integer v_result;

        v_result := xf_Sem_160103_external_functions_002(v_input);
        if(v_result==6) { setverdict(pass) }
        else { setverdict(fail) }
    }

    control{

        execute(TC_Sem_160103_external_functions_002());

    }

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.1.3, Ensure that the IUT recognizes external functions
 ** @verdict  pass accept, ttcn3verdict:pass
 ** @configuration  external_functions
 ***************************************************/
module Sem_160103_external_functions_001 {
	
    type component GeneralComp {
    }
	
	/**
	 * @return always 1
	 */
    external function xf_Sem_160103_external_functions_001() return integer;

    testcase TC_Sem_160103_external_functions_001 () runs on GeneralComp {
        var integer v_i;

        v_i := xf_Sem_160103_external_functions_001();
        
        if (v_i == 1) {
	        setverdict(pass);
        } else {
            setverdict(fail);
        }
    }

    control{

        execute(TC_Sem_160103_external_functions_001());

    }

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:16.1.1, Ensure that the IUT correctly handles function invocations
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_160101_invoking_functions_001 {


type component GeneralComp {	
 var integer v_gc:=0;    	    
}
	
function f_test ( integer p_integer := 0 ) runs on GeneralComp return integer {

 v_gc:=v_gc+p_integer;
 return v_gc;
}

testcase TC_Sem_160101_invoking_functions_001 () runs on GeneralComp {
	var integer v_result:=0;

	f_test();
	f_test(1);
	v_result:=f_test(1);
 	if( match(v_result, 2) and match(f_test(), 2) ) {
        setverdict(pass);
    }
    else {
        setverdict(fail);
    }		
 
}


control{

    execute(TC_Sem_160101_invoking_functions_001());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.2, Ensure that the IUT properly evaluates if-else statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1902_if_else_statement_002 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1902_if_else_statement_002 () runs on GeneralComp{
 var integer v_i:=1;
 
 if ( match(v_i, 2) ) {
   setverdict(fail);
 }
 else if(match(v_i, 1)) { setverdict(pass) };  //else if shorthand notation
}


control{

    execute(TC_Sem_1902_if_else_statement_002());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.2, Ensure that the IUT properly evaluates if-else statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1902_if_else_statement_001 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1902_if_else_statement_001 () runs on GeneralComp{
 var integer v_i:=1;
 var integer v_j:=2;
 
 if ( v_i==1 ) {		//testing of nested if-else statement
  if( v_j==1) {
   setverdict(fail);
  }
  else {
   setverdict(pass);
  }
 }
 else {
  setverdict(fail);
 }
}


control{

    execute(TC_Sem_1902_if_else_statement_001());

}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:19.1, Ensure that the right-hand side of the assignment of a structured value is evaulted correctly
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/

module Sem_1901_assignments_003{
	
type component GeneralComp {	
}
    
 type record Myrec{
     integer field1,
     float   field2
 };
	
testcase TC_Sem_1901_assignments_003 () runs on GeneralComp system GeneralComp {
 var Myrec v_j :={11,1.1};    //fully initialized variable
 var Myrec v_i;        

   v_i:=v_j;	//assignment
    
 if (match(v_i,v_j)) {
  setverdict(pass,v_i);
 }
 else {
  setverdict(fail,v_i);
 }
}


control{

    execute(TC_Sem_1901_assignments_003());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.1, Ensure that the IUT properly evaluates assignment statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1901_assignments_001 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1901_assignments_001 () runs on GeneralComp system GeneralComp {
 var integer v_i;
 v_i:=3*(2+3*3);	//validation of the order of evaluating assignment expressions
 
 if ( v_i==33 ) {
  setverdict(pass);
 }
 else {
  setverdict(fail);
 }
}


control{

    execute(TC_Sem_1901_assignments_001());

}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:19.1, Ensure that Ensure that the right-hand side of the assignment of a structured value is evaulted correctly
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/

//Restriction d) Using a reference to an omitted field in the right-hand side of the assignment has the same effect as using the omit keyword.

module Sem_1901_assignments_004{
	
type component GeneralComp {	
}
    
 type record Myrec{
     integer field1,
     float   field2 optional
 };
    
type record Myrec_2{
     float   field optional
 };
	
testcase TC_Sem_1901_assignments_004 () runs on GeneralComp system GeneralComp {
 var Myrec v_j :={11,omit};    
 var Myrec_2 v_i;        

   v_i.field:=v_j.field2;	//assignment
    
 if (match(v_i.field,omit)) {
  setverdict(pass,v_i);
 }
 else {
  setverdict(fail,v_i);
 }
}


control{

    execute(TC_Sem_1901_assignments_004());

}

}
/***************************************************
 ** @author   STF 487 
 ** @version  0.0.1
 ** @purpose  1:19.1, Ensure that uninitialized at the right-hand side of the assignment shall also become uninitialized at the left-hand side
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/

module Sem_1901_assignments_002{
	
type component GeneralComp {	
}
    
 type record Myrec{
     integer field1,
     float   field2
 };
	
testcase TC_Sem_1901_assignments_002 () runs on GeneralComp system GeneralComp {
 var Myrec v_i :={11,1.1};    //fully initialized variable
 var Myrec v_j :={12};        //partly initialized variable

   v_i:=v_j;	//assignment, v_i is now partly initialized variable
    
 if (isvalue(v_i)) {
  setverdict(fail,v_i);
 }
 else {
  setverdict(pass,v_i);
 }
}


control{

    execute(TC_Sem_1901_assignments_002());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.11, Ensure that the IUT properly evaluates log statements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1911_log_statement_004 {
	
type component GeneralComp {	
}

function f_square(integer p_arg) return integer {
 return p_arg*p_arg;
}
	
testcase TC_Sem_1911_log_statement_004 () runs on GeneralComp{
 var integer v_i;
 
 for(v_i:=1; v_i<10; v_i:= v_i+1) {
  log("Actual value of v_i squared: ", f_square(v_i) );	//actual value of v_i squared is expected, log output is not validated by the script
 }
 
 setverdict(pass)
 
}


control{

    execute(TC_Sem_1911_log_statement_004());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.11, Ensure that the IUT properly evaluates log statements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1911_log_statement_005 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1911_log_statement_005 () runs on GeneralComp{
 var integer v_i;
 timer t_1;
 
 t_1.start(1.0);
 log("Actual timer state: ", t_1);			//running state is expected, log output is not validated by the script
 log("Is timer running? ", t_1.running);	//true is expected, log output is not validated by the script
 
 for(v_i:=1; v_i<10; v_i:= v_i+1) {
  log("Actual timer value: ", t_1.read);	//actual timer value is expected, log output is not validated by the script
 }

 t_1.stop;
 log("Actual timer state: ", t_1);			//stopped state is expected, log output is not validated by the script
 log("Is timer running? ", t_1.running);	//false is expected, log output is not validated by the script
 
 setverdict(pass)
 
}


control{

    execute(TC_Sem_1911_log_statement_005());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.11, Ensure that the IUT properly evaluates log statements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1911_log_statement_003 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1911_log_statement_003 () runs on GeneralComp{
 const integer c_i:=1;
 
  log("Actual value of c_i: ", c_i);	//expected to print 1 for c_i constant value, log output is not validated by the script
 
 setverdict(pass)
 
}


control{

    execute(TC_Sem_1911_log_statement_003());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.11, Ensure that the IUT properly evaluates log statements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1911_log_statement_001 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1911_log_statement_001 () runs on GeneralComp{
 var integer v_i;
 
 for(v_i:=1; v_i<10; v_i:= v_i+1) {
  log("Actual value of v_i: ", v_i);	//actual value of v_i is expected, log output is not validated by the script
 }
 
 setverdict(pass)
 
}


control{

    execute(TC_Sem_1911_log_statement_001());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.11, Ensure that the IUT properly evaluates log statements
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1911_log_statement_002 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1911_log_statement_002 () runs on GeneralComp{
 var integer v_i;
 
  log("Actual value of v_i: ", v_i);	//expected to print "UNINITIALIZED" for the unbounded v_i value, log output is not validated by the script
 
 setverdict(pass)
 
}


control{

    execute(TC_Sem_1911_log_statement_002());

}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:19.7, Ensure that the IUT correctly handles label syntax.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_1907_label_statement_001 {


	type record MessageType {
  	 integer  		field1, 
  	 charstring  	field2
	}

    type port loopbackPort message {
	  inout MessageType
	}

type component GeneralComp {	    	    
	  port loopbackPort messagePort
}	

function f_test ( integer p_integer := 0 ) runs on GeneralComp return integer {
 label L1;
 return p_integer+1;
}

	
altstep AltSet1() runs on GeneralComp { 
  var integer v_LocalVar := f_test();   // local variable 
  
     [] messagePort.receive {
      label L_A;
        setverdict(pass);
      label L_B;
     }
     
}

testcase TC_Syn_1907_label_statement_001 () runs on GeneralComp {
 var MessageType v_testMessage;
 timer t_timer;
 
 v_testMessage:=  {  
  field1 := 1,
  field2 := "test string"
 } 

 messagePort.send(v_testMessage);
 t_timer.start( 1.0 );
 label L1;
 
 alt {
  [] AltSet1();		
  [] messagePort.receive {
      label L2;
      setverdict(pass);
     }
  [] t_timer.timeout {
      label L3;
     }
 }
 label L4;
}			

control{
    execute(TC_Syn_1907_label_statement_001());
}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.5, Ensure that the IUT properly evaluates while statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1905_while_statement_001 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1905_while_statement_001 () runs on GeneralComp{
 var integer v_j:=1;
 
 while(v_j<10) {
  v_j:=v_j+1;	
 }
 
  if( v_j==10 ) { setverdict(pass); }
  else  { setverdict(fail); }
 
 
}


control{

    execute(TC_Sem_1905_while_statement_001());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.5, Ensure that the IUT properly evaluates while statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1905_while_statement_003 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1905_while_statement_003 () runs on GeneralComp{
 var integer v_i:=1;
 var integer v_j:=1;
 
 while(v_i<10) {
  while(v_j<10) {
   if(v_i==5) { break; }
   v_j:=v_j+1;	
  }
  v_i:=v_i+1;	
 }
 
  if(v_i==10) { setverdict(pass); }
  else  { setverdict(fail); }
 
}


control{

    execute(TC_Sem_1905_while_statement_003());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.5, Ensure that the IUT properly evaluates while statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1905_while_statement_002 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1905_while_statement_002 () runs on GeneralComp{
 var integer v_i:=1;
 
 while(v_i<10) {
  if(v_i==5) { break; }
  v_i:=v_i+1;	
 }
 
  if(v_i==5) { setverdict(pass); }
  else  { setverdict(fail); }
 
}


control{

    execute(TC_Sem_1905_while_statement_002());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.6, Ensure that the IUT properly evaluates do-while statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1906_do_while_statement_003 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1906_do_while_statement_003 () runs on GeneralComp{
 var integer v_i:=1;
 var integer v_j:=1;
 
 do {
  do {
   if(v_i==5) { break; }
   v_j:=v_j+1;	
  } while(v_j<10);
  v_i:=v_i+1;	
 } while(v_i<10);
 
  if(v_i==10) { setverdict(pass); }
  else  { setverdict(fail); }
 
}


control{

    execute(TC_Sem_1906_do_while_statement_003());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.6, Ensure that the IUT properly evaluates do-while statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1906_do_while_statement_002 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1906_do_while_statement_002 () runs on GeneralComp{
 var integer v_i:=1;
 
 do {
  if(v_i==5) { break; }
  v_i:=v_i+1;	
 } while(v_i<10);
 
  if(v_i==5) { setverdict(pass); }
  else  { setverdict(fail); }
 
}


control{

    execute(TC_Sem_1906_do_while_statement_002());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.6, Ensure that the IUT properly evaluates do-while statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1906_do_while_statement_001 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1906_do_while_statement_001 () runs on GeneralComp{
 var integer v_j:=1;
 
 do {
  v_j:=v_j+1;	
 } while(v_j<10);
 
  if( v_j==10 ) { setverdict(pass); }
  else  { setverdict(fail); }
 
 
}


control{

    execute(TC_Sem_1906_do_while_statement_001());

}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:19.8, Ensure that the IUT correctly handles goto statements.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_1908_goto_statement_001 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1908_goto_statement_001 () runs on GeneralComp{
 var integer v_i:=1;
 goto L1;	//jumping forward
 v_i:=2;
 
 label L1;
 
  if( v_i==1 ) { setverdict(pass); }
  else  { setverdict(fail); }
 
 
}


control{

    execute(TC_Sem_1908_goto_statement_001());

}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:19.8, Ensure that the IUT correctly handles goto statements.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_1908_goto_statement_003 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1908_goto_statement_003 () runs on GeneralComp{
 var integer v_i;

 for(v_i:=1; v_i<10; v_i:= v_i+1) {
  if(v_i==5) { goto L1; }	//jumping out of the loop
 }

 label L1;
 
  if( v_i==5 ) { setverdict(pass); }
  else  { setverdict(fail); }
 
 
}


control{

    execute(TC_Sem_1908_goto_statement_003());

}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:19.8, Ensure that the IUT correctly handles goto statements.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_1908_goto_statement_002 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1908_goto_statement_002 () runs on GeneralComp{
 var integer v_i:=1;

 label L1;
 v_i:=v_i+1;
 
 if(v_i==2) { goto L1; }	//jumping backward
 
  if( v_i==3 ) { setverdict(pass); }
  else  { setverdict(fail); }
 
 
}


control{

    execute(TC_Sem_1908_goto_statement_002());

}

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:19.9, stop statement in a function called from a PTC
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirement is tested:
// When invoked in a test case, altstep or function that are executed on a test
// component, it terminates the relevant test component.

module Sem_1909_stop_statement_004 {

    type component GeneralComp {	
    }
        
    testcase TC_Sem_1909_stop_statement_004 () runs on GeneralComp {
        setverdict(pass);  
    }
    
    testcase TC_not_to_be_executed () runs on GeneralComp{
        setverdict(fail);  
    }

    function f_stop() {
        execute(TC_Sem_1909_stop_statement_004());
        stop;
    }

    control {
        f_stop();
        execute(TC_not_to_be_executed());
    }

}
/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:19.9, stop statement in a function called from a PTC
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirement is tested:
// When invoked in a test case, altstep or function that are executed on a test
// component, it terminates the relevant test component.

module Sem_1909_stop_statement_003 {

    type component GeneralComp {	
    }
    
    function f_stop() runs on GeneralComp {
        setverdict(pass); 
        stop;
    }
    
    function f_ptc() runs on GeneralComp {
        f_stop();
        setverdict(fail);
    }
    
    testcase TC_Sem_1909_stop_statement_003 () runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc := GeneralComp.create;
        v_ptc.start(f_ptc());
        v_ptc.done;
    }
    
    
    control {
        execute(TC_Sem_1909_stop_statement_003());
    }

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:19.9, Ensure that the IUT correctly handles stop statements.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_1909_stop_statement_002 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1909_stop_statement_002 () runs on GeneralComp{
  setverdict(pass);  
}

testcase TC_not_to_be_executed () runs on GeneralComp{
  setverdict(fail);  
}


control{
    execute(TC_Sem_1909_stop_statement_002());
    stop;
    execute(TC_not_to_be_executed());
}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:19.9, Ensure that the IUT correctly handles stop statements.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_1909_stop_statement_001 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1909_stop_statement_001 () runs on GeneralComp{
  setverdict(pass); 
  stop;
  setverdict(fail);
 
}


control{

    execute(TC_Sem_1909_stop_statement_001());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.13, Ensure that the IUT properly evaluates continue statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1913_continue_statement_001 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1913_continue_statement_001 () runs on GeneralComp{
 var integer v_i;
 
 for(v_i:=1; v_i<10; v_i:= v_i+1) {
  if(v_i==5) { continue; }	
  if(v_i==5) { break; }	
 }
 
  if( v_i==10 ) { setverdict(pass); }
  else  { setverdict(fail); }
 
 
}


control{

    execute(TC_Sem_1913_continue_statement_001());

}

}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:19.3.2, verify that it is possible to use an else branches
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Each branch shall start with the case keyword followed by one or more identifiers 
// of the alternatives (fields) of the union type (a list branch) or the else keyword 
// (an else branch) and a statement block.

module Sem_190301_select_union_statement_003 { 

    type component GeneralComp {
	}	
    
    type union U {
        integer intOption,
        charstring strOption,
        boolean boolOption,
        bitstring bitOption
    }

    testcase TC_Sem_190301_select_union_statement_003() runs on GeneralComp {
        var U v_un := { strOption := "abc" }
        select union (v_un) {
            case (strOption) {
                setverdict(pass);
            } case (bitOption) {
                setverdict(fail);
            } case else {
                setverdict(fail);
            }
        }
	}

	control {
		execute(TC_Sem_190301_select_union_statement_003());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:19.3.2, verify that it is possible to use comma separated list of alternatives in case branches
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Each branch shall start with the case keyword followed by one or more identifiers 
// of the alternatives (fields) of the union type (a list branch) or the else keyword 
// (an else branch) and a statement block.

module Sem_190301_select_union_statement_002 { 

    type component GeneralComp {
	}	
    
    type union U {
        integer intOption,
        charstring strOption,
        boolean boolOption,
        bitstring bitOption
    }

    testcase TC_Sem_190301_select_union_statement_002() runs on GeneralComp {
        var U v_un := { strOption := "abc" }
        select union (v_un) {
            case (intOption, boolOption, strOption) {
                setverdict(pass);
            } case (bitOption) {
                setverdict(fail);
            }
        }
	}

	control {
		execute(TC_Sem_190301_select_union_statement_002());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:19.3.2, verify that it is possible to use a select union statement with several branches
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The statement contains a header part and zero or more branches. 

module Sem_190301_select_union_statement_001 { 

    type component GeneralComp {
	}	
    
    type union U {
        integer intOption,
        charstring strOption,
        boolean boolOption
    }

    testcase TC_Sem_190301_select_union_statement_001() runs on GeneralComp {
        var U v_un := { strOption := "abc" }
        select union (v_un) {
            case (intOption) {
                setverdict(fail);
            } case (strOption) {
                setverdict(pass);
            } case (boolOption) {
                setverdict(fail);
            }
        }
	}

	control {
		execute(TC_Sem_190301_select_union_statement_001());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:19.3.2, verify that partially initialized value can be used in select union header
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// [The TemplateInstance in the header of the select union statement] shall be 
// at least partially initialized.

module Sem_190301_select_union_statement_006 { 

    type component GeneralComp {
	}	
    
    type union U {
        integer intOption,
        charstring strOption,
        record {
            integer field1,
            integer field2
        } recOption
    }

    testcase TC_Sem_190301_select_union_statement_006() runs on GeneralComp {
        var U v_un := { recOption := { field1 := 1, field2 := - } }
        select union (v_un) {
            case (intOption) {
                setverdict(fail);
            } case (strOption) {
                setverdict(fail);
            } case (recOption) {
                setverdict(pass);
            }
        }
	}

	control {
		execute(TC_Sem_190301_select_union_statement_006());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:19.3.2, verify that no branch is executed if the's no suitable case branch
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Otherwise [if no case exists for the chosen alternative and the else branch 
// is not present], the select union statement has no effect.

module Sem_190301_select_union_statement_005 { 

    type component GeneralComp {
	}	
    
    type union U {
        integer intOption,
        charstring strOption,
        boolean boolOption,
        bitstring bitOption
    }

    testcase TC_Sem_190301_select_union_statement_005() runs on GeneralComp {
        var U v_un := { strOption := "abc" }
        select union (v_un) {
            case (intOption) {
                setverdict(pass);
            } case (bitOption) {
                setverdict(fail);
            }
        }
        setverdict(pass);
	}

	control {
		execute(TC_Sem_190301_select_union_statement_005());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:19.3.2, verify that else branch is executed if no case is defined for the selected alternative
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// If no case exists for the chosen alternative, the StatementBlock of the else 
// branch, if it is present, is executed.

module Sem_190301_select_union_statement_004 { 

    type component GeneralComp {
	}	
    
    type union U {
        integer intOption,
        charstring strOption,
        boolean boolOption,
        bitstring bitOption
    }

    testcase TC_Sem_190301_select_union_statement_004() runs on GeneralComp {
        var U v_un := { strOption := "abc" }
        select union (v_un) {
            case (intOption) {
                setverdict(fail);
            } case (bitOption) {
                setverdict(fail);
            } case else {
                setverdict(pass);
            }
        }
	}

	control {
		execute(TC_Sem_190301_select_union_statement_004());
	}
}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.3, Ensure that the IUT properly evaluates select-case statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_190301_select_case_statement_004 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_190301_select_case_statement_004 () runs on GeneralComp{
 var integer v_i:=2;
 
 select (v_i) {	
  case(1) {
   setverdict(fail);
  }
  case(2) {
   setverdict(pass);
  }
  case(2) {
   setverdict(fail);
  }
  case else {
   setverdict(fail);
  }
 }
}


control{

    execute(TC_Sem_190301_select_case_statement_004());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.3, Ensure that the IUT properly evaluates select-case statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_190301_select_case_statement_003 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_190301_select_case_statement_003 () runs on GeneralComp{
 var integer v_i:=5;
 
 setverdict(pass);
 select (v_i) {	
  case(1) {
   setverdict(fail);
  }
  case(2) {
   setverdict(fail);
  }
  case(3) {
   setverdict(fail);
  }
 }
}


control{

    execute(TC_Sem_190301_select_case_statement_003());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.3, Ensure that the IUT properly evaluates select-case statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_190301_select_case_statement_001 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_190301_select_case_statement_001 () runs on GeneralComp{
 var integer v_i:=2;
 
 select (v_i) {	
  case(1) {
   setverdict(fail);
  }
  case(2) {
   setverdict(pass);
  }
  case(3) {
   setverdict(fail);
  }
  case else {
   setverdict(fail);
  }
 }
}


control{

    execute(TC_Sem_190301_select_case_statement_001());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.3, Ensure that the IUT properly evaluates select-case statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_190301_select_case_statement_002 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_190301_select_case_statement_002 () runs on GeneralComp{
 var integer v_i:=5;
 
 select (v_i) {	
  case(1) {
   setverdict(fail);
  }
  case(2) {
   setverdict(fail);
  }
  case(3) {
   setverdict(fail);
  }
  case else {
   setverdict(pass);
  }
 }
}


control{

    execute(TC_Sem_190301_select_case_statement_002());

}

}
/*****************************************************************
 ** @author   STF 451
 ** @version  0.0.1
 ** @purpose  1:19.10, Ensure that the IUT correctly handles return statements.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_1910_return_statement_002 {
	
    type component GeneralComp {
    }

    function f_template_return() return template charstring {
        setverdict(pass);
        return ?;
    }

	
    testcase TC_Sem_1910_return_statement_002 () runs on GeneralComp {
        if ( match("A",f_template_return() ) ) {
            setverdict(pass, "function return value correct");
        }
        else {
            setverdict(fail, "function return value wrong");
        }
 
    }


    control{

        execute(TC_Sem_1910_return_statement_002());

    }

}
/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:19.10, Ensure that the IUT correctly handles return statements.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/
module Sem_1910_return_statement_001 {
	
    type component GeneralComp {
    }

    function f_verdict_return() runs on GeneralComp return verdicttype {
        setverdict(pass);
        return getverdict;
    }

	
    testcase TC_Sem_1910_return_statement_001 () runs on GeneralComp {
        if (f_verdict_return() != pass) {
            setverdict(fail, "function return value wrong");
        }
        if (getverdict != pass) {
            setverdict(fail, "component verdict not set");
        }
 
    }


    control{

        execute(TC_Sem_1910_return_statement_001());

    }

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.4, Ensure that the IUT properly evaluates for statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1904_for_statement_003 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1904_for_statement_003 () runs on GeneralComp{
 var integer v_i;
 
 for(v_i:=1; v_i<10; v_i:= v_i+1) {
  for(var integer v_j:=1; v_j<10; v_j:= v_j+1) {
   if(v_i==5) { break; }	//the break statement must only exit the inner loop
  }
 }
 
  if(v_i==10) { setverdict(pass); }
  else  { setverdict(fail); }
 
 
}


control{

    execute(TC_Sem_1904_for_statement_003());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.4, Ensure that the IUT properly evaluates for statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1904_for_statement_001 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1904_for_statement_001 () runs on GeneralComp{
 var integer v_i;
 var integer v_j:=1;
 
 for(v_i:=1; v_i<10; v_i:= v_i+1) {
  v_j:=v_j+1;	
 }
 
  if( match(v_i, 10) and match(v_j, 10) ) { setverdict(pass); }
  else  { setverdict(fail); }
 
 
}


control{

    execute(TC_Sem_1904_for_statement_001());

}

}
/***************************************************
 ** @author   STF 409 
 ** @version  0.0.1
 ** @purpose  1:19.4, Ensure that the IUT properly evaluates for statements
 ** @verdict  pass  accept, ttcn3verdict:pass
 ***************************************************/
module Sem_1904_for_statement_002 {
	
type component GeneralComp {	
}
	
testcase TC_Sem_1904_for_statement_002 () runs on GeneralComp{
 var integer v_i;
 
 for(v_i:=1; v_i<10; v_i:= v_i+1) {
  if(v_i==5) { break; }
 }
 
  if(v_i==5) { setverdict(pass); }
  else  { setverdict(fail); }
 
 
}


control{

    execute(TC_Sem_1904_for_statement_002());

}

}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20.2, Ensure that the behavior continues after the alt-statement (loopback case).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2002_TheAltStatement_011 {

type component GeneralComp { }

testcase TC_Sem_2002_TheAltStatement_011() runs on GeneralComp {
    timer t_timer;
    var boolean v_altVisited := false;	
	
    t_timer.start(20E-3);
    alt { // block until a timeout happens in 20ms
        [] t_timer.timeout {
            v_altVisited := true;
        }
    }

    if (v_altVisited == true) {
        setverdict(pass);
    } else {
        setverdict(fail); // for some reason the alt has not been processed correctly.
    }
}

control {
    execute(TC_Sem_2002_TheAltStatement_011(), 200E-3); // timeout in 100ms, then error
}
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20.2, Ensure that the killed-block in an alt-statement is triggered as expected when the component is killed (loopback case).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2002_TheAltStatement_009 {

type port MyPort message {
    inout charstring
}

type component SystemComp { 
    port MyPort p;
}

type component MTCComp { 
    port MyPort p;
}

type component PTCComp { 
    port MyPort p;
}

function f_secondComponent() runs on PTCComp {
}

testcase TC_Sem_2002_TheAltStatement_009() runs on MTCComp system SystemComp {
    var PTCComp v_ptc := PTCComp.create;
    map(self:p, system:p);
    v_ptc.start(f_secondComponent());
    v_ptc.kill;
	
    alt {
        [] v_ptc.killed {
            setverdict(pass);
        }
        [else] {
            setverdict(fail);
        }
    }
}

control {
    execute(TC_Sem_2002_TheAltStatement_009());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20.2, Ensure that an altstep invocation works as expected (loopback case).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2002_TheAltStatement_006 {

type port MyPort message {
	inout charstring
}

type component GeneralComp { 
	port MyPort p;
}

template charstring m_testOne := "ping1";
template charstring m_testTwo := "ping2";

altstep a_test() runs on GeneralComp {
	[] p.receive(m_testOne) {
		setverdict(pass);
	}
}

testcase TC_Sem_2002_TheAltStatement_006() runs on GeneralComp {
	p.send(m_testOne);

	alt {
		[] a_test();
		[else] {
			setverdict(fail);
		}
	}
	
	setverdict(pass);
}

control {
	execute(TC_Sem_2002_TheAltStatement_006());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20.2, Ensure that the done-block in an alt-statement is triggered as expected (loopback case).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2002_TheAltStatement_008 {

type port MyPort message {
    inout charstring
}

type component MTCComp { 
    port MyPort p;
}

type component PTCComp { 
    port MyPort p;
}

type component SystemComp { 
    port MyPort p;
}

function f_secondComponent() runs on PTCComp {
}

testcase TC_Sem_2002_TheAltStatement_008() runs on MTCComp system SystemComp {
    var PTCComp v_ptc := PTCComp.create alive;
    map(self:p, system:p);
    v_ptc.start(f_secondComponent());
	
    alt {
        [] v_ptc.killed {
            setverdict(fail); // as we have an alive component, it shouldn't have the killed status here
        }
        [] v_ptc.done {
            setverdict(pass);
        }
    }
    v_ptc.kill;
}

control {
    execute(TC_Sem_2002_TheAltStatement_008());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20.2, Ensure that the alt-statement processes the alternatives in order (loopback case).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2002_TheAltStatement_003 {

type port MyPort message {
	inout charstring
}

type component GeneralComp { 
	port MyPort p;
}

template charstring m_test := "ping";

testcase TC_Sem_2002_TheAltStatement_003() runs on GeneralComp {
	p.send(m_test);
	alt {
		[] p.receive(m_test) {
			setverdict(pass);
		}
		[] p.receive(m_test) {
			setverdict(fail);
		}
		[] p.receive(m_test) {
			setverdict(fail);
		}
	}
}

control {
	execute(TC_Sem_2002_TheAltStatement_003());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20.2, Ensure that the timeout branch is taken as expected (loopback case).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2002_TheAltStatement_010 {

type component GeneralComp { }

testcase TC_Sem_2002_TheAltStatement_010() runs on GeneralComp {
	timer t_timer;
	
	t_timer.start(20E-3);
	
	alt { // block until a timeout happens in 20ms
		[] t_timer.timeout {
			setverdict(pass);
		}
	}
}

control {
	execute(TC_Sem_2002_TheAltStatement_010(), 200E-3); // timeout in 100ms, then error
}
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20.2, Ensure that activated defaults are processed in the reverse order (loopback case).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2002_TheAltStatement_004 {

type port MyPort message {
    inout charstring
}

type component GeneralComp { 
    port MyPort p;
}

template charstring m_testOne := "ping1";
template charstring m_testTwo := "ping2";
template charstring m_testThree := "ping3"; // never sent!

altstep a_first() runs on GeneralComp {
    [] p.receive(m_testTwo) {
        setverdict(fail);
    }
}

altstep a_second() runs on GeneralComp {
    [] p.receive(m_testOne) {
        setverdict(pass);
    }
}

testcase TC_Sem_2002_TheAltStatement_004() runs on GeneralComp {
    var default v_defaultOne := activate(a_first());
    var default v_defaultTwo := activate(a_second());

    p.send(m_testOne);
    p.send(m_testTwo);
	
    alt {
        [] p.receive(m_testThree) {
            setverdict(fail);
        }
    }
}

control {
    execute(TC_Sem_2002_TheAltStatement_004(), 2.0);  // if the altstep isn't handled after 2s, we raise an error
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20.2, Ensure that the else branch is executed when nothing else matched (loopback case).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2002_TheAltStatement_005 {

type port MyPort message {
	inout charstring
}

type component GeneralComp { 
	port MyPort p;
}

template charstring m_testOne := "ping1";
template charstring m_testTwo := "ping2";

testcase TC_Sem_2002_TheAltStatement_005() runs on GeneralComp {
	p.send(m_testOne);
	p.send(m_testOne);

	alt {
		[] p.receive(m_testTwo) {
			setverdict(fail);
		}
		[false] p.receive(m_testTwo) {
			setverdict(fail);
		}
		[else] {
			setverdict(pass);
		}
	}
	
	setverdict(pass);
}

control {
	execute(TC_Sem_2002_TheAltStatement_005(), 2.0);  // if the altstep isn't handled after 2s, we raise an error
}

}/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:20.2, Ensure that alt statements are correctly handled for dynamically mapped ports
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// Mycompport A is dynamically mapped
module Sem_2002_TheAltStatement_012{ 

    type port loopbackPort message {
	  inout integer
	}
		
	type port IntegerOutputPortType message {
	  inout integer
	}
	
type component GeneralComp
	{
	
		port IntegerOutputPortType MycomportA
	}

type component MyTestSystemInterface
	{
 		port loopbackPort messagePort
	}
	
// MyTestSystemInterface is the test system interface
testcase TC_Sem_2002_TheAltStatement_012() runs on GeneralComp system MyTestSystemInterface {
 timer tc_timer := 0.1;
 map(mtc:MycomportA, system:messagePort);


 MycomportA.send(2);
 tc_timer.start;
 unmap(mtc:MycomportA);
 setverdict(pass);

    alt {
     [] MycomportA.receive {
     }
     [] tc_timer.timeout {
        setverdict(pass);
     }
    }
}
control{
    execute(TC_Sem_2002_TheAltStatement_012());
}
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20.2, Ensure that the alt-statement works as expected (loopback case).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2002_TheAltStatement_001 {

type port MyPort message {
	inout charstring
}

type component GeneralComp { 
	port MyPort p;
}

template charstring m_test := "ping";

testcase TC_Sem_2002_TheAltStatement_001() runs on GeneralComp {
	p.send(m_test);
	alt {
		[] p.receive(m_test) {
			setverdict(pass);
		}
	}
}

control {
	execute(TC_Sem_2002_TheAltStatement_001());
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20.2, Ensure that the alt-statement with a guard works as expected (loopback case).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2002_TheAltStatement_002 {

type port MyPort message {
    inout charstring
}

type component GeneralComp { 
    port MyPort p;
}

template charstring m_test := "ping";

testcase TC_Sem_2002_TheAltStatement_002() runs on GeneralComp {
    var integer counter := 1;
    p.send(m_test);
    alt {
        [counter == 1] p.receive(m_test) {
            setverdict(pass);
        }
    }
}

control {
    execute(TC_Sem_2002_TheAltStatement_002());
}

}/***************************************************
 ** @author   STF 451 
 ** @version  0.0.1
 ** @purpose  1:20.2, Ensure that alt statements are correctly handled for dynamically mapped ports
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// Mycompport A is dynamically mapped
module Sem_2002_TheAltStatement_013{ 

    type port loopbackPort message {
	  inout integer
	}
		
	type port IntegerOutputPortType message {
	  inout integer
	}
	
type component GeneralComp
	{
	
		port IntegerOutputPortType MycomportA
	}

type component MyTestSystemInterface
	{
 		port loopbackPort messagePort
	}
	
// MyTestSystemInterface is the test system interface
testcase TC_Sem_2002_TheAltStatement_013() runs on GeneralComp system MyTestSystemInterface {
 timer tc_timer := 0.1;
 map(mtc:MycomportA, system:messagePort);


 MycomportA.send(2);
 tc_timer.start;
 unmap(mtc:MycomportA);

    alt {
     [] tc_timer.timeout {
        MycomportA.clear;
        setverdict(pass);
     }
    }
}
control{
    execute(TC_Sem_2002_TheAltStatement_013());
}
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:20.2, no default activation after else
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirement is tested:
// If an else branch is defined, the default mechanism will never be called, 
// i.e. active defaults will never be entered.

module Sem_2002_TheAltStatement_014 {

    type port MyPort message {
        inout charstring
    }
    
    type component GeneralComp { 
	    port MyPort p;
    }
    
    altstep a_receive() runs on GeneralComp {
        [] p.receive {
			setverdict(fail);
		}
    }
    
    testcase TC_Sem_2002_TheAltStatement_014() runs on GeneralComp system GeneralComp {
        map(self:p, system: p);
	    p.send(charstring:"abc");
        activate(a_receive());
	    alt {
		    [] p.receive(charstring:"def") {
                setverdict(fail);
            }
            [else] {
                setverdict(pass);
            }
	    }
    }
    
    control {
	    execute(TC_Sem_2002_TheAltStatement_014());
    }
}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20.2, Ensure that an altstep invocation works as expected and that the optional statement block is executed after the altstep staatement block (loopback case).
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2002_TheAltStatement_007 {

type port MyPort message {
	inout charstring
}

type component GeneralComp { 
	port MyPort p;
	var boolean v_visitedAltstep := false;
}

template charstring m_testOne := "ping1";
template charstring m_testTwo := "ping2";

altstep a_test() runs on GeneralComp {
	[] p.receive(m_testOne) {
		v_visitedAltstep := true;
	}
}

testcase TC_Sem_2002_TheAltStatement_007() runs on GeneralComp {
	p.send(m_testOne);

	alt {
		[] a_test() {
			if (v_visitedAltstep == true) {
				setverdict(pass);
			}
		}
		[else] {
			setverdict(fail);
		}
	}
	
	setverdict(pass);
}

control {
	execute(TC_Sem_2002_TheAltStatement_007());
}

}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:20.4, Validate that interleave statements are properly handled.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2004_InterleaveStatement_002 {

    type port loopbackPort message {
        inout MyMessageType
    }

    type component GeneralComp {
        port loopbackPort pt_myPort1,pt_myPort2;
    }

    type record MyMessageType {
        integer field1,
        charstring field2,
        boolean field3
    }
    
	altstep checkTimeout(timer t_timer){
        [] t_timer.timeout {
            setverdict(fail);
        }
    }

    testcase TC_Sem_2004_InterleaveStatement_002() runs on GeneralComp {
    
        template MyMessageType MySig1 := {1,"aaa",true};
        template MyMessageType MySig2 := {2,"bbb",true};
        template MyMessageType MySig3 := {3,"ccc",true};
    
        timer t_timer;
        
        pt_myPort1.send(MyMessageType:{1, "aaa", true});
        
        t_timer.start(1.0);
    
        interleave {
            [] pt_myPort1.receive(MySig1)
            {
                pt_myPort2.send(MySig2);
                alt {
                    [] pt_myPort1.receive(MySig3) {
                        setverdict(fail);
                    }
                }
            }
            [] pt_myPort2.receive(MySig2)
            {
                setverdict(pass);
                break;						//evaluation of correct exit from interleave
                pt_myPort1.send(MySig3);
                setverdict(fail);
            }
        }

    
    }

    control{
        execute(TC_Sem_2004_InterleaveStatement_002());
    }
}/*****************************************************************
 ** @author   STF 433
 ** @version  0.0.1
 ** @purpose  1:20.4, Validate that interleave statements are properly handled.
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2004_InterleaveStatement_001 {

    type port loopbackPort message {
        inout MyMessageType
    }

    type component GeneralComp {
        port loopbackPort pt_myPort1,pt_myPort2;
        timer t_timer;
    }

    type record MyMessageType {
        integer field1,
        charstring field2,
        boolean field3
    }
    
    altstep checkTimeout(timer t_timer){
        [] t_timer.timeout {
            setverdict(fail);
        }
    }

    testcase TC_Sem_2004_InterleaveStatement_001() runs on GeneralComp system GeneralComp {
    
        template MyMessageType MySig1 := {1,"aaa",true};
        template MyMessageType MySig2 := {2,"bbb",true};
        template MyMessageType MySig3 := {3,"ccc",true};
        
        map(mtc:pt_myPort1, system:pt_myPort1);
        map(mtc:pt_myPort2, system:pt_myPort2);
    
	    activate(checkTimeout(t_timer));
        pt_myPort1.send(MyMessageType:{1, "aaa", true});
        t_timer.start(3.0);
    
        interleave {
            [] pt_myPort1.receive(MySig1)
            {
                pt_myPort2.send(MySig2);
                alt {
                    [] pt_myPort1.receive(MySig3) {
                        setverdict(pass);
                    }
                }
            }
            [] pt_myPort2.receive(MySig2)
            {
                pt_myPort1.send(MySig3);
            }
        }

    
    }

    control{
        execute(TC_Sem_2004_InterleaveStatement_001());
    }
}/*****************************************************************
 * @author STF 433
 * @version 0.0.1
 * @purpose 1:20.4, Validate that interleave statements are properly handled.
 * @verdict pass accept, noexecution
 *****************************************************************/
module Syn_2004_InterleaveStatement_001 {
    type port MyMessagePortType message {
        inout MyMessageType;
    }

    type component GeneralComp {
        port MyMessagePortType pt_myPort1, pt_myPort2;
    }

    type record MyMessageType {
        integer field1,
        charstring field2,
        boolean field3
    }

    testcase TC_Syn_2004_InterleaveStatement_001() runs on GeneralComp {

        template MyMessageType MySig1 := {1, "abc", true}
        template MyMessageType MySig2 := MySig1;
        template MyMessageType MySig3 := MySig1;
        template MyMessageType MySig4 := MySig1;
        template MyMessageType MySig5 := MySig1;
        template MyMessageType MySig6 := MySig1;

        pt_myPort1
        .send(MyMessageType:
              {
                  2,
                  "abcxyz",
                  true
              });

        interleave {
            [] pt_myPort1.receive(MySig1) {
                pt_myPort1.send(MySig2);
                pt_myPort1.receive(MySig3);
            }
            [] pt_myPort2.receive(MySig4) {
                pt_myPort2.send(MySig5);
                pt_myPort2.receive(MySig6);
            }
        }
    }
    control {
        execute(TC_Syn_2004_InterleaveStatement_001());
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:20.4, while loop inside interleave
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirement is tested:
// If none of the alternatives of the interleave statement can be executed, 
// the default mechanism will be invoked. This means, according to the 
// semantics of the default mechanism, the actual snapshot will be used to
// evaluate those altsteps that have been activated before entering the 
// interleave statement.

module Sem_2004_InterleaveStatement_003 {

    type port MyPort message {
        inout charstring
    }

    type component GeneralComp {
        port MyPort p;
    }    
    
    altstep a_receive() runs on GeneralComp {
        [] p.receive(charstring:?) {
            setverdict(pass, "default called");
        }
    }
    
    testcase TC_Sem_2004_InterleaveStatement_003() runs on GeneralComp {
        p.send(charstring:"foo");
        p.send(charstring:"ding");
        p.send(charstring:"bar");
        activate(a_receive());
        
        interleave {
            [] p.receive(charstring:"bar") { // should not be called, because the default is invoked instead
                setverdict(fail, "default not used properly!!!");
            }
            [] p.receive(charstring:"foo") {
                setverdict(pass, "foo received");
            }
        }        
    }

    control{
        execute(TC_Sem_2004_InterleaveStatement_003());
    }
}/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.1, verify that deactivate removes default from list of defaults
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// A deactivate operation will remove the referenced default from the list of defaults.

module Sem_200503_the_deactivate_operation_001 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		port P p;
	}
	
	altstep a1() runs on GeneralComp {
		[] p.receive(integer:?) {
			setverdict(pass);
		}
	}
	
	altstep a2() runs on GeneralComp {
		[] p.receive(integer:?) {
			setverdict(fail, "Deactivated"); // should be deactivated at the time of default processing
		}
	}

	testcase TC_Sem_200503_the_deactivate_operation_001() runs on GeneralComp {
		var default v_default;
		activate(a1());		
		v_default := activate(a2());
		p.send(integer:1);
		deactivate(v_default);
		alt {
			[] p.receive(integer:0) { // not expected: leads to default invocation
				setverdict(fail);
			}
		}
	}

	control{
		execute(TC_Sem_200503_the_deactivate_operation_001());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.1, verify that deactivate without parameter clear list of defaults
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// A deactivate operation without parameter deactivates all defaults of a test component.

module Sem_200503_the_deactivate_operation_003 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		port P p;
	}
	
	altstep a1() runs on GeneralComp {
		[] p.receive(integer:1) {
			setverdict(fail, "Deactivated"); // should be deactivated at the time of default processing
		}
	}
	
	altstep a2() runs on GeneralComp {
		[] p.receive(integer:?) {
			setverdict(fail, "Deactivated"); // should be deactivated at the time of default processing
		}
	}

	testcase TC_Sem_200503_the_deactivate_operation_003() runs on GeneralComp {
		timer t := 0.5;
		t.start;
		activate(a1());		
		activate(a2());
		p.send(integer:1);
		deactivate;
		alt {
			[] p.receive(integer:0) { // not expected: leads to default invocation
				setverdict(fail);
			}
			[] t.timeout { // timer should provide enough time to take at least one snapshot
				setverdict(pass);
			}
		}
	}

	control{
		execute(TC_Sem_200503_the_deactivate_operation_003());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.1, verify that deactivate null works correctly
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// Calling a deactivate operation with the special value null has no effect.

module Sem_200503_the_deactivate_operation_004 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		port P p;
	}
	
	altstep a1() runs on GeneralComp {
		[] p.receive(integer:?) {
			setverdict(pass);
		}
	}
	
	testcase TC_Sem_200503_the_deactivate_operation_004() runs on GeneralComp {
		var default v_default := null;
		activate(a1());		
		p.send(integer:1);
		deactivate(v_default); // v_default is null: there should be no error and no deactivation
		alt {
			[] p.receive(integer:0) { // not expected: leads to default invocation
				setverdict(fail);
			}
		}
	}

	control{
		execute(TC_Sem_200503_the_deactivate_operation_004());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.1, verify that deactivate removes default from list of defaults
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// A deactivate operation will remove the referenced default from the list of defaults.

// Note:
// The test verifies syntactical variant with a function instance passed as a parameter 
// to the deactivate operation.

module Sem_200503_the_deactivate_operation_002 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		port P p;
	}
	
	altstep a1() runs on GeneralComp {
		[] p.receive(integer:?) {
			setverdict(pass);
		}
	}
	
	altstep a2() runs on GeneralComp {
		[] p.receive(integer:?) {
			setverdict(fail, "Deactivated"); // should be deactivated at the time of default processing
		}
	}
	
	function f(default p_default) return default {
		return p_default;
	}

	testcase TC_Sem_200503_the_deactivate_operation_002() runs on GeneralComp {
		var default v_default;
		activate(a1());		
		v_default := activate(a2());
		p.send(integer:1);
		deactivate(f(v_default));
		alt {
			[] p.receive(integer:0) { // not expected: leads to default invocation
				setverdict(fail);
			}
		}
	}

	control{
		execute(TC_Sem_200503_the_deactivate_operation_002());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.2, verify passing port parameter to activated altstep
 ** @verdict   pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// An altstep that is activated as a default shall only have in parameters, port parameters, or timer parameters.

module Sem_200502_the_activate_operation_004 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		port P p;
	}
	
	altstep a(P p_port) runs on GeneralComp {
		[] p_port.receive(integer:?) { setverdict(pass); }
	}
	
	testcase TC_Sem_200502_the_activate_operation_004() runs on GeneralComp {
		activate(a(p));
		p.send(integer:1);
		alt {
			[] p.receive(integer:0) { setverdict(fail); }
		}
	}

	control{
		execute(TC_Sem_200502_the_activate_operation_004());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.2, verify that parameters are passed at activation time
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The actual parameters of a parameterized altstep (see clause 16.2.1) that should 
// be activated as a default, shall be provided in the corresponding activate statement. 
// This means the actual parameters are bound to the default at the time of its activation 
// (and not e.g. at the time of its invocation by the default mechanism).

module Sem_200502_the_activate_operation_002 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		port P p;
	}
	
	const integer c_defaultParValue := 1;
	
	altstep a(integer p_par) runs on GeneralComp {
		[] p.receive(integer:?) {
			if (p_par == c_defaultParValue) { setverdict(pass); }
			else { setverdict(fail); }
		}
	}

	testcase TC_Sem_200502_the_activate_operation_002() runs on GeneralComp {
		var integer v_num := c_defaultParValue;
		activate(a(v_num));
		v_num := v_num + 1;
		p.send(integer:5);
		alt {
			[] p.receive(integer:0) { // not expected: leads to default evocation
				setverdict(fail);
			}
		}
	}

	control{
		execute(TC_Sem_200502_the_activate_operation_002());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:20.5.2, control block timer (referenced through timer parameter) as a parameter of activated altstep
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For altsteps activated in module control or in functions or altsteps invoked
// directly or indirectly from module control, all timer instances in the actual 
// parameter list shall be declared in the highest scope of the module control 
// part (see clause 26.2). Timers from lower scopes of the module control part 
// (i.e. from the nested statement blocks) are not allowed to occur in the actual
// parameter list.

module Sem_200502_the_activate_operation_006 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		port P p;
	}
	
	altstep a(timer t_tmr) {
		[] t_tmr.timeout { log ("Timeout in default"); }
	}
	
	testcase TC_Sem_200502_the_activate_operation_006() runs on GeneralComp {
        setverdict(pass);
	}

    function f_test(timer t_tmr) {
        timer t_tmr2;
        t_tmr.start;
        activate(a(t_tmr));
        alt {
            [] t_tmr2.timeout { }
        }
    }
    
	control{
        timer t_tmr := 1.0;
        f_test(t_tmr);
		execute(TC_Sem_200502_the_activate_operation_006());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.2, verify that passing component timer to activated altstep
 ** @verdict   pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// All timer instances in the actual parameter list shall be declared as component type local timers. 

module Sem_200502_the_activate_operation_003 { 

	type component GeneralComp {
		timer tc_tmr := 0.5;
	}	
	
	altstep a(timer t_tmr) runs on GeneralComp {
		[] t_tmr.timeout {}
	}
	
	testcase TC_Sem_200502_the_activate_operation_003() runs on GeneralComp {
		tc_tmr.start;
		activate(a(tc_tmr));
		any port.receive;
		setverdict(pass);
	}

	control{
		execute(TC_Sem_200502_the_activate_operation_003());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.2, verify that activate operation can be used as standalone statement
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The activate operation can be called without saving the returned default reference. 
// This form is useful in test cases which do not require explicit deactivation 
// of the activated default, i.e. deactivation of a default is done implicitly at
// MTC termination.

// Note:
// An activate operation saving the returned default reference is tested in the section 
// 6.2.8.

module Sem_200502_the_activate_operation_001 { 

	type component GeneralComp {
	}	
	
	altstep a() runs on GeneralComp
	{
		[] any port.receive {}
	}

	testcase TC_Sem_200502_the_activate_operation_001() runs on GeneralComp {
		activate(a());
		setverdict(pass);
	}

	control{
		execute(TC_Sem_200502_the_activate_operation_001());
	}
}
/***************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:20.5.2, control block timer as a parameter of activated altstep
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For altsteps activated in module control or in functions or altsteps invoked
// directly or indirectly from module control, all timer instances in the actual 
// parameter list shall be declared in the highest scope of the module control 
// part (see clause 26.2). Timers from lower scopes of the module control part 
// (i.e. from the nested statement blocks) are not allowed to occur in the actual
// parameter list.

module Sem_200502_the_activate_operation_005 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		port P p;
	}
	
	altstep a(timer t_tmr) {
		[] t_tmr.timeout { log ("Timeout in default"); }
	}
	
	testcase TC_Sem_200502_the_activate_operation_005() runs on GeneralComp {
        setverdict(pass);
	}

	control{
        timer t_tmr := 1.0, t_tmr2;
        t_tmr.start;
        activate(a(t_tmr));
        alt {
            [] t_tmr2.timeout { }
        }
		execute(TC_Sem_200502_the_activate_operation_005());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.1, verify that default processing order is correct
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For each test component the defaults, i.e. activated altsteps, are stored as an ordered 
// list. The defaults are listed in the reversed order of their activation i.e. the last 
// activated default is the first element in the list of active defaults. 

// The default mechanism is evoked at the end of each alt statement, if due to the 
// actual snapshot none of the specified alternatives could be executed. An evoked 
// default mechanism invokes the first altstep in the list of defaults, i.e. the last
// activated default, and waits for the result of its termination. The termination can 
// be successful or unsuccessful.

// In the case of a successful termination, the default ... the main control flow of the 
// test component will continue immediately after the alt statement from which the default
// mechanism was called...

// Note: 
// In this test case, two altsteps are activated as defaults. The sooner activated
// default leads to a test case failure, but because the last activated default takes
// precedence, it should never happen.

module Sem_200501_the_default_mechanism_004 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		port P p;
	}
	
	altstep a1() runs on GeneralComp {
		[] p.receive(integer:?) {
			setverdict(fail, "First default");
		}
	}

	altstep a2() runs on GeneralComp {
		[] p.receive(integer:?) {
			setverdict(pass, "Last default");
		}
	}
	
	testcase TC_Sem_200501_the_default_mechanism_004() runs on GeneralComp {
		activate(a1());
		activate(a2());
		p.send(integer:5);
		alt {
			[] p.receive(integer:0) { // not expected: leads to default invocation
				setverdict(fail);
			}
		}
	}

	control{
		execute(TC_Sem_200501_the_default_mechanism_004());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.1, verify that activated default is invoked
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The default mechanism is evoked at the end of each alt statement, if due to the 
// actual snapshot none of the specified alternatives could be executed. An evoked 
// default mechanism invokes the first altstep in the list of defaults, i.e. the last
// activated default, and waits for the result of its termination. The termination can 
// be successful or unsuccessful.

module Sem_200501_the_default_mechanism_001 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		port P p;
	}
	
	altstep a() runs on GeneralComp {
		[] p.receive(integer:?) {
			setverdict(pass);
		}
	}

	testcase TC_Sem_200501_the_default_mechanism_001() runs on GeneralComp {
		activate(a());
		p.send(integer:5);
		alt {
			[] p.receive(integer:0) { // not expected: leads to default invocation
				setverdict(fail);
			}
		}
	}

	control{
		execute(TC_Sem_200501_the_default_mechanism_001());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.1, verify than default are processed in interleave
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The default mechanism is evoked at the end of each alt statement, if due to the 
// actual snapshot none of the specified alternatives could be executed. An evoked 
// default mechanism invokes the first altstep in the list of defaults, i.e. the last
// activated default, and waits for the result of its termination. The termination can 
// be successful or unsuccessful.

// In particular, the test case is related to the NOTE 1: 
// An interleave statement is semantically equivalent to a nested set of alt statements 
// and the default mechanism also applies to each of these alt statements. This means, 
// the default mechanism also applies to interleave statements. Furthermore, the restrictions 
// imposed on interleave statements in clause 20.4 do not apply to altsteps that are 
// activated as default behaviour for interleave statements.

module Sem_200501_the_default_mechanism_003 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		port P p;
	}
	
	altstep a() runs on GeneralComp {
		[] p.receive(integer:?) {
			setverdict(pass); 
		}
	}

	testcase TC_Sem_200501_the_default_mechanism_003() runs on GeneralComp {
		activate(a());
		p.send(integer:1);
		p.send(integer:2);
		interleave {
			[] p.receive(integer:1) { // expected, no default in this case
				setverdict(pass);
			}
			[] p.receive(integer:3) { // not expected: leads to default invocation
				setverdict(fail);
			}
		}
	}

	control{
		execute(TC_Sem_200501_the_default_mechanism_003());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.1, verify that default processing order is correct
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// For each test component the defaults, i.e. activated altsteps, are stored as an ordered 
// list. The defaults are listed in the reversed order of their activation i.e. the last 
// activated default is the first element in the list of active defaults. 

// The default mechanism is evoked at the end of each alt statement, if due to the 
// actual snapshot none of the specified alternatives could be executed. An evoked 
// default mechanism invokes the first altstep in the list of defaults, i.e. the last
// activated default, and waits for the result of its termination. The termination can 
// be successful or unsuccessful.

// In the case of an unsuccessful termination, the default mechanism invokes the next 
// default in the list.

// In the case of a successful termination, the default ... the main control flow of the 
// test component will continue immediately after the alt statement from which the default
// mechanism was called...

// Note: 
// In this test case, two altsteps are activated as defaults. The last activated doesn't 
// match, which should lead to invokation of the default activated as the first one.

module Sem_200501_the_default_mechanism_005 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		port P p;
	}
	
	altstep a1() runs on GeneralComp {
		[] p.receive(integer:?) {
			setverdict(pass, "First default");
		}
	}

	altstep a2() runs on GeneralComp {
		[] p.receive(integer:1) { // no match
			setverdict(fail, "Last default");
		}
	}
	
	testcase TC_Sem_200501_the_default_mechanism_005() runs on GeneralComp {
		activate(a1());
		activate(a2());
		p.send(integer:5);
		alt {
			[] p.receive(integer:0) { // not expected: leads to default invocation
				setverdict(fail);
			}
		}
	}

	control{
		execute(TC_Sem_200501_the_default_mechanism_005());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.1, verify stop command behaviour in invoked default
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// In the case of a successful termination, the default may either stop the test component 
// by means of a stop statement

module Sem_200501_the_default_mechanism_008 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		port P p;
	}
	
	altstep a() runs on GeneralComp {
		[] p.receive(integer:?) {			
			setverdict(pass, "Default value -> stopping component");
			stop;
		}
	}
	
	testcase TC_Sem_200501_the_default_mechanism_008() runs on GeneralComp {
		activate(a());
		p.send(integer:5);
		alt {
			[] p.receive(integer:1) { // not expected: invoking default
				setverdict(fail);
			}
		}
		setverdict(fail, "Component stop expected");
	}

	control{
		execute(TC_Sem_200501_the_default_mechanism_008());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.1, verify repeat command behaviour in invoked default
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// In the case of a successful termination, ... the test component will take new 
// snapshot and re-evaluate the alt statement. The latter has to be specified by 
// means of a repeat statement.

module Sem_200501_the_default_mechanism_006 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		var integer vc_messageCounter := 0;
		port P p;
	}
	
	altstep a() runs on GeneralComp {
		[] p.receive(integer:?) {
			vc_messageCounter := vc_messageCounter + 1;
			setverdict(pass, "Default value -> repeating alt");
			repeat;
		}
	}
	
	testcase TC_Sem_200501_the_default_mechanism_006() runs on GeneralComp {
		activate(a());
		p.send(integer:5);
		p.send(integer:1);
		alt {
			[] p.receive(integer:1) {
				vc_messageCounter := vc_messageCounter + 1;
				setverdict(pass);
			}
		}
		if (vc_messageCounter != 2) { 
			setverdict(fail, "Different number of received messages (", vc_messageCounter, ") than expected (2)");
		}
	}

	control{
		execute(TC_Sem_200501_the_default_mechanism_006());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.1, verify break command behaviour in invoked default
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// If the execution of the selected top alternative of the default ends with a break statement 
// the control flow of the test component will continue immediately after the alt statement.

module Sem_200501_the_default_mechanism_007 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		var integer vc_messageCounter := 0;
		port P p;
	}
	
	altstep a() runs on GeneralComp {
		[] p.receive(integer:?) {
			vc_messageCounter := vc_messageCounter + 1;
			if (vc_messageCounter == 2) {
				setverdict(pass, "Message count full, terminating alt");
				break;
			}
			setverdict(pass, "Default value -> repeating alt");
			repeat;
		}
	}
	
	testcase TC_Sem_200501_the_default_mechanism_007() runs on GeneralComp {
		activate(a());
		p.send(integer:5);
		p.send(integer:0);
		p.send(integer:1);
		alt {
			[] p.receive(integer:1) { // not expected: break should occur first
				vc_messageCounter := vc_messageCounter + 1;
				setverdict(fail);
			}
		}
		if (vc_messageCounter != 2) { 
			setverdict(fail, "Different number of received messages (", vc_messageCounter, ") than expected (2)");
		}
	}

	control{
		execute(TC_Sem_200501_the_default_mechanism_007());
	}
}
/***************************************************
 ** @author   STF 470
 ** @version  0.0.1
 ** @purpose  1:20.5.1, verify that default are processed in interleave
 ** @verdict  pass accept, ttcn3verdict:pass
 ***************************************************/

// The following requirement is tested:
// The default mechanism is evoked at the end of each alt statement, if due to the 
// actual snapshot none of the specified alternatives could be executed. An evoked 
// default mechanism invokes the first altstep in the list of defaults, i.e. the last
// activated default, and waits for the result of its termination. The termination can 
// be successful or unsuccessful.

// In particular, the test case is related to the NOTE 1: 
// An interleave statement is semantically equivalent to a nested set of alt statements 
// and the default mechanism also applies to each of these alt statements. This means, 
// the default mechanism also applies to interleave statements. Furthermore, the restrictions 
// imposed on interleave statements in clause 20.4 do not apply to altsteps that are 
// activated as default behaviour for interleave statements.

module Sem_200501_the_default_mechanism_002 { 

	type port P message {
		inout integer;
	}
	
	type component GeneralComp {
		port P p;
	}
	
	altstep a() runs on GeneralComp {
		[] p.receive(integer:?) {
			setverdict(pass); 
		}
	}

	testcase TC_Sem_200501_the_default_mechanism_002() runs on GeneralComp {
		activate(a());
		p.send(integer:1);
		p.send(integer:2);
		interleave {
			[] p.receive(integer:5) { // not expected: leads to default invocation
				setverdict(fail);
			}
			[] p.receive(integer:2) { // not expected: the first default causes exit from interleave
				setverdict(fail);
			}
		}
	}

	control{
		execute(TC_Sem_200501_the_default_mechanism_002());
	}
}
/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20, Ensure that alt-statements are accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_20_TopLevel_001 {

type port MyPort message {
    inout charstring
}

type component GeneralComp { 
    port MyPort p;
}

template charstring m_test := "ping";

testcase TC_Syn_20_TopLevel_001() runs on GeneralComp {
    var boolean guard := false;
    p.send(m_test);
    alt {
        [] p.receive(m_test) {
            setverdict(pass);
        }
        [guard == true] p.receive(m_test) {
            setverdict(fail);
        }
        [else] {
            setverdict(fail);
        }
    }
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20, Ensure that defaults and the activate statement is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_20_TopLevel_005 {

type port MyPort message {
    inout charstring
}

type component GeneralComp { 
    port MyPort p;
}

template charstring m_testOne := "ping1";
template charstring m_testTwo := "ping2";

altstep a_catchError() runs on GeneralComp {
    [] any port.receive {
    }
}

testcase TC_Syn_20_TopLevel_005() runs on GeneralComp {
    var default v_errorDefault := activate(a_catchError());
    p.send(m_testOne);
    alt {
        [] p.receive(m_testOne) {
        }
    }
    deactivate(v_errorDefault);
    setverdict(pass);
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20, Ensure that defaults and the activate statement is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_20_TopLevel_004 {

type port MyPort message {
    inout charstring
}

type component GeneralComp { 
    port MyPort p;
}

template charstring m_testOne := "ping1";
template charstring m_testTwo := "ping2";

altstep a_catchError() runs on GeneralComp {
    [] any port.receive {
    }
}

testcase TC_Syn_20_TopLevel_004() runs on GeneralComp {
    var default v_errorDefault := activate(a_catchError());
    p.send(m_testOne);
    alt {
        [] p.receive(m_testOne) {
        }
    }
    setverdict(pass);
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20, Ensure that the interleave-statement is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_20_TopLevel_003 {

type port MyPort message {
	inout charstring
}

type component GeneralComp { 
	port MyPort p;
}

template charstring m_testOne := "ping1";
template charstring m_testTwo := "ping2";

testcase TC_Syn_20_TopLevel_003() runs on GeneralComp {
	p.send(m_testOne);
	p.send(m_testTwo);
	interleave {
		[] p.receive(m_testOne) {
		}
		[] p.receive(m_testTwo) {
		}
	}
	setverdict(pass);
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20, Ensure that repeat in an alt-statement is accepted.
 ** @verdict  pass accept, noexecution
 *****************************************************************/

module Syn_20_TopLevel_002 {

type port MyPort message {
    inout charstring
}

type component GeneralComp { 
    port MyPort p;
}

template charstring m_test := "ping";

testcase TC_Syn_20_TopLevel_002() runs on GeneralComp {
    var integer counter := 1;
    p.send(m_test);
    alt {
        [counter == 1] p.receive(m_test) {
            counter := counter + 1;
            repeat;
        }
        [else] {
            setverdict(pass);
        }
    }
}

}/*****************************************************************
 ** @author   STF 409
 ** @version  0.0.1
 ** @purpose  1:20.3, Ensure that the IUT correctly processes repeat statements
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

module Sem_2003_the_repeat_statement_001 {

    type port loopbackPort message {
        inout charstring
    }

    type component GeneralComp {
        port loopbackPort p;
    }

    template charstring m_test := "ping";

    testcase TC_Sem_2003_the_repeat_statement_001() runs on GeneralComp {
        timer t:= 5.0;
        var integer counter := 1;

        p.send(m_test);
        p.send(m_test);

        t.start;
        alt {
            [counter == 1] p.receive(m_test) {
                counter := 2;
                repeat;
            }
            [counter == 2] p.receive(m_test) {
                setverdict(pass);
            }
            [] t.timeout {
                setverdict(fail);
            }
        }
    }

    control {
        execute(TC_Sem_2003_the_repeat_statement_001());
    }

}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:20.2, repeat in procedure call block
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirement is tested:
// When used in statement blocks of the response and exception handling parts
// of blocking procedure calls, the repeat statement causes the re-evaluation
// of the response and exception handling part of the call (see clause 22.3.1).

module Sem_2003_the_repeat_statement_002 {

    signature S();
    
    type port MyPort procedure {
        inout S;
    }
    
    type component GeneralComp { 
	    port MyPort p;
    }
    
    function f_mirror() runs on GeneralComp {
        p.getcall(S:?);
        p.reply(S:{});
    }
        
    testcase TC_Sem_2003_the_repeat_statement_002() runs on GeneralComp system GeneralComp {
        var GeneralComp v_ptc[2];
        var integer v_counter := 0;
        for(var integer i := 0; i < lengthof(v_ptc); i := i + 1) {
            v_ptc[i] := GeneralComp.create;
            connect(self:p, v_ptc[i]:p);
            v_ptc[i].start(f_mirror());
        }        
	    p.call(S:{}) to all component { // broadcast call (several replies expected)
            [] p.getreply(S:?) {
                v_counter := v_counter + 1;
                if (v_counter < lengthof(v_ptc)) { repeat; } // tested repeat
                else { setverdict(pass); }
            }
	    }
    }
    
    control {
	    execute(TC_Sem_2003_the_repeat_statement_002());
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:20.2, repeat in alstep branch of alt statements
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirement is tested:
// If a repeat statement is used in a top alternative in an altstep definition,
// it causes a new snapshot and the re-evaluation of the alt statement from 
// which the altstep has been called. The call of the altstep may either be 
// done implicitly by the default mechanism (see clause 20.5.1) or explicitly
// in the alt statement (see clause 20.2).

module Sem_2003_the_repeat_statement_003 {
    
    type port MyPort message {
        inout charstring;
    }
    
    type component GeneralComp { 
	    port MyPort p;
    }
        
    altstep a_receiveAny() runs on GeneralComp {
        [] p.receive(charstring:?) {
            repeat;
        }
    }
    
    testcase TC_Sem_2003_the_repeat_statement_003() runs on GeneralComp {
        p.send(charstring:"foo");
        p.send(charstring:"bar");
        alt {
            [] p.receive(charstring:"bar") {
                setverdict(pass);
            }
            [] a_receiveAny();
        }
    }
    
    control {
	    execute(TC_Sem_2003_the_repeat_statement_003());
    }
}/*****************************************************************
 ** @author   STF 487
 ** @version  0.0.1
 ** @purpose  1:20.2, repeat in executed default
 ** @verdict  pass accept, ttcn3verdict:pass
 *****************************************************************/

// The following requirement is tested:
// If a repeat statement is used in a top alternative in an altstep definition,
// it causes a new snapshot and the re-evaluation of the alt statement from 
// which the altstep has been called. The call of the altstep may either be 
// done implicitly by the default mechanism (see clause 20.5.1) or explicitly
// in the alt statement (see clause 20.2).

module Sem_2003_the_repeat_statement_004 {
    
    type port MyPort message {
        inout charstring;
    }
    
    type component GeneralComp { 
	    port MyPort p;
    }
        
    altstep a_receiveAny() runs on GeneralComp {
        [] p.receive(charstring:?) {
            repeat;
        }
    }
    
    testcase TC_Sem_2003_the_repeat_statement_004() runs on GeneralComp {
        p.send(charstring:"foo");
        p.send(charstring:"bar");
        activate(a_receiveAny());
        alt {
            [] p.receive(charstring:"bar") {
                setverdict(pass);
            }
        }
    }
    
    control {
	    execute(TC_Sem_2003_the_repeat_statement_004());
    }
}
